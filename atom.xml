<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>荒原饮露</title>
  
  <subtitle>可能是未来的架构师，也可能送外卖。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.missf.top/"/>
  <updated>2021-05-22T08:53:50.000Z</updated>
  <id>https://www.missf.top/</id>
  
  <author>
    <name>荒原饮露</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运维备忘录</title>
    <link href="https://www.missf.top/post/78df5ed2.html"/>
    <id>https://www.missf.top/post/78df5ed2.html</id>
    <published>2021-05-22T08:53:50.000Z</published>
    <updated>2021-05-22T08:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运维备忘录"><a href="#运维备忘录" class="headerlink" title="运维备忘录"></a>运维备忘录</h1><blockquote><p>由于我们脑⼒有限，忘性却很好，所以就有了这个文档。</p></blockquote><p>Kubernetes 在容器中执行命令</p><pre class="line-numbers language-shell"><code class="language-shell">官方示例 kubectl exec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...] kubectl exec -it $i -- date 等同于 kubectl exec -it $i -- sh -c 'date' (COMMAND==sh -c,args=='date')记录缘由for i in $(kubectl get pod | grep tomcat | awk '{print $1}'); do kubectl exec -it $i -- sh -c 'rm -rf webapps;mv webapps.dist webapps'; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不生成文件末尾的换行符</p><pre class="line-numbers language-shell"><code class="language-shell">[root@k8s-master ~/kubernetes/configmap]# echo 'qdqfewf' > test[root@k8s-master ~/kubernetes/configmap]# cat -A test qdqfewf$[root@k8s-master ~/kubernetes/configmap]# echo -n 'qdqfewf' > test[root@k8s-master ~/kubernetes/configmap]# cat -A testqdqfewf[root@k8s-master ~/kubernetes/configmap]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运维备忘录&quot;&gt;&lt;a href=&quot;#运维备忘录&quot; class=&quot;headerlink&quot; title=&quot;运维备忘录&quot;&gt;&lt;/a&gt;运维备忘录&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;由于我们脑⼒有限，忘性却很好，所以就有了这个文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes 学习笔记</title>
    <link href="https://www.missf.top/post/7f42a634.html"/>
    <id>https://www.missf.top/post/7f42a634.html</id>
    <published>2021-03-08T10:46:59.000Z</published>
    <updated>2021-08-27T06:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>此文档仅为个人的学习笔记，记录下来是为了以后遗忘时可以翻阅。最好的 Kubernetes 文档在 <a href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noopener">kubernetes.io</a>，请大家去官网学习！</p></blockquote><h2 id="Kubernetes-是什么？"><a href="#Kubernetes-是什么？" class="headerlink" title="Kubernetes 是什么？"></a>Kubernetes 是什么？</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p><p>名称 Kubernetes 源于希腊语，意为“舵手”或“飞行员”。Google 在 2014 年开源了 Kubernetes 项目， Kubernetes 建立在 <a href="https://research.google/pubs/pub43438" target="_blank" rel="noopener">Google 在大规模运行生产工作负载方面拥有十几年的经验</a> 的基础上，结合了社区中最好的想法和实践。</p><h3 id="时光回溯"><a href="#时光回溯" class="headerlink" title="时光回溯"></a>时光回溯</h3><p>让我们回顾一下为什么 Kubernetes 如此有用。</p><p><strong>传统部署时代</strong>：</p><p>早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。</p><p><strong>虚拟化部署时代：</strong></p><p>作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息不能被另一应用程序随意访问。</p><p>虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序而可以实现更好的可伸缩性，降低硬件成本等等。</p><p>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</p><p><strong>容器部署时代：</strong></p><p>容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p><p>容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：</p><ul><li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。</li><li>可观察性不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li><li>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li><li>资源隔离：可预测的应用程序性能。</li><li>资源利用：高效率和高密度。</li></ul><h3 id="Kubernetes-能做什么？"><a href="#Kubernetes-能做什么？" class="headerlink" title="Kubernetes 能做什么？"></a>Kubernetes 能做什么？</h3><p>容器是打包和运行应用程序的最好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果由系统处理此行为，会不会更容易？</p><p>这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p><p>Kubernetes 为你提供：</p><ul><li><p>服务发现和负载均衡</p><p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p>存储编排</p><p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p>自动部署和回滚</p><p>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p></li><li><p>自动完成装箱计算</p><p>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p>自我修复</p><p>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p>密钥与配置管理</p><p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><h3 id="Kubernetes-不是什么？"><a href="#Kubernetes-不是什么？" class="headerlink" title="Kubernetes 不是什么？"></a>Kubernetes 不是什么？</h3><p>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。</p><p>Kubernetes：</p><ul><li><p>不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</p></li><li><p>不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。</p></li><li><p>不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， <a href="https://openservicebrokerapi.org/" target="_blank" rel="noopener">开放服务代理</a>）来访问。</p></li><li><p>不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。</p></li><li><p>不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。</p></li><li><p>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。</p></li><li><p>此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。</p></li></ul><h2 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h2><p>当你部署完 Kubernetes, 即拥有了一个完整的集群。</p><p>一个 Kubernetes 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p><p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p><p>本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。</p><h3 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）</h3><p>控制平面的组件对集群做出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 pod）。</p><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机（一般使用 master 节点）上启动所有控制平面组件，并且不会在此计算机上运行用户容器。 </p><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p><p>Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>你的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p><p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/" target="_blank" rel="noopener">etcd 文档</a>。</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>在主节点上运行控制器的组件。</p><p>从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li><p>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应</p></li><li><p>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod</p></li><li><p>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</p></li><li><p>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</p></li></ul><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都运行在 Pod 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p>kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p><h4 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）</h4><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener">Kubernetes CRI (容器运行环境接口)</a>。</p><h3 id="插件（Addons）"><a href="#插件（Addons）" class="headerlink" title="插件（Addons）"></a>插件（Addons）</h3><p>插件使用 Kubernetes 资源（DaemonSet、 Deployment等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h4 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）</h4><p><a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">Dashboard</a> 是Kubernetes 集群的通用、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h4><p>为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。</p><h4 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控</h4><p>容器资源监控将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面，参考 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus 项目</a> 结合 <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana 项目</a>。</p><h4 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志</h4><p><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">集群层面日志</a> 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p><h2 id="Kubernetes-API"><a href="#Kubernetes-API" class="headerlink" title="Kubernetes API"></a>Kubernetes API</h2><p>Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。</p><p>Kubernetes API 使你可以查询和操纵 Kubernetes API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。</p><p>大部分操作都可以通过 kubectl 命令行接口或类似 kubeadm 这类命令行工具来执行， 这些工具在背后也是调用 API。不过，你也可以使用 REST 调用来访问这些 API。</p><h2 id="使用-Kubernetes-对象"><a href="#使用-Kubernetes-对象" class="headerlink" title="使用 Kubernetes 对象"></a>使用 Kubernetes 对象</h2><h3 id="理解-Kubernetes-对象"><a href="#理解-Kubernetes-对象" class="headerlink" title="理解 Kubernetes 对象"></a>理解 Kubernetes 对象</h3><p>本页说明了 Kubernetes 对象在 Kubernetes API 中是如何表示的，以及如何在 <code>.yaml</code> 格式的文件中表示。</p><h4 id="理解-Kubernetes-对象-1"><a href="#理解-Kubernetes-对象-1" class="headerlink" title="理解 Kubernetes 对象"></a>理解 Kubernetes 对象</h4><p>在 Kubernetes 系统中，Kubernetes 对象是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：</p><ul><li>哪些容器化应用在运行（以及在哪些节点上运行）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。 通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的， 这就是 Kubernetes 集群的期望状态（Desired State）。</p><p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 都需要使用 <a href="https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api" target="_blank" rel="noopener">Kubernetes API</a>。 比如，当使用 kubectl 命令行接口时，CLI 会执行必要的 Kubernetes API 调用， 也可以在程序中使用 <a href="https://kubernetes.io/zh/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">客户端库</a>直接调用 Kubernetes API。</p><h4 id="对象规约（Spec）与状态（Status）"><a href="#对象规约（Spec）与状态（Status）" class="headerlink" title="对象规约（Spec）与状态（Status）"></a>对象规约（Spec）与状态（Status）</h4><p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 <code>spec</code>（规约）和对象 <code>status</code>（状态） 。 对于具有 <code>spec</code> 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： 期望状态（Desired State） 。</p><p><code>status</code> 描述了对象的当前状态（Current State），它是由 Kubernetes 系统和组件设置并更新的。在任何时刻，Kubernetes <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane" target="_blank" rel="noopener">控制平面</a> 都一直积极地管理着对象的实际状态，以使之与期望状态相匹配。</p><h4 id="描述-Kubernetes-对象"><a href="#描述-Kubernetes-对象" class="headerlink" title="描述 Kubernetes 对象"></a>描述 Kubernetes 对象</h4><p>创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>）， API 请求必须在请求体中包含 JSON 格式的信息。 大多数情况下，需要在 <code>.yaml</code> 文件中为 <code>kubectl</code> 提供这些信息。<code>kubectl</code> 在发起 API 请求时，会将这些信息转换成 JSON 格式。</p><h4 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h4><p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p><ul><li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li><li><code>kind</code> - 想要创建的对象的类别</li><li><code>metadata</code> - 帮助唯一性标识对象的一些数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li></ul><h3 id="Kubernetes-对象管理"><a href="#Kubernetes-对象管理" class="headerlink" title="Kubernetes 对象管理"></a>Kubernetes 对象管理</h3><h4 id="命令式命令"><a href="#命令式命令" class="headerlink" title="命令式命令"></a>命令式命令</h4><p>用命令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给 <code>kubectl</code> 命令作为参数或标志。</p><p>这是开始或者在集群中运行一次性任务的最简单方法。因为这个技术直接在活动对象上操作，所以它不提供以前配置的历史记录。</p><p>通过创建 Deployment 对象来运行 nginx 容器的实例：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl run nginx --image nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h4><p>在命令式对象配置中，kubectl 命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。</p><p>创建配置文件中定义的对象：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create -f nginx.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="对象名称和-IDs"><a href="#对象名称和-IDs" class="headerlink" title="对象名称和 IDs"></a>对象名称和 IDs</h3><p>集群中的每一个对象都有一个名称来标识在同类资源中的唯一性。</p><p>每个 Kubernetes 对象也有一个 UID 来标识在整个集群中的唯一性。</p><p>比如，在同一个名字空间中有一个名为 myapp-1234 的 Pod, 但是可以命名一个 Pod 和一个 Deployment 同为 myapp-1234.</p><p>对于用户提供的非唯一性的属性，Kubernetes 提供了 标签（Labels）和 注解（Annotation）机制。</p><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><p>Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群。 这些虚拟集群被称为名字空间。</p><h4 id="何时使用多个名字空间"><a href="#何时使用多个名字空间" class="headerlink" title="何时使用多个名字空间"></a>何时使用多个名字空间</h4><p>名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。当需要名称空间提供的功能时，请开始使用它们。</p><p>名字空间为名称提供了一个范围。资源的名称需要在名字空间内是唯一的，但不能跨名字空间。 名字空间不能相互嵌套，每个 Kubernetes 资源只能在一个名字空间中。</p><p>名字空间是在多个用户之间划分集群资源的一种方法（通过资源配额）。</p><p>不需要使用多个名字空间来分隔轻微不同的资源，例如同一软件的不同版本： 使用标签来区分同一名字空间中的不同资源。</p><h4 id="使用名字空间"><a href="#使用名字空间" class="headerlink" title="使用名字空间"></a>使用名字空间</h4><p>名字空间的创建和删除在<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/namespaces/" target="_blank" rel="noopener">名字空间的管理指南文档</a>描述。</p><p><strong>说明：</strong> 避免使用前缀 <code>kube-</code> 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。</p><h5 id="查看名字空间"><a href="#查看名字空间" class="headerlink" title="查看名字空间"></a>查看名字空间</h5><p>你可以使用以下命令列出集群中现存的名字空间：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get namespace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Kubernetes 会创建四个初始名字空间：</p><ul><li><code>default</code> 没有指明使用其它名字空间的对象所使用的默认名字空间。</li><li><code>kube-system</code> Kubernetes 系统创建对象所使用的名字空间。</li><li><code>kube-public</code> 这个名字空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。 这个名字空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个名字空间的公共方面只是一种约定，而不是要求。</li><li><code>kube-node-lease</code> 此名字空间用于与各个节点相关的租期（Lease）对象； 此对象的设计使得集群规模很大时节点心跳检测性能得到提升。</li></ul><h5 id="为请求设置名字空间"><a href="#为请求设置名字空间" class="headerlink" title="为请求设置名字空间"></a>为请求设置名字空间</h5><p>要为当前请求设置名字空间，请使用 <code>--namespace</code> 参数。</p><p>例如：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl run nginx --image=nginx --namespace=<名字空间名称>kubectl get pods --namespace=<名字空间名称><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="设置名字空间偏好"><a href="#设置名字空间偏好" class="headerlink" title="设置名字空间偏好"></a>设置名字空间偏好</h5><p>你可以永久保存名字空间，以用于对应上下文中所有后续 kubectl 命令。</p><h4 id="名字空间和-DNS"><a href="#名字空间和-DNS" class="headerlink" title="名字空间和 DNS"></a>名字空间和 DNS</h4><p>当你创建一个服务 时， Kubernetes 会创建一个相应的 DNS 条目。</p><p>该条目的形式是 &lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local，这意味着如果容器只使用 &lt;服务名称&gt;，它将被解析到本地名字空间的服务。这对于跨多个名字空间（如开发、分级和生产） 使用相同的配置非常有用。如果你希望跨名字空间访问，则需要使用完全限定域名（FQDN）。</p><h4 id="并非所有对象都在名字空间中"><a href="#并非所有对象都在名字空间中" class="headerlink" title="并非所有对象都在名字空间中"></a>并非所有对象都在名字空间中</h4><p>大多数 kubernetes 资源（例如 Pod、Service、副本控制器等）都位于某些名字空间中。 但是名字空间资源本身并不在名字空间中。而且底层资源，例如 <a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">节点</a> 和持久化卷不属于任何名字空间。</p><p>查看哪些 Kubernetes 资源在名字空间中，哪些不在名字空间中：</p><pre class="line-numbers language-shell"><code class="language-shell"># 位于名字空间中的资源kubectl api-resources --namespaced=true# 不在名字空间中的资源kubectl api-resources --namespaced=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标签和选择算符"><a href="#标签和选择算符" class="headerlink" title="标签和选择算符"></a>标签和选择算符</h3><p>标签（Labels）是附加到 Kubernetes 对象（比如 Pods）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。</p><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。</p><p>服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。 管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。</p><p>示例标签：</p><ul><li><code>&quot;release&quot; : &quot;stable&quot;</code>, <code>&quot;release&quot; : &quot;canary&quot;</code></li><li><code>&quot;environment&quot; : &quot;dev&quot;</code>, <code>&quot;environment&quot; : &quot;qa&quot;</code>, <code>&quot;environment&quot; : &quot;production&quot;</code></li><li><code>&quot;tier&quot; : &quot;frontend&quot;</code>, <code>&quot;tier&quot; : &quot;backend&quot;</code>, <code>&quot;tier&quot; : &quot;cache&quot;</code></li><li><code>&quot;partition&quot; : &quot;customerA&quot;</code>, <code>&quot;partition&quot; : &quot;customerB&quot;</code></li><li><code>&quot;track&quot; : &quot;daily&quot;</code>, <code>&quot;track&quot; : &quot;weekly&quot;</code></li></ul><p>这些只是常用标签的例子; 你可以任意制定自己的约定。请记住，对于给定对象标签的键必须是唯一的。</p><h4 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h4><p>标签是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（/）分隔。 名称段是必需的，必须小于等于 63 个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 带有破折号（-），下划线（_），点（ .）和之间的字母数字。 前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（.）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（/）。</p><p>如果省略前缀，则假定标签键对用户是私有的。 向最终用户对象添加标签的自动系统组件（例如 kube-scheduler、kube-controller-manager、 kube-apiserver、kubectl 或其他第三方自动化工具）必须指定前缀。</p><p>kubernetes.io/ 前缀是为 Kubernetes 核心组件保留的。</p><p>有效标签值必须为 63 个字符或更少，并且必须为空或以字母数字字符（[a-z0-9A-Z]）开头和结尾， 中间可以包含破折号（-）、下划线（_）、点（.）和字母或数字。</p><h4 id="标签选择算符"><a href="#标签选择算符" class="headerlink" title="标签选择算符"></a>标签选择算符</h4><p>与名称和 UID 不同， 标签不支持唯一性。通常，我们希望许多对象携带相同的标签。</p><p>通过 标签选择算符，客户端/用户可以识别一组对象。标签选择算符是 Kubernetes 中的核心分组原语。</p><p>API 目前支持两种类型的选择算符：基于等值的 和 基于集合的。标签选择算符可以由逗号分隔的多个 需求 组成。 在多个需求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑 与（&amp;&amp;）运算符。</p><p>空标签选择算符或者未指定的选择算符的语义取决于上下文， 支持使用选择算符的 API 类别应该将算符的合法性和含义用文档记录下来。</p><h5 id="基于等值的需求"><a href="#基于等值的需求" class="headerlink" title="基于等值的需求"></a>基于等值的需求</h5><p>基于等值 或 基于不等值 的需求允许按标签键和值进行过滤。 匹配对象必须满足所有指定的标签约束，尽管它们也可能具有其他标签。 可接受的运算符有 = 、 == 和 != 三种。 前两个表示相等（并且只是同义词），而后者表示不相等。例如：</p><pre class="line-numbers language-shell"><code class="language-shell">environment = productiontier != frontend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="基于集合的需求"><a href="#基于集合的需求" class="headerlink" title="基于集合的需求"></a>基于集合的需求</h5><p>基于集合 的标签需求允许你通过一组值来过滤键。 支持三种操作符：in、notin 和 exists (只可以用在键标识符上)。例如：</p><pre class="line-numbers language-shell"><code class="language-shell">environment in (production, qa)tier notin (frontend, backend)partition!partition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一个示例选择了所有键等于 environment 并且值等于 production 或者 qa 的资源。</li><li>第二个示例选择了所有键等于 tier 并且值不等于 frontend 或者 backend 的资源，以及所有没有 tier 键标签的资源。</li><li>第三个示例选择了所有包含了有 partition 标签的资源；没有校验它的值。</li><li>第四个示例选择了所有没有 partition 标签的资源；没有校验它的值。 类似地，逗号分隔符充当 与 运算符。因此，使用 partition 键（无论为何值）和 environment 不同于 qa 来过滤资源可以使用 partition, environment notin（qa) 来实现。</li></ul><p>基于集合的标签选择算符是相等标签选择算符的一般形式，因为 environment=production 等同于 environment in（production）；!= 和 notin 也是类似的。</p><p>基于集合的要求可以与基于相等的要求混合使用。例如：partition in (customerA, customerB),environment!=qa。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>你可以使用 Kubernetes 注解为对象附加任意的非标识的元数据。客户端程序（例如工具和库）能够获取这些元数据信息。</p><h5 id="为对象附加元数据"><a href="#为对象附加元数据" class="headerlink" title="为对象附加元数据"></a>为对象附加元数据</h5><p>你可以使用标签或注解将元数据附加到 Kubernetes 对象。 标签可以用来选择对象和查找满足某些条件的对象集合。 相反，注解不用于标识和选择对象。 注解中的元数据，可以很小，也可以很大，可以是结构化的，也可以是非结构化的，能够包含标签不允许的字符。</p><p>注解和标签一样，是键/值对:</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"annotations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"key1"</span> <span class="token operator">:</span> <span class="token string">"value1"</span><span class="token punctuation">,</span>    <span class="token property">"key2"</span> <span class="token operator">:</span> <span class="token string">"value2"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="语法和字符集-1"><a href="#语法和字符集-1" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p>注解（Annotations）存储的形式是键/值对。有效的注解键分为两部分： 可选的前缀和名称，以斜杠（/）分隔。 名称段是必需项，并且必须在63个字符以内，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 并允许使用破折号（-），下划线（_），点（.）和字母数字。 前缀是可选的。如果指定，则前缀必须是DNS子域：一系列由点（.）分隔的DNS标签， 总计不超过253个字符，后跟斜杠（/）。 如果省略前缀，则假定注解键对用户是私有的。 由系统组件添加的注解 （例如，kube-scheduler，kube-controller-manager，kube-apiserver，kubectl 或其他第三方组件），必须为终端用户添加注解前缀。</p><p>kubernetes.io/ 和 k8s.io/ 前缀是为 Kubernetes 核心组件保留的。</p><p>例如，下面是一个 Pod 的配置文件，其注解中包含 imageregistry: <a href="https://hub.docker.com/：" target="_blank" rel="noopener">https://hub.docker.com/：</a></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> annotations<span class="token punctuation">-</span>demo  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">imageregistry</span><span class="token punctuation">:</span> <span class="token string">"https://hub.docker.com/"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字段选择器"><a href="#字段选择器" class="headerlink" title="字段选择器"></a>字段选择器</h3><p>字段选择器（Field selectors）允许你根据一个或多个资源字段的值 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/kubernetes-objects" target="_blank" rel="noopener">筛选 Kubernetes 资源</a>。 下面是一些使用字段选择器查询的例子：</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>下面这个 kubectl 命令将筛选出 <code>status.phase</code> 字段值为 <code>Running</code> 的所有 Pod：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods --field-selector status.phase=Running<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="支持的字段"><a href="#支持的字段" class="headerlink" title="支持的字段"></a>支持的字段</h5><p>你可在字段选择器中使用 =、==和 != （= 和 == 的意义是相同的）操作符。 例如，下面这个 kubectl 命令将筛选所有不属于 default 命名空间的 Kubernetes 服务：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get services  --all-namespaces --field-selector metadata.namespace!=default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="链式选择器"><a href="#链式选择器" class="headerlink" title="链式选择器"></a>链式选择器</h5><p>同标签和其他选择器一样， 字段选择器可以通过使用逗号分隔的列表组成一个选择链。 下面这个 kubectl 命令将筛选 status.phase 字段不等于 Running 同时 spec.restartPolicy 字段等于 Always 的所有 Pod：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="多种资源类型"><a href="#多种资源类型" class="headerlink" title="多种资源类型"></a>多种资源类型</h5><p>你能够跨多种资源类型来使用字段选择器。 下面这个 kubectl 命令将筛选出所有不在 default 命名空间中的 StatefulSet 和 Service：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。 每个节点包含运行 Pods 所需的服务， 这些 Pods 由控制面负责管理。</p><p>通常集群中会有若干个节点；而在一个学习用或者资源受限的环境中，你的集群中也可能只有一个节点。</p><p>节点上的组件包括 kubelet、 容器运行时以及 kube-proxy。</p><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>向 API 服务器添加节点的方式主要有两种：</p><ol><li>节点上的 kubelet 向控制面执行自注册。</li><li>你，或者别的什么人，手动添加一个 Node 对象。</li></ol><p>在你创建了 Node 对象或者节点上的 kubelet 执行了自注册操作之后， 控制面会检查新的 Node 对象是否合法。例如，如果你使用下面的 JSON 对象来创建 Node 对象：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"Node"</span><span class="token punctuation">,</span>  <span class="token property">"apiVersion"</span><span class="token operator">:</span> <span class="token string">"v1"</span><span class="token punctuation">,</span>  <span class="token property">"metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"10.240.79.157"</span><span class="token punctuation">,</span>    <span class="token property">"labels"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"my-first-k8s-node"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Kubernetes 会在内部创建一个 Node 对象作为节点的表示。Kubernetes 检查 kubelet 向 API 服务器注册节点时使用的 metadata.name 字段是否匹配。 如果节点是健康的（即所有必要的服务都在运行中），则该节点可以用来运行 Pod。 否则，直到该节点变为健康之前，所有的集群活动都会忽略该节点。</p><h3 id="控制面到节点通信"><a href="#控制面到节点通信" class="headerlink" title="控制面到节点通信"></a>控制面到节点通信</h3><p>本文列举控制面节点（确切说是 API 服务器）和 Kubernetes 集群之间的通信路径。 目的是为了让用户能够自定义他们的安装，以实现对网络配置的加固，使得集群能够在不可信的网络上（或者在一个云服务商完全公开的 IP 上）运行。</p><h4 id="节点到控制面"><a href="#节点到控制面" class="headerlink" title="节点到控制面"></a>节点到控制面</h4><p>Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。 所有从集群（或所运行的 Pods）发出的 API 调用都终止于 apiserver（其它控制面组件都没有被设计为可暴露远程服务）。 apiserver 被配置为在一个安全的 HTTPS 端口（443）上监听远程连接请求， 并启用一种或多种形式的客户端身份认证机制。 一种或多种客户端鉴权机制应该被启用， 特别是在允许使用匿名请求 或服务账号令牌的时候。</p><p>应该使用集群的公共根证书开通节点，这样它们就能够基于有效的客户端凭据安全地连接 apiserver。 一种好的方法是以客户端证书的形式将客户端凭据提供给 kubelet。 请查看 kubelet TLS 启动引导 以了解如何自动提供 kubelet 客户端证书。</p><p>想要连接到 apiserver 的 Pod 可以使用服务账号安全地进行连接。 当 Pod 被实例化时，Kubernetes 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。 kubernetes 服务（位于所有名字空间中）配置了一个虚拟 IP 地址，用于（通过 kube-proxy）转发 请求到 apiserver 的 HTTPS 末端。</p><p>控制面组件也通过安全端口与集群的 apiserver 通信。</p><p>这样，从集群节点和节点上运行的 Pod 到控制面的连接的缺省操作模式即是安全的， 能够在不可信的网络或公网上运行。</p><h4 id="控制面到节点"><a href="#控制面到节点" class="headerlink" title="控制面到节点"></a>控制面到节点</h4><p>从控制面（apiserver）到节点有两种主要的通信路径。 第一种是从 apiserver 到集群中每个节点上运行的 kubelet 进程。 第二种是从 apiserver 通过它的代理功能连接到任何节点、Pod 或者服务。</p><h5 id="API-服务器到-kubelet"><a href="#API-服务器到-kubelet" class="headerlink" title="API 服务器到 kubelet"></a>API 服务器到 kubelet</h5><p>从 apiserver 到 kubelet 的连接用于：</p><ul><li>获取 Pod 日志</li><li>挂接（通过 kubectl）到运行中的 Pod</li><li>提供 kubelet 的端口转发功能。</li></ul><p>这些连接终止于 kubelet 的 HTTPS 末端。 默认情况下，apiserver 不检查 kubelet 的服务证书。这使得此类连接容易受到中间人攻击， 在非受信网络或公开网络上运行也是 不安全的。</p><p>为了对这个连接进行认证，使用 –kubelet-certificate-authority 标志给 apiserver 提供一个根证书包，用于 kubelet 的服务证书。</p><p>如果无法实现这点，又要求避免在非受信网络或公共网络上进行连接，可在 apiserver 和 kubelet 之间使用 SSH 隧道。</p><p>最后，应该启用 kubelet 用户认证和/或鉴权 来保护 kubelet API。</p><h5 id="apiserver-到节点、Pod-和服务"><a href="#apiserver-到节点、Pod-和服务" class="headerlink" title="apiserver 到节点、Pod 和服务"></a>apiserver 到节点、Pod 和服务</h5><p>从 apiserver 到节点、Pod 或服务的连接默认为纯 HTTP 方式，因此既没有认证，也没有加密。 这些连接可通过给 API URL 中的节点、Pod 或服务名称添加前缀 <code>https:</code> 来运行在安全的 HTTPS 连接上。 不过这些连接既不会验证 HTTPS 末端提供的证书，也不会提供客户端证书。 因此，虽然连接是加密的，仍无法提供任何完整性保证。 这些连接目前还不能安全地在非受信网络或公共网络上运行。</p><h2 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h2><p>工作负载是在 Kubernetes 上运行的应用程序。</p><p>无论你的负载是单一组件还是由多个一同工作的组件构成，在 Kubernetes 中你可以在一组 Pods 中运行它。 在 Kubernetes 中，Pod 代表的是集群上处于运行状态的一组容器。</p><p>Kubernetes Pods 有确定的生命周期。 例如，一旦某 Pod 在你的集群中运行，Pod 运行所在的节点出现致命错误时， 所有该节点上的 Pods 都会失败。Kubernetes 将这类失败视为最终状态：即使该节点后来恢复正常运行，你也需要创建新的 Pod 来恢复应用。</p><p>不过，为了让用户的日子略微好过一些，你并不需要直接管理每个 Pod。 相反，你可以使用负载资源来替你管理一组 Pods。 这些资源配置控制器来确保合适类型的、处于运行状态的 Pod 个数是正确的，与你所指定的状态相一致。</p><p>Kubernetes 提供若干种内置的工作负载资源：</p><ul><li>Deployment 和 ReplicaSet （替换原来的资源 ReplicationController）。 Deployment 很适合用来管理你的集群上的无状态应用，Deployment 中的所有 Pod 都是相互等价的，并且在需要的时候被换掉。</li><li>StatefulSet 让你能够运行一个或者多个以某种方式跟踪应用状态的 Pods。 例如，如果你的负载会将数据作持久存储，你可以运行一个 StatefulSet，将每个 Pod 与某个 PersistentVolume 对应起来。你在 StatefulSet 中各个 Pod 内运行的代码可以将数据复制到同一 StatefulSet 中的其它 Pod 中以提高整体的服务可靠性。</li><li>DaemonSet 定义提供节点本地支撑设施的 Pods。这些 Pods 可能对于你的集群的运维是非常重要的，例如作为网络链接的辅助工具或者作为网络插件的一部分等等。每次你向集群中添加一个新节点时，如果该节点与某 DaemonSet 的规约匹配，则控制面会为该 DaemonSet 调度一个 Pod 到该新节点上运行。</li><li>Job 和 CronJob。 定义一些一直运行到结束并停止的任务。Job 用来表达的是一次性的任务，而 CronJob 会根据其时间规划反复运行。</li></ul><h3 id="pods"><a href="#pods" class="headerlink" title="pods"></a>pods</h3><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><p>Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。</p><p>除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 Init 容器。 你也可以在集群中支持临时性容器 的情况外，为调试的目的注入临时性容器。</p><h4 id="什么是-Pod？"><a href="#什么是-Pod？" class="headerlink" title="什么是 Pod？"></a>什么是 Pod？</h4><p>说明： 除了 Docker 之外，Kubernetes 支持很多其他容器运行时（容器运行时是负责运行容器的软件）， Docker 是最有名的运行时， 使用 Docker 的术语来描述 Pod 会很有帮助。</p><p>Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面，即用来隔离 Docker 容器的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。</p><p>就 Docker 概念的术语而言，Pod 类似于共享名字空间和文件系统卷的一组 Docker 容器。</p><h4 id="使用-Pod"><a href="#使用-Pod" class="headerlink" title="使用 Pod"></a>使用 Pod</h4><p>通常你不需要直接创建 Pod，甚至单实例 Pod。 相反，你会使用诸如 Deployment 或 Job 这类工作负载资源来创建 Pod。如果 Pod 需要跟踪状态， 可以考虑 StatefulSet 资源。</p><p>Kubernetes 集群中的 Pod 主要有两种用法：</p><ul><li>运行单个容器的 Pod。“每个 Pod 一个容器” 模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li><li>运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的 “挂斗”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。</li></ul><p>说明： 将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。</p><p>每个 Pod 都旨在运行给定应用程序的单个实例。如果希望横向扩展应用程序（例如，运行多个实例以提供更多的资源），则应该使用多个 Pod，每个实例使用一个 Pod。 在 Kubernetes 中，这通常被称为副本（Replication）。 通常使用一种工作负载资源及其控制器来创建和管理一组 Pod 副本。</p><h3 id="工作负载资源"><a href="#工作负载资源" class="headerlink" title="工作负载资源"></a>工作负载资源</h3><p>工作负载是指在 Kubernetes 上运行的应用程序，一个 pod 可以运行一个或多个工作负载。工作负载资源是用来管理一组 pod 的，确保这些被管理的 pod ，处于我们期望的运行状态。</p><h4 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h4><p>一个 Deployment 为 Pods （pod 表示集群上正在运行的一组容器） 和 ReplicaSets （下一代副本控制器）提供声明式的更新能力。</p><p>你负责描述 Deployment 中的目标状态，而 Deployment 控制器（Controller）以受控速率更改实际状态， 使其变为期望状态。你可以定义 Deployment 以创建新的 ReplicaSet，或删除现有 Deployment， 并通过新的 Deployment 收养其资源。</p><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><h4 id="StatefulSets"><a href="#StatefulSets" class="headerlink" title="StatefulSets"></a>StatefulSets</h4><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p><p>StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p><p>和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><p>DaemonSet 的一些典型用法：</p><ul><li>在每个节点上运行集群守护进程</li><li>在每个节点上运行日志收集守护进程</li><li>在每个节点上运行监控守护进程</li></ul><p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。</p><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。</p><p>一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p><h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><p>CronJob 创建基于时间调度的 Jobs。</p><p>一个 CronJob 对象就像 crontab (cron table) 文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p><h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><p>ReplicationController 确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的</p><h4 id="ReplicationController-的替代方案"><a href="#ReplicationController-的替代方案" class="headerlink" title="ReplicationController 的替代方案"></a>ReplicationController 的替代方案</h4><p><strong>ReplicaSet</strong><br>ReplicaSet 是下一代 ReplicationController， 支持新的基于集合的标签选择算符。 它主要被 Deployment 用来作为一种编排 Pod 创建、删除及更新的机制。 请注意，我们推荐使用 Deployment 而不是直接使用 ReplicaSet，除非 你需要自定义更新编排或根本不需要更新。</p><p><strong>Deployment （推荐）</strong></p><p>Deployment 是一种更高级别的 API 对象， 它以类似于 kubectl rolling-update 的方式更新其底层 ReplicaSet 及其 Pod。 如果你想要这种滚动更新功能，那么推荐使用 Deployment，因为与 kubectl rolling-update 不同， 它们是声明式的、服务端的，并且具有其它特性。</p><h1 id="部署-Kubernetes-集群"><a href="#部署-Kubernetes-集群" class="headerlink" title="部署 Kubernetes 集群"></a>部署 Kubernetes 集群</h1><p>Kubernetes 官方提供多种部署方式：</p><ul><li>云解决方案</li><li>使用部署工具安装 Kubernetes</li><li>Windows Kubernetes</li></ul><p>我们这里使用部署工具来安装 Kubernetes，官方提供的工具主要有以下几个：</p><ul><li><p>Kubeadm：官方维护的为了给创建 Kubernetes 集群提供最佳实践的一个工具，涉及集群生命周期管理等知识。</p></li><li><p>Kops ：在 AWS 上安装 Kubernetes 集群。</p></li><li><p>Kubespray：Ansible 部署，OS 级别通用的部署方式，可以是裸机和云的环境。</p></li></ul><p>这里我们使用 Kubeadm 部署，这是官方推荐的部署方式，Kubeadm 可用于生产级别的集群部署。</p><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><ul><li><p>一台或多台运行着下列系统的机器：</p><ul><li>Ubuntu 16.04+</li><li>Debian 9+</li><li>CentOS 7+</li><li>Red Hat Enterprise Linux (RHEL) 7+</li><li>Fedora 25+</li><li>HypriotOS v1.0.1+</li><li>Flatcar Container Linux （使用 2512.3.0 版本测试通过）</li></ul></li><li><p>每台机器 2 GB 或更多的 RAM （如果少于这个数字将会影响你应用的运行内存)</p></li><li><p>2 CPU 核或更多</p></li><li><p>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</p></li><li><p>节点之中不可以有重复的主机名、MAC 地址或 product_uuid。</p></li><li><p>开启机器上的某些端口（Kubernetes 服务所占用的端口必须开启）</p></li><li><p>禁用交换分区。为了保证 kubelet 正常工作，你必须禁用交换分区。</p></li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>节点准备</p><pre class="line-numbers language-shell"><code class="language-shell">k8s-master 10.10.110.190k8s-ndoe1  10.10.110.191k8s-node2  10.10.110.192Operating System: Ubuntu 18.04.5 LTS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结构图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5fb8cee7b18d6271134d01e7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>配置节点</p><pre class="line-numbers language-shell"><code class="language-shell"># 关闭防火墙systemctl stop ufwufw disable# 检查所有节点网络接口的mac地址和product_uuid唯一性ip linkcat /sys/class/dmi/id/product_uuid# 禁用swap分区swapoff -a# 设置主机名hostnamectl set-hostname [hostname]# 配置hosts解析    cat >> /etc/hosts << EOF    10.10.110.190 k8s-master    10.10.110.191 k8s-node1    10.10.110.192 k8s-node2    EOF# 允许iptables检查桥接流量modprobe br_netfilterlsmod | grep br_netfiltercat <<EOF | tee /etc/modules-load.d/k8s.confbr_netfilterEOFcat <<EOF | tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --system# 节点时间同步timedatectl set-local-rtc 1timedatectl set-timezone Asia/Shanghaiecho "*/5 *  *  *  * /usr/sbin/ntpdate ntp.aliyun.com &>/dev/null" | crontab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装-Container-Runtime"><a href="#安装-Container-Runtime" class="headerlink" title="安装 Container Runtime"></a>安装 Container Runtime</h2><p>为了在 Pod 中运行容器，Kubernetes 需要使用容器运行时。</p><pre class="line-numbers language-shell"><code class="language-shell"># 卸载旧版本apt-get remove docker docker-engine docker.io containerd runc# 更新apt包索引和安装包apt-get updateapt-get install -y \    apt-transport-https \    ca-certificates \    curl \    gnupg \    lsb-release# 添加Docker的官方GPG密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 设置稳定存储库echo \    "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \    $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null# 安装Docker引擎apt-get updateapt-get install -y docker-ce docker-ce-cli containerd.io# 配置docker镜像加速,kubernetes官方建议docker驱动采用systemd,如果不修改kubeadm init时会有warning提示cat <<EOF | tee /etc/docker/daemon.json{  "registry-mirrors": ["https://265wemgl.mirror.aliyuncs.com"],   "exec-opts": ["native.cgroupdriver=systemd"],  "log-driver": "json-file",  "log-opts": {    "max-size": "100m"  },  "storage-driver": "overlay2"}EOFsystemctl daemon-reloadsystemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h2><p>你需要在每台机器上安装以下的软件包：</p><ul><li><code>kubeadm</code>：用来初始化集群的指令。</li><li><code>kubelet</code>：在集群中的每个节点上用来启动 Pod 和容器等。</li><li><code>kubectl</code>：用来与集群通信的命令行工具。</li></ul><p>kubeadm 不能帮你安装或者管理 kubelet 或 kubectl，所以你需要确保它们与通过 kubeadm 安装的控制平面的版本相匹配。</p><pre class="line-numbers language-shell"><code class="language-shell">apt-get update && apt-get install -y apt-transport-https curlcurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -cat <<EOF | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOFapt-get updateapt-get install -y kubelet kubeadm kubectlapt-mark hold kubelet kubeadm kubectl # 阻止软件自动更新<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化控制平面节点"><a href="#初始化控制平面节点" class="headerlink" title="初始化控制平面节点"></a>初始化控制平面节点</h2><p>控制平面节点是运行控制平面组件的机器， 包括 etcd （集群数据库） 和 API Server（命令行工具 kubectl 与之通信）。</p><p>在所有 master 节点执行</p><pre class="line-numbers language-shell"><code class="language-shell">kubeadm init \  --apiserver-advertise-address=10.10.110.190 \  --image-repository registry.aliyuncs.com/google_containers \  --kubernetes-version v1.21.0 \  --service-cidr=10.96.0.0/12 \  --pod-network-cidr=10.244.0.0/16 \  --ignore-preflight-errors=all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>–apiserver-advertise-address 服务器所公布的其正在监听的 IP 地址</li><li>–image-repository 默认拉取镜像地址为 k8s.gcr.io（国内网络无法拉取），这里指定阿里云镜像仓库地址</li><li>–kubernetes-version 指定 k8s 安装版本</li><li>–service-cidr 集群内部虚拟网络，pod 统一访问入口</li><li>–pod-network-cidr 指明 pod 网络可以使用的 IP 地址段</li></ul><p>拷贝 kubectl 连接 k8s 所使用的认证文件到当前用户的默认路径</p><pre class="line-numbers language-shell"><code class="language-shell">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="安装-Pod-网络附加组件"><a href="#安装-Pod-网络附加组件" class="headerlink" title="安装 Pod 网络附加组件"></a>安装 Pod 网络附加组件</h2><p>你必须部署一个基于 Pod 网络插件的容器网络接口 (CNI)，以便你的 Pod 可以相互通信。 在安装网络之前，集群 DNS (CoreDNS) 将不会启动。这也是为什么 node 的状态其实是 NotReady 的原因。Kubernetes 常用的网络插件包括 Calico、Flannel、Canal 和 Weave，这里我们使用 Calico 来为 Kubernetes 集群提供网络策略支持</p><p>你可以使用以下命令在控制平面节点或具有 kubeconfig 凭据的节点上安装 Pod 网络附加组件：</p><pre class="line-numbers language-shell"><code class="language-shell"># 下载 calico 官方配置文件(国内网络可能会下载失败)wget https://docs.projectcalico.org/manifests/calico.yaml# 修改 calico 配置文件- name: CALICO_IPV4POOL_CIDR  value: "10.244.0.0/16"    # 修改为kubeadm init时指定的--pod-network-cidr网段# 应用配置文件kubectl apply -f calico.yaml# 查看 pods 运行状态kubectl get pods -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加入节点"><a href="#加入节点" class="headerlink" title="加入节点"></a>加入节点</h2><p>节点是你的工作负载（容器和 Pod 等）运行的地方。要将新节点添加到集群，请对每台计算机执行以下操作：</p><ul><li>SSH 到机器</li><li>成为 root （例如 <code>sudo su -</code>）</li><li>运行 <code>kubeadm init</code> 输出的命令。例如：</li></ul><pre class="line-numbers language-shell"><code class="language-shell">kubeadm join 10.10.110.190:6443 --token 54sx6k.gi533yr3f4yimvky \    --discovery-token-ca-cert-hash sha256:3f16fb0f5c1ed611af164b8f5df6891ee60bba760286b860d125d08a304ed4b0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行 kubeadm init 之后，默认生成的 token 有效期为 24 小时，过期之后就需要重新创建 token，操作如下：</p><pre class="line-numbers language-shell"><code class="language-shell"># 列出token列表kubeadm token list# 创建tokenkubeadm token createbvw33z.dd7p7h2t151vc6ej  # 这里是新生成的token# 获取CA证书公钥哈希值openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'3f16fb0f5c1ed611af164b8f5df6891ee60bba760286b860d125d08a304ed4b0# 使用新的token和公钥哈希值加入节点kubeadm join 10.10.110.190:6443 --token $(新生成的token) \    --discovery-token-ca-cert-hash sha256:$(新生成的公钥哈希值)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h2><p>Dashboard 是基于网页的 Kubernetes 用户界面。 你可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。 你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment，Job，DaemonSet 等等）。 例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p><p>默认情况下不会部署 Dashboard。可以通过以下命令部署：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 下载dashboard配置清单文件</span>wget https<span class="token punctuation">:</span>//raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml<span class="token comment" spellcheck="true"># dashboard默认的service是ClusterIP类型,我们需要修改为NodePort类型,才能让外部访问到我们的dashboard</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard  <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">443</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8443</span>      <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30023</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span class="token punctuation">---</span><span class="token comment" spellcheck="true"># 访问地址</span>https<span class="token punctuation">:</span>//nodeip<span class="token punctuation">:</span><span class="token number">30023</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 Dashboard 管理页面所需的 token，可以通过以下命令创建：</p><pre class="line-numbers language-shell"><code class="language-shell"># 我们首先在kubernetes-dashboard命名空间中创建名为admin-user的service accountkubectl create serviceaccount admin-user -n kubernetes-dashboardkubectl get serviceaccounts -n kubernetes-dashboard# 创建集群角色绑定,给admin-user用户授权kubectl create clusterrolebinding admin-user --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:admin-user# 获取kubernetes-dashboard命名空间下admin-user用户的登录tokenkubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置-k8s-命令自动补全"><a href="#设置-k8s-命令自动补全" class="headerlink" title="设置 k8s 命令自动补全"></a>设置 k8s 命令自动补全</h2><pre class="line-numbers language-shell"><code class="language-shell">apt-get install -y bash-completionlocate bash_completionsource /usr/share/bash-completion/bash_completionsource <(kubectl completion bash)echo "source <(kubectl completion bash)" >> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Kubelet-概述"><a href="#Kubelet-概述" class="headerlink" title="Kubelet 概述"></a>Kubelet 概述</h1><p>我们可以使用 Kubectl 命令行工具管理 Kubernetes 集群。默认情况下，<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录下查找名为 <code>config</code> 的文件。 你可以通过设置 <code>KUBECONFIG</code> 环境变量或者设置 <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl/" target="_blank" rel="noopener"><code>--kubeconfig</code></a>参数来指定其他 kubeconfig 文件。使用 kubeconfig 文件来组织有关集群、用户、命名空间和身份认证机制的信息。<code>kubectl</code> 命令行工具使用 kubeconfig 文件来查找选择集群所需的信息，并与集群的 API 服务器进行通信。</p><p>说明：用于配置集群访问的文件称为 <em>kubeconfig 文件</em>。这是引用配置文件的通用方法。这并不意味着有一个名为 <code>kubeconfig</code> 的文件。</p><h2 id="支持多集群、用户和身份认证机制"><a href="#支持多集群、用户和身份认证机制" class="headerlink" title="支持多集群、用户和身份认证机制 "></a><a href="">支持多集群</a>、用户和身份认证机制<a href="https://kubernetes.io/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/#支持多集群-用户和身份认证机制"> </a></h2><p>假设您有多个集群，并且您的用户和组件以多种方式进行身份认证。比如：</p><ul><li>正在运行的 kubelet 可能使用证书在进行认证。</li><li>用户可能通过令牌进行认证。</li><li>管理员可能拥有多个证书集合提供给各用户。</li></ul><p>使用 kubeconfig 文件，您可以组织集群、用户和命名空间。您还可以定义上下文，以便在集群和命名空间之间快速轻松地切换。</p><h2 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h2><p>通过 kubeconfig 文件中的 context 元素，使用简便的名称来对访问参数进行分组。每个上下文都有三个参数：cluster、namespace 和 user。默认情况下，kubectl 命令行工具使用当前上下文中的参数与集群进行通信。</p><p>选择当前上下文</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl config use-context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="KUBECONFIG-环境变量"><a href="#KUBECONFIG-环境变量" class="headerlink" title="KUBECONFIG 环境变量"></a>KUBECONFIG 环境变量</h2><p><code>KUBECONFIG</code> 环境变量包含一个 kubeconfig 文件列表。 对于 Linux 和 Mac，列表以冒号分隔。对于 Windows，列表以分号分隔。 <code>KUBECONFIG</code> 环境变量不是必要的。 如果 <code>KUBECONFIG</code> 环境变量不存在，<code>kubectl</code> 使用默认的 kubeconfig 文件，<code>$HOME/.kube/config</code>。</p><p>如果 <code>KUBECONFIG</code> 环境变量存在，<code>kubectl</code> 使用 <code>KUBECONFIG</code> 环境变量中列举的文件合并后的有效配置。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>使用以下语法 <code>kubectl</code> 从终端窗口运行命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl [command] [TYPE] [NAME] [flags]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</li><li><code>TYPE</code>：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式。</li><li><code>NAME</code>：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息 <code>kubectl get pods</code>。</li><li><code>flags</code>: 指定可选的参数。</li></ul><h2 id="Kubectl-–help"><a href="#Kubectl-–help" class="headerlink" title="Kubectl –help"></a>Kubectl –help</h2><h3 id="基本指令-初级"><a href="#基本指令-初级" class="headerlink" title="基本指令(初级)"></a>基本指令(初级)</h3><ul><li>create：从文件或标准输入创建资源。</li><li>expose：将资源作为新的 Kubernetes 服务公开。</li><li>run：在集群上运行指定的镜像。</li><li>set：设置对象的特定功能。</li></ul><h3 id="基本指令-中级"><a href="#基本指令-中级" class="headerlink" title="基本指令(中级)"></a>基本指令(中级)</h3><ul><li>explain：解释文档参考资料。</li><li>get：显示一个或多个资源。</li><li>edit：编辑服务器上的资源。</li><li>delete：通过文件名、标准输入、资源和名称或通过资源和标签选择器删除资源。</li></ul><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><ul><li>rollout：管理资源的发布。</li><li>scale：对 deployment、ReplicaSet、Replication Controller 或 StatefulSet 扩容缩容。</li><li>autoscale：自动扩容缩容。</li></ul><h3 id="集群管理命令"><a href="#集群管理命令" class="headerlink" title="集群管理命令"></a>集群管理命令</h3><ul><li>certificate：修改证书资源。</li><li>cluster-info：显示集群信息。</li><li>top：显示资源(CPU/内存/存储)使用情况。</li><li>cordon：将节点标记为不可调度。</li><li>uncordon：将节点标记为可调度的。</li><li>drain：更新一个或多个节点上的污点。</li><li>taint：驱逐节点上的应用准备下线维护。</li></ul><h3 id="疑难解答和调试命令"><a href="#疑难解答和调试命令" class="headerlink" title="疑难解答和调试命令"></a>疑难解答和调试命令</h3><ul><li>describe：描述显示特定资源或资源组的详细信息。</li><li>logs：打印一个容器的日志。</li><li>attach：连接到正在运行的容器上。</li><li>exec：在容器中执行命令。</li><li>port-forward：转发一个或多个本地端口到一个 pod。</li><li>proxy：运行到 Kubernetes API 服务器的代理。</li><li>cp：在容器和容器之间复制文件和目录。</li><li>auth：授权检查。</li><li>debug：使用交互式调试容器调试群集资源。</li></ul><h3 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h3><ul><li>diff：由文件名或标准输入指定当前联机配置和应用时的配置差异。</li><li>apply：通过文件名或标准输入对资源应用配置。</li><li>patch：使用补丁更新资源的字段。</li><li>replace：用文件名或标准输入替换资源。</li><li>wait：等待一个或多个资源的特定条件。</li><li>kustomize：从 kustomization.yaml 文件中的指令生成一组 API 资源。</li></ul><h3 id="设置命令"><a href="#设置命令" class="headerlink" title="设置命令"></a>设置命令</h3><ul><li>label：更新资源上的标签。</li><li>annotate：更新一个或多个资源上的注解。</li><li>completion：kubectl 命令自动补全。</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li>api-resources：打印受支持的 API 资源。</li><li>api-versions：打印受支持的 API 版本。</li><li>config：修改 Kubeconfig 文件。</li><li>plugin：提供与插件交互的实用程序。</li><li>version：打印当前上下文客户端和服务版本信息。</li></ul><h2 id="Kubectl-管理应用生命周期"><a href="#Kubectl-管理应用生命周期" class="headerlink" title="Kubectl 管理应用生命周期"></a>Kubectl 管理应用生命周期</h2><p>创建</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl create deployment myapp-deployment --image=ikubernetes/myapp:v1 --replicas=3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发布</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl expose deployment myapp-deployment --name=myapp-service --type=NodePort --port=8000 --target-port=80 --protocol=TCP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>升级</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl set image deployment/myapp-deployment myapp=ikubernetes/myapp:v2kubectl rollout status deployment myapp-deployment # 查看升级状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>回滚</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl rollout history deployment myapp-deployment # 查看版本发布历史记录kubectl rollout history deployment myapp-deployment --revision=3 # 查看指定版本发布的详细信息kubectl rollout undo deployment myapp-deployment # 回滚到上一个版本kubectl rollout undo deployment myapp-deployment --to-revision=2 # 回滚到指定的版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>删除</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl delete deployments.apps myapp-deploymentkubectl delete service myapp-service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="对象类资源格式"><a href="#对象类资源格式" class="headerlink" title="对象类资源格式"></a>对象类资源格式</h1><p>Kubernetes API 仅支持接受及响应 JSON 格式的数据（JSON 对象），同时，为了便于使用，它也允许用户提供 YAML 格式的 POST 对象，但 API Server 接受和返回的所有 JSON 对象都遵循同一个模式，它们都具有 kind 和 apiVersion 字段，用于表示对象所属的资源类型、API 群组及相关版本。</p><p>大多数的对象或列表类型的资源还需要具有三个嵌套型的字段 metadata、spec、status。其中 metadata 字段为资源提供元数据信息，如名称、资源隶属的名称空间和标签等。spec 则用于定义用户期望的状态，不同的资源类型，其状态的意义也各不相同。status 则记录着活动对象的当前状态信息，它由 Kubernetes 系统自行维护，对用户来说为只读状态。</p><p>Kubectl 的命令可以分为三类：陈述式命令（Imperative commands）、陈述式对象配置（Imperative object configuration）和声明式对象配置（Declarative object configuration）。</p><p>陈述式命令就是此前管理应用生命周期用到的 run、expose 和 delete 等命令，它们直接作用于 Kubernetes 系统上的活动对象，简单易用，但是不支持代码复用、修改复审及审计日志的功能。对于新手来说，更容易上手学习。</p><p>陈述式对象配置管理方式支持使用 create、delete、get 和 replace 等命令，与陈述式命令不同之处在于，它通过资源配置清单读取需要管理的目标资源对象。陈述式对象配置管理操作同样直接作用于 Kubernetes 系统上的活动对象，即便修改配置清单中极小的一部分内容，使用 replace 命令进行的对象更新也会导致整个对象被替换。</p><p>声明式对象配置并不直接指明要进行的对象管理操作，而是提供配置清单文件给 Kubernetes 系统，并委托系统跟踪活动对象的状态变动。资源对象的创建、删除及修改操作可全部通过唯一的 apply 命令来完成。并且每次操作时，提供给命令的配置信息都存放于对象的注解信息中，并通过比对检查活动对象的当前状态、注解中的配置信息及资源清单中的配置信息三方进行变更合并，从而实现仅修改变动字段的高级补丁机制。</p><h2 id="资源配置清单"><a href="#资源配置清单" class="headerlink" title="资源配置清单"></a>资源配置清单</h2><p>我们前面使用 Kubectl 管理应用生命周期，使用的是陈述式命令。下面我们将以资源配置清单的格式来创建活动对象。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ikubernetes<span class="token punctuation">-</span>deployment  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> ikubernetes<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> ikubernetes  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> ikubernetes    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ikubernetes        <span class="token key atrule">image</span><span class="token punctuation">:</span> ikubernetes/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在该活动对象实例中：</p><ul><li><p>创建名为 ikubernetes-deployment （由 <code>.metadata.name</code> 字段标明）的 Deployment</p></li><li><p>该 Deployment 创建三个（由 <code>replicas</code> 字段标明） Pod 副本</p></li><li><p><code>selector</code> 字段定义 Deployment 如何查找要管理的 Pods。这里只需选择在 Pod 模板中定义的标签（app: ikubernetes）</p></li><li><p><code>template</code> 字段包含以下子字段：</p><ul><li>Pod 被使用 <code>labels</code> 字段打上 app: ikubernetes 标签</li><li>Pod 模板规约 （即 .<code>template.spec</code> 字段）指示 Pods 运行一个 ikubernetes 容器，并指定容器运行版本的镜像</li></ul><p>Kubernetes API 标准的资源组织格式由五个核心字段组成：</p></li><li><p>apiVersion：定义这个资源使用的 API 版本</p></li><li><p>kind：定义这个资源的类型</p></li><li><p>metadata：资源的元数据</p></li><li><p>spec：资源的规约，描述所期望的对象应有的状态</p></li><li><p>status：记录对象在系统上的当前状态</p></li></ul><p>在编写资源配置清单时如果对资源的字段不确定，可以使用 Kubernetes 内置的 explain 命令列出受支持资源的字段：</p><pre class="line-numbers language-shell"><code class="language-shell"># 获取资源及其字段的文档kubectl explain pods# 获取资源的特定字段kubectl explain pods.spec.containers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="工作负载资源使用"><a href="#工作负载资源使用" class="headerlink" title="工作负载资源使用"></a>工作负载资源使用</h1><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>一个 Deployment 为 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pods</a> 和 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSets</a> 提供声明式的更新能力。</p><p>下面是 Deployment 示例。其中创建了一个 ReplicaSet，负责启动三个 <code>nginx</code> Pods：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.14.2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开始之前，请确保的 Kubernetes 集群已启动并运行。 按照以下步骤创建上述 Deployment ：</p><p>通过运行以下命令创建 Deployment ：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl apply -f nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行 <code>kubectl get deployments.apps -o wide</code> 检查 Deployment 是否已创建：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME                     READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS    IMAGES                 SELECTORnginx-deployment         3/3     3            3           34s   nginx         nginx:1.14.2           app=nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在检查集群中的 Deployment 时，所显示的字段有：</p><ul><li><code>NAME</code> 列出了集群中 Deployment 的名称。</li><li><code>READY</code> 显示应用程序的可用的副本数，显示的模式是“就绪个数/期望个数”。</li><li><code>UP-TO-DATE</code> 显示为了达到期望状态已经更新的副本数。</li><li><code>AVAILABLE</code> 显示应用可供用户使用的副本数。</li><li><code>AGE</code> 显示应用程序运行的时间。</li></ul><p>请注意期望副本数是根据 <code>.spec.replicas</code> 字段设置 3。</p><p>运行 <code>kubectl rollout status deployment nginx-deployment</code> 查看 Deployment 上线状态：</p><pre class="line-numbers language-shell"><code class="language-shell">deployment "nginx-deployment" successfully rolled out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要查看 Deployment 创建的 ReplicaSet（<code>rs</code>），运行 <code>kubectl get rs</code>。 输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME                                DESIRED   CURRENT   READY   AGEnginx-deployment-66b6c48dd5         3         3         3       5m5s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要查看每个资源自动生成的标签，运行 <code>kubectl get pods --show-labels</code>。返回以下输出：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME                                      READY   STATUS    RESTARTS   AGE     LABELSnginx-deployment-66b6c48dd5-5jd4w         1/1     Running   0          7m20s   app=nginx,pod-template-hash=66b6c48dd5nginx-deployment-66b6c48dd5-js2bx         1/1     Running   0          7m20s   app=nginx,pod-template-hash=66b6c48dd5nginx-deployment-66b6c48dd5-mqsnj         1/1     Running   0          7m20s   app=nginx,pod-template-hash=66b6c48dd5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所创建的 ReplicaSet 确保总是存在三个 <code>nginx</code> Pod。</p><h2 id="ReplicaSet-1"><a href="#ReplicaSet-1" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><p>ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet ，除非你需要自定义更新业务流程或根本不需要更新。</p><p>这实际上意味着，你可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义 ReplicaSet 管理你的应用。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicaSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">ti</span><span class="token punctuation">:</span> fr  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">ti</span><span class="token punctuation">:</span> fr    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到当前被部署的 ReplicaSet：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get rs nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并看到你所创建的前端：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME    DESIRED   CURRENT   READY   AGEnginx   3         3         2       11s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你也可以查看 ReplicaSet 的状态：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl describe rs nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到类似如下的输出：</p><pre class="line-numbers language-shell"><code class="language-shell">Name:         nginxNamespace:    defaultSelector:     ti=frLabels:       app=nginxAnnotations:  <none>Replicas:     3 current / 3 desiredPods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 FailedPod Template:  Labels:  ti=fr  Containers:   nginx:    Image:        nginx    Port:         <none>    Host Port:    <none>    Environment:  <none>    Mounts:       <none>  Volumes:        <none>Events:  Type    Reason            Age   From                   Message  ----    ------            ----  ----                   -------  Normal  SuccessfulCreate  113s  replicaset-controller  Created pod: nginx-7hxhm  Normal  SuccessfulCreate  113s  replicaset-controller  Created pod: nginx-mnq9v  Normal  SuccessfulCreate  113s  replicaset-controller  Created pod: nginx-w9cfq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后可以查看启动了的 Pods：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到类似如下的 Pod 信息：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME          READY   STATUS    RESTARTS   AGEnginx-7hxhm   1/1     Running   0          3m2snginx-mnq9v   1/1     Running   0          3m2snginx-w9cfq   1/1     Running   0          3m2s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="StatefulSets-1"><a href="#StatefulSets-1" class="headerlink" title="StatefulSets"></a>StatefulSets</h2><h2 id="DaemonSet-1"><a href="#DaemonSet-1" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><p>你可以在 YAML 文件中描述 DaemonSet。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> fluentd  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> fluentd<span class="token punctuation">-</span>logging<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> fluentd<span class="token punctuation">-</span>elasticsearch  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> fluentd<span class="token punctuation">-</span>elasticsearch    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> fluentd<span class="token punctuation">-</span>elasticsearch        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/fluentd_elasticsearch/fluentd<span class="token punctuation">:</span>v2.5.2      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">type</span><span class="token punctuation">:</span> ssd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果指定了 <code>.spec.template.spec.nodeSelector</code>，DaemonSet 控制器将在能够与 Node 选择算符匹配的节点上创建 Pod。类似这种情况，可以指定 <code>.spec.template.spec.affinity</code>，之后 DaemonSet 控制器将在能够与节点亲和性匹配的节点上创建 Pod。 如果根本就没有指定，则 DaemonSet Controller 将在所有节点上创建 Pod。</p><h2 id="Jobs-1"><a href="#Jobs-1" class="headerlink" title="Jobs"></a>Jobs</h2><p>下面是一个 Job 配置示例。它负责计算 π 到小数点后 2000 位，并将结果打印出来。 此计算大约需要 10 秒钟完成。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pi        <span class="token key atrule">image</span><span class="token punctuation">:</span> perl        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"perl"</span><span class="token punctuation">,</span>  <span class="token string">"-Mbignum=bpi"</span><span class="token punctuation">,</span> <span class="token string">"-wle"</span><span class="token punctuation">,</span> <span class="token string">"print bpi(2000)"</span><span class="token punctuation">]</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never  <span class="token key atrule">backoffLimit</span><span class="token punctuation">:</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要查看 Job 对应的已完成的 Pods，可以执行 <code>kubectl get pods</code>。</p><p>要以机器可读的方式列举隶属于某 Job 的全部 Pods，你可以使用类似下面这条命令：</p><pre class="line-numbers language-shell"><code class="language-shell">pods=$(kubectl get pods --selector=job-name=pi --output=jsonpath='{.items[*].metadata.name}')echo $pods<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">pi-ntb4l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，选择算符与 Job 的选择算符相同。<code>--output=jsonpath</code> 选项给出了一个表达式， 用来从返回的列表中提取每个 Pod 的 name 字段。</p><p>查看其中一个 Pod 的标准输出：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl logs $pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Service-资源"><a href="#Service-资源" class="headerlink" title="Service 资源"></a>Service 资源</h1><p>创建和销毁 Kubernetes Pod 以匹配集群状态。 Pod 是非永久性资源。 如果你使用 Deployment 来运行你的应用程序，则它可以动态创建和销毁 Pod。</p><p>每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。</p><p>这导致了一个问题： 如果一组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”）提供功能， 那么前端如何找出并跟踪要连接的 IP 地址，以便前端可以使用提供工作负载的后端部分？</p><p>于是就有了 Services。</p><h2 id="定义-Service"><a href="#定义-Service" class="headerlink" title="定义 Service"></a>定义 Service</h2><p>例如，假定有一组 Pod，它们对外暴露了 6379 端口，同时还被打上 <code>app=redis</code> 标签：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>deployment  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> redis    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis        <span class="token key atrule">image</span><span class="token punctuation">:</span> redis        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们创建名称为 “my-service” 的 Service 对象，它会将请求代理到使用 TCP 端口 6379，并且具有标签 <code>app=redis</code> 的 Pod 上：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过执行 <code>kubectl get endpoints my-service</code> 命令可以看到 Service 后端所代理的 Pod：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME         ENDPOINTS                                                   AGEmy-service   10.244.169.179:6379,10.244.169.180:6379,10.244.36.82:6379   6m3s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Service-虚拟-IP-和服务代理"><a href="#Service-虚拟-IP-和服务代理" class="headerlink" title="Service 虚拟 IP 和服务代理"></a>Service 虚拟 IP 和服务代理</h2><p>在 Kubernetes 集群中，每个 Node 运行一个 kube-proxy 进程。 kube-proxy 负责为 Service 实现了一种 VIP（虚拟 IP）的形式，而不是 ExternalName 的形式。简单来讲，一个 Service 对象就是工作节点上的一些 iptables 或 ipvs 规则，用于将到达 Service 对象 IP 地址的流量调度转发至相应的 Endpoint 对象指向的 IP 地址和端口之上。</p><h3 id="userspace-代理模型"><a href="#userspace-代理模型" class="headerlink" title="userspace 代理模型"></a>userspace 代理模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/606199998322e6675cd1d76b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种模式，kube-proxy 会监视 Kubernetes 控制平面对 Service 对象和 Endpoints 对象的添加和移除操作。 对每个 Service，它会在本地 Node 上打开一个端口（随机选择）。 任何连接到“代理端口”的请求，都会被代理到 Service 的后端 <code>Pods</code> 中的某个上面（如 <code>Endpoints</code> 所报告的一样）。 使用哪个后端 Pod，是 kube-proxy 基于 <code>SessionAffinity</code> 来确定的。</p><p>最后，它配置 iptables 规则，捕获到达该 Service 的 <code>clusterIP</code>（是虚拟 IP） 和 <code>Port</code> 的请求，并重定向到代理端口，代理端口再代理请求到后端Pod。</p><p>默认情况下，用户空间模式下的 kube-proxy 通过轮转算法选择后端。</p><h3 id="iptables-代理模型"><a href="#iptables-代理模型" class="headerlink" title="iptables 代理模型"></a>iptables 代理模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/6061a5e08322e6675cdf26c6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种模式，kube-proxy 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 clusterIP 和端口的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。</p><p>默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。</p><p>使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理， 而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠。</p><p>如果 kube-proxy 在 iptables 模式下运行，并且所选的第一个 Pod 没有响应， 则连接失败。 这与用户空间模式不同：在这种情况下，kube-proxy 将检测到与第一个 Pod 的连接已失败， 并会自动使用其他后端 Pod 重试。</p><p>你可以使用 Pod 就绪探测器 验证后端 Pod 可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端。 这样做意味着你避免将流量通过 kube-proxy 发送到已知已失败的 Pod。</p><h3 id="ipvs-代理模型"><a href="#ipvs-代理模型" class="headerlink" title="ipvs 代理模型"></a>ipvs 代理模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/6061a7cf8322e6675ce18487.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在 <code>ipvs</code> 模式下，kube-proxy 监视 Kubernetes 服务和端点，调用 <code>netlink</code> 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。 该控制循环可确保IPVS 状态与所需状态匹配。访问服务时，IPVS 将流量定向到后端 Pod 之一。</p><p>IPVS代理模式基于类似于 iptables 模式的 netfilter 挂钩函数， 但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。 与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。</p><p>IPVS 提供了更多选项来平衡后端 Pod 的流量。 这些是：</p><ul><li><code>rr</code>：轮替（Round-Robin）</li><li><code>lc</code>：最少链接（Least Connection），即打开链接数量最少者优先</li><li><code>dh</code>：目标地址哈希（Destination Hashing）</li><li><code>sh</code>：源地址哈希（Source Hashing）</li><li><code>sed</code>：最短预期延迟（Shortest Expected Delay）</li><li><code>nq</code>：从不排队（Never Queue）</li></ul><h2 id="Service-类型"><a href="#Service-类型" class="headerlink" title="Service 类型"></a>Service 类型</h2><p>对于一些应用的某些部分（如前端），可能希望将其暴露给 Kubernetes 集群外部的 IP 地址。</p><p>Kubernetes <code>ServiceTypes</code> 允许指定你所需要的 Service 类型，默认是 <code>ClusterIP</code>。</p><p><code>Type</code> 的取值以及行为如下：</p><ul><li><code>ClusterIP</code>：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 <code>ServiceType</code>。</li><li><code>NodePort</code>：通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务。</li><li><code>LoadBalancer</code>：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li><li><code>ExternalName</code>：通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理。</li></ul><p>你也可以使用 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress</a> 来暴露自己的服务。 Ingress 不是一种服务类型，但它充当集群的入口点。 它可以将路由规则整合到一个资源中，因为它可以在同一IP地址下公开多个服务。</p><h3 id="NodePort-类型"><a href="#NodePort-类型" class="headerlink" title="NodePort 类型"></a>NodePort 类型</h3><p>如果你将 <code>type</code> 字段设置为 <code>NodePort</code>，则 Kubernetes 控制平面将在 <code>--service-node-port-range</code> 标志指定的范围内分配端口（默认值：30000-32767）。 每个节点将那个端口（每个节点上的相同端口号）代理到你的服务中。 你的服务在其 <code>.spec.ports[*].nodePort</code> 字段中要求分配的端口。</p><p>如果需要特定的端口号，你可以在 <code>nodePort</code> 字段中指定一个值。 控制平面将为你分配该端口或报告 API 事务失败。 这意味着你需要自己注意可能发生的端口冲突。 你还必须使用有效的端口号，该端口号在配置用于 NodePort 的范围内。 </p><p>使用 NodePort 可以让你自由设置自己的负载均衡解决方案， 配置 Kubernetes 不完全支持的环境， 甚至直接暴露一个或多个节点的 IP。</p><p>例如：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> MyApp  <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 默认情况下,为了方便起见,`targetPort` 被设置为与 `port` 字段相同的值</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token comment" spellcheck="true"># 可选字段</span>      <span class="token comment" spellcheck="true"># 默认情况下,为了方便起见,Kubernetes 控制平面会从某个范围内分配一个端口号(默认:30000-32767)</span>      <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30007</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Service-启用-ipvs-代理模型"><a href="#Service-启用-ipvs-代理模型" class="headerlink" title="Service 启用 ipvs 代理模型"></a>Service 启用 ipvs 代理模型</h2><p>Kubernetes 的 <code>1.11</code> 版本后，默认使用 ipvs，如果节点的内核不支持或没有开启 ipvs 则 kubernetes 会自动降级为使用 iptables 规则。</p><p>查看 kube-proxy 的启动日志，这里默认使用的是 iptables 代理模型</p><pre class="line-numbers language-shell"><code class="language-shell">[root@k8s-master ~]$ kubectl logs -f kube-proxy-hjxcq -n kube-system ...I0323 03:36:31.452070       1 node.go:172] Successfully retrieved node IP: 10.10.110.192I0323 03:36:31.452837       1 server_others.go:142] kube-proxy node IP is an IPv4 address (10.10.110.192), assume IPv4 operationW0323 03:36:31.577520       1 server_others.go:578] Unknown proxy mode "", assuming iptables proxyI0323 03:36:31.579263       1 server_others.go:185] Using iptables Proxier.I0323 03:36:31.580249       1 server.go:650] Version: v1.20.0...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在所有 Kubernetes 节点开启 ipvs 支持</p><pre class="line-numbers language-shell"><code class="language-shell">modprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看内核模块是否加载</p><pre class="line-numbers language-shell"><code class="language-shell">lsmod | grep ip_vs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 ConfigMap 的 kube-system/kube-proxy 的配置文件为 ipvs</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl edit configmaps kube-proxy -n kube-system...ipvs:            excludeCIDRs: null      minSyncPeriod: 0s      scheduler: ""      strictARP: false      syncPeriod: 0s      tcpFinTimeout: 0s      tcpTimeout: 0s      udpTimeout: 0s    kind: KubeProxyConfiguration    metricsBindAddress: ""    mode: "ipvs" # 修改此处为ipvs...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除所有 kube-proxy 的 pod</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pod -n kube-system | grep 'kube-proxy' | awk '{print $1}' | xargs -I {} kubectl delete pod {} -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次查看 kube-proxy 的日志</p><pre class="line-numbers language-shell"><code class="language-shell">[root@k8s-master ~]$ kubectl logs -f kube-proxy-pnglg -n kube-system ...I0410 09:05:52.455879       1 node.go:172] Successfully retrieved node IP: 10.10.110.192I0410 09:05:52.459403       1 server_others.go:142] kube-proxy node IP is an IPv4 address (10.10.110.192), assume IPv4 operationI0410 09:05:52.599981       1 server_others.go:258] Using ipvs Proxier.W0410 09:05:52.606702       1 proxier.go:445] IPVS scheduler not specified, use rr by defaultI0410 09:05:52.608073       1 server.go:650] Version: v1.20.0...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 ipvs 相关规则</p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y ipvsadm [root@k8s-master ~]$ ipvsadm -LnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -> RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  172.17.0.1:30023 rr  -> 10.244.36.72:8443            Masq    1      0          0         TCP  10.10.110.190:30023 rr  -> 10.244.36.72:8443            Masq    1      0          0         TCP  10.96.0.1:443 rr  -> 10.10.110.190:6443           Masq    1      0          0         TCP  10.96.0.10:53 rr  -> 10.244.36.73:53              Masq    1      0          0           -> 10.244.169.160:53            Masq    1      0          0         TCP  10.96.0.10:9153 rr  -> 10.244.36.73:9153            Masq    1      0          0           -> 10.244.169.160:9153          Masq    1      0          0         TCP  10.97.105.36:80 rrTCP  10.98.47.133:443 rr  -> 10.244.36.72:8443            Masq    1      0          0         TCP  10.110.221.168:8000 rr  -> 10.244.169.159:8000          Masq    1      0          0         TCP  10.244.235.192:30023 rr  -> 10.244.36.72:8443            Masq    1      0          0         TCP  127.0.0.1:30023 rr  -> 10.244.36.72:8443            Masq    1      0          0         UDP  10.96.0.10:53 rr  -> 10.244.36.73:53              Masq    1      0          0           -> 10.244.169.160:53            Masq    1      0          0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。</p><p>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p><h2 id="Ingress-是什么？"><a href="#Ingress-是什么？" class="headerlink" title="Ingress 是什么？"></a>Ingress 是什么？</h2><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#ingress-v1beta1-networking-k8s-io" target="_blank" rel="noopener">Ingress</a> 公开了从集群外部到集群内<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">服务</a>的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p><p>下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/607553c38322e6675cd7616b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以将 Ingress 配置为服务提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及提供基于名称的虚拟主机等能力。 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。</p><p>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#nodeport" target="_blank" rel="noopener">Service.Type=NodePort</a> 或 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#loadbalancer" target="_blank" rel="noopener">Service.Type=LoadBalancer</a> 类型的服务。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>你必须具有 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a> 才能满足 Ingress 的要求。 仅创建 Ingress 资源本身没有任何效果。</p><p>你可能需要部署 Ingress 控制器，例如 <a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener">ingress-nginx</a>。 你可以从许多 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a> 中进行选择。</p><p>理想情况下，所有 Ingress 控制器都应符合参考规范。但实际上，不同的 Ingress 控制器操作略有不同。</p><h2 id="Ingress-资源"><a href="#Ingress-资源" class="headerlink" title="Ingress 资源"></a>Ingress 资源</h2><p>一个最小的 Ingress 资源示例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> minimal<span class="token punctuation">-</span>ingress  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /testpath        <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> test            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与所有其他 Kubernetes 资源一样，Ingress 需要使用 <code>apiVersion</code>、<code>kind</code> 和 <code>metadata</code> 字段。 Ingress 对象的命名必须是合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank" rel="noopener">DNS 子域名名称</a>。 有关使用配置文件的一般信息，请参见<a href="https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/" target="_blank" rel="noopener">部署应用</a>、 <a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noopener">配置容器</a>、 <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/manage-deployment/" target="_blank" rel="noopener">管理资源</a>。 Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器，例如 <a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md" target="_blank" rel="noopener">重写目标注解</a>。 不同的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a> 支持不同的注解。查看文档以供你选择 Ingress 控制器，以了解支持哪些注解。</p><p>Ingress <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" target="_blank" rel="noopener">规约</a> 提供了配置负载均衡器或者代理服务器所需的所有信息。 最重要的是，其中包含与所有传入请求匹配的规则列表。 Ingress 资源仅支持用于转发 HTTP 流量的规则。</p><h3 id="Ingress-规则"><a href="#Ingress-规则" class="headerlink" title="Ingress 规则"></a>Ingress 规则</h3><p>每个 HTTP 规则都包含以下信息：</p><ul><li>可选的 <code>host</code>。在此示例中，未指定 <code>host</code>，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了 <code>host</code>（例如 foo.bar.com），则 <code>rules</code> 适用于该 <code>host</code>。</li><li>路径列表 paths（例如，<code>/testpath</code>）,每个路径都有一个由 <code>serviceName</code> 和 <code>servicePort</code> 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。</li><li><code>backend</code>（后端）是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service 文档</a> 中所述的服务和端口名称的组合。 与规则的 <code>host</code> 和 <code>path</code> 匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到列出的 <code>backend</code>。</li></ul><p>通常在 Ingress 控制器中会配置 <code>defaultBackend</code>（默认后端），以服务于任何不符合规约中 <code>path</code> 的请求。</p><h3 id="DefaultBackend"><a href="#DefaultBackend" class="headerlink" title="DefaultBackend"></a>DefaultBackend</h3><p>没有 <code>rules</code> 的 Ingress 将所有流量发送到同一个默认后端。 <code>defaultBackend</code> 通常是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a> 的配置选项，而非在 Ingress 资源中指定。</p><p>如果 <code>hosts</code> 或 <code>paths</code> 都没有与 Ingress 对象中的 HTTP 请求匹配，则流量将路由到默认后端。</p><h3 id="资源后端"><a href="#资源后端" class="headerlink" title="资源后端"></a>资源后端</h3><p>Resource 后端是一个 ObjectRef，指向同一命名空间中的另一个 Kubernetes，将其作为 Ingress 对象。Resource 与 Service 配置是互斥的，在二者均被设置时会无法通过合法性检查。Resource 后端的一种常见用法是将所有入站数据导向带有静态资产的对象存储后端。</p><h3 id="路径类型"><a href="#路径类型" class="headerlink" title="路径类型"></a>路径类型</h3><p>Ingress 中的每个路径都需要有对应的路径类型（Path Type）。未明确设置 <code>pathType</code> 的路径无法通过合法性检查。当前支持的路径类型有三种：</p><ul><li><code>ImplementationSpecific</code>：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 <code>pathType</code> 处理或者与 <code>Prefix</code> 或 <code>Exact</code> 类型作相同处理。</li><li><code>Exact</code>：精确匹配 URL 路径，且区分大小写。</li><li><code>Prefix</code>：基于以 <code>/</code> 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由 <code>/</code> 分隔符分隔的路径中的标签列表。 如果每个 <em>p</em> 都是请求路径 <em>p</em> 的元素前缀，则请求与路径 <em>p</em> 匹配。</li></ul><p><strong>说明：</strong> 如果路径的最后一个元素是请求路径中最后一个元素的子字符串，则不会匹配 （例如：<code>/foo/bar</code> 匹配 <code>/foo/bar/baz</code>, 但不匹配 <code>/foo/barbaz</code>）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><table><thead><tr><th>类型</th><th>路径</th><th>请求路径</th><th>匹配与否？</th></tr></thead><tbody><tr><td>Prefix</td><td><code>/</code></td><td>（所有路径）</td><td>是</td></tr><tr><td>Exact</td><td><code>/foo</code></td><td><code>/foo</code></td><td>是</td></tr><tr><td>Exact</td><td><code>/foo</code></td><td><code>/bar</code></td><td>否</td></tr><tr><td>Exact</td><td><code>/foo</code></td><td><code>/foo/</code></td><td>否</td></tr><tr><td>Exact</td><td><code>/foo/</code></td><td><code>/foo</code></td><td>否</td></tr><tr><td>Prefix</td><td><code>/foo</code></td><td><code>/foo</code>, <code>/foo/</code></td><td>是</td></tr><tr><td>Prefix</td><td><code>/foo/</code></td><td><code>/foo</code>, <code>/foo/</code></td><td>是</td></tr><tr><td>Prefix</td><td><code>/aaa/bb</code></td><td><code>/aaa/bbb</code></td><td>否</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbb</code></td><td>是</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb/</code></td><td><code>/aaa/bbb</code></td><td>是，忽略尾部斜线</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbb/</code></td><td>是，匹配尾部斜线</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbb/ccc</code></td><td>是，匹配子路径</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbbxyz</code></td><td>否，字符串前缀不匹配</td></tr><tr><td>Prefix</td><td><code>/</code>, <code>/aaa</code></td><td><code>/aaa/ccc</code></td><td>是，匹配 <code>/aaa</code> 前缀</td></tr><tr><td>Prefix</td><td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td><td><code>/aaa/bbb</code></td><td>是，匹配 <code>/aaa/bbb</code> 前缀</td></tr><tr><td>Prefix</td><td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td><td><code>/ccc</code></td><td>是，匹配 <code>/</code> 前缀</td></tr><tr><td>Prefix</td><td><code>/aaa</code></td><td><code>/ccc</code></td><td>否，使用默认后端</td></tr><tr><td>混合</td><td><code>/foo</code> (Prefix), <code>/foo</code> (Exact)</td><td><code>/foo</code></td><td>是，优选 Exact 类型</td></tr></tbody></table><h3 id="最基本的-Ingress-资源"><a href="#最基本的-Ingress-资源" class="headerlink" title="最基本的 Ingress 资源"></a>最基本的 Ingress 资源</h3><p>注意：在此示例中，未指定 <code>host</code>，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了 <code>host</code>（例如 foo.bar.com），则 <code>rules</code> 适用于该 <code>host</code>。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>wildcard<span class="token punctuation">-</span>host  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/nginx"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">defaultBackend</span><span class="token punctuation">:</span>    <span class="token key atrule">service</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> default<span class="token punctuation">-</span>http<span class="token punctuation">-</span>backend      <span class="token key atrule">port</span><span class="token punctuation">:</span>        <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基于-URL-路由代理服务"><a href="#基于-URL-路由代理服务" class="headerlink" title="基于 URL 路由代理服务"></a>基于 URL 路由代理服务</h3><p>配置根据请求的 HTTP URI 将来自同一 IP 地址的流量路由到多个 Service。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>wildcard<span class="token punctuation">-</span>host  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"www.ingress.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/nginx"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/tomcat"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> tomcat<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">defaultBackend</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果hosts或paths都没有与Ingress对象中的HTTP请求匹配,则流量将路由到默认后端</span>    <span class="token key atrule">service</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> default<span class="token punctuation">-</span>http<span class="token punctuation">-</span>backend      <span class="token key atrule">port</span><span class="token punctuation">:</span>        <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基于名称的虚拟托管"><a href="#基于名称的虚拟托管" class="headerlink" title="基于名称的虚拟托管"></a>基于名称的虚拟托管</h3><p>基于名称的虚拟主机支持将针对多个主机名的 HTTP 流量路由到同一 IP 地址上。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>wildcard<span class="token punctuation">-</span>host<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"www.nginx.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"www.tomcat.com"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> tomcat<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">defaultBackend</span><span class="token punctuation">:</span>    <span class="token key atrule">service</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> default<span class="token punctuation">-</span>http<span class="token punctuation">-</span>backend      <span class="token key atrule">port</span><span class="token punctuation">:</span>        <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>可以通过设定包含 TLS 私钥和证书的 <a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Secret</a> 来保护 Ingress。 Ingress 只支持单个 TLS 端口 443，并假定 TLS 连接终止于 Ingress 节点 （与 Service 及其 Pod 之间的流量都以明文传输）。 如果 Ingress 中的 TLS 配置部分指定了不同的主机，那么它们将根据通过 SNI TLS 扩展指定的主机名 （如果 Ingress 控制器支持 SNI）在同一端口上进行复用。 TLS Secret 必须包含名为 <code>tls.crt</code> 和 <code>tls.key</code> 的键名。 这些数据包含用于 TLS 的证书和私钥。例如：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> testsecret<span class="token punctuation">-</span>tls  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">tls.crt</span><span class="token punctuation">:</span> base64 编码的 cert  <span class="token key atrule">tls.key</span><span class="token punctuation">:</span> base64 编码的 key<span class="token key atrule">type</span><span class="token punctuation">:</span> kubernetes.io/tls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Ingress 中引用此 Secret 将会告诉 Ingress 控制器使用 TLS 加密从客户端到负载均衡器的通道。 你需要确保创建的 TLS Secret 创建自包含 <code>https-example.foo.com</code> 的公用名称（CN）的证书。 这里的公共名称也被称为全限定域名（FQDN）。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>wildcard<span class="token punctuation">-</span>host<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> www.missf.top    <span class="token key atrule">secretName</span><span class="token punctuation">:</span> www<span class="token punctuation">-</span>missf<span class="token punctuation">-</span>top  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> www.missf.top    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>service            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">defaultBackend</span><span class="token punctuation">:</span>    <span class="token key atrule">service</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> default<span class="token punctuation">-</span>http<span class="token punctuation">-</span>backend      <span class="token key atrule">port</span><span class="token punctuation">:</span>        <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生成-tls-自签证书"><a href="#生成-tls-自签证书" class="headerlink" title="生成 tls 自签证书"></a>生成 tls 自签证书</h4><p>CFSSL 是 CloudFlare 开源的一款 PKI/TLS 工具。 CFSSL 包含一个命令行工具和一个用于签名、验证并且捆绑 TLS 证书的 HTTP API 服务，使用 Go 语言编写。</p><ol><li><p>安裝 <code>CFSSL</code> 工具</p><pre class="line-numbers language-shell"><code class="language-shell">curl -s -L -o /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64curl -s -L -o /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64curl -s -L -o /usr/local/bin/cfssl-certinfo https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x /usr/local/bin/cfssl*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>生成配置证书生成策略文件</p><pre class="line-numbers language-json"><code class="language-json">cat > ca-config.json &lt;&lt;EOF<span class="token punctuation">{</span>  <span class="token property">"signing"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"default"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"expiry"</span><span class="token operator">:</span> <span class="token string">"87600h"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"profiles"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"kubernetes"</span><span class="token operator">:</span> <span class="token punctuation">{</span>         <span class="token property">"expiry"</span><span class="token operator">:</span> <span class="token string">"87600h"</span><span class="token punctuation">,</span>         <span class="token property">"usages"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"signing"</span><span class="token punctuation">,</span>            <span class="token string">"key encipherment"</span><span class="token punctuation">,</span>            <span class="token string">"server auth"</span><span class="token punctuation">,</span>            <span class="token string">"client auth"</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个策略，有一个默认的配置和一个 <code>profile</code>，这里的 <code>profile</code> 是 kubernetes。</p><p>signing：表示该证书可用于签名其它证书。</p><p>server auth：表示 client 可以用该 CA 对 server 提供的证书进行验证。</p><p>client auth：表示 server 可以用该 CA 对 client 提供的证书进行验证。</p><p>expiry：表示证书的有效期。</p></li><li><p>生成 CA 证书和私钥配置文件</p><pre class="line-numbers language-json"><code class="language-json">cat > ca-csr.json &lt;&lt;EOF<span class="token punctuation">{</span>    <span class="token property">"CN"</span><span class="token operator">:</span> <span class="token string">"kubernetes"</span><span class="token punctuation">,</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"algo"</span><span class="token operator">:</span> <span class="token string">"rsa"</span><span class="token punctuation">,</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">2048</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"names"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"C"</span><span class="token operator">:</span> <span class="token string">"CN"</span><span class="token punctuation">,</span>            <span class="token property">"ST"</span><span class="token operator">:</span> <span class="token string">"GuangDong"</span><span class="token punctuation">,</span>            <span class="token property">"L"</span><span class="token operator">:</span> <span class="token string">"ShenZhen"</span><span class="token punctuation">,</span>            <span class="token property">"O"</span><span class="token operator">:</span> <span class="token string">"Kubernetes"</span><span class="token punctuation">,</span>            <span class="token property">"OU"</span><span class="token operator">:</span> <span class="token string">"Devops"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CN：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)，浏览器使用该字段验证网站是否合法</p><p>C：Country， 国家</p><p>ST：State，州，省</p><p>L：Locality，地区，城市</p><p>O：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)</p><p>OU：Organization Unit Name，组织单位名称，公司部门</p></li><li><p>生成 CA 证书、CA 私钥、CSR 文件</p><pre class="line-numbers language-shell"><code class="language-shell">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -# 得到如下文件[root@k8s-master ~/kubernetes/ssl]$ lltotal 28-rw-r--r-- 1 root root  294 Apr 17 15:46 ca-config.json-rw-r--r-- 1 root root 1013 Apr 17 15:48 ca.csr-rw-r--r-- 1 root root  274 Apr 17 15:47 ca-csr.json-rw------- 1 root root 1679 Apr 17 15:48 ca-key.pem-rw-r--r-- 1 root root 1387 Apr 17 15:48 ca.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>生成服务端的证书信息</p><pre class="line-numbers language-json"><code class="language-json">cat > www.missf.top-csr.json &lt;&lt;EOF<span class="token punctuation">{</span>  <span class="token property">"CN"</span><span class="token operator">:</span> <span class="token string">"www.missf.top"</span><span class="token punctuation">,</span>  <span class="token property">"hosts"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"key"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"algo"</span><span class="token operator">:</span> <span class="token string">"rsa"</span><span class="token punctuation">,</span>    <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">2048</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"names"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>       <span class="token property">"C"</span><span class="token operator">:</span> <span class="token string">"CN"</span><span class="token punctuation">,</span>       <span class="token property">"ST"</span><span class="token operator">:</span> <span class="token string">"GuangDong"</span><span class="token punctuation">,</span>       <span class="token property">"L"</span><span class="token operator">:</span> <span class="token string">"ShenZhen"</span><span class="token punctuation">,</span>       <span class="token property">"O"</span><span class="token operator">:</span> <span class="token string">"Kubernetes"</span><span class="token punctuation">,</span>       <span class="token property">"OU"</span><span class="token operator">:</span> <span class="token string">"System"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 ca 证书签发证书</p><pre class="line-numbers language-shell"><code class="language-shell">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes www.missf.top-csr.json | cfssljson -bare www.missf.top<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用证书创建 secret 资源</p></li></ol><pre class="line-numbers language-shell"><code class="language-shell">kubectl create secret tls www-missf-top --cert=www.missf.top.pem --key=www.missf.top-key.pem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>Kubernetes 的存储方式有很多，<a href="https://kubernetes.io/zh/docs/concepts/storage/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/storage/</a></p><h2 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h2><p>Container 中的文件在磁盘上是临时存放的，这给 Container 中运行的较重要的应用程序带来一些问题。问题之一是当容器崩溃时文件丢失。kubelet 会重新启动容器， 但容器会以干净的状态重启。 第二个问题会在同一 <code>Pod</code> 中运行多个容器并共享文件时出现。 Kubernetes <a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/" target="_blank" rel="noopener">卷（Volume）</a>这一抽象概念能够解决这两个问题。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Docker 也有 <a href="https://docs.docker.com/storage/" target="_blank" rel="noopener">卷（Volume）</a> 的概念，但对它只有少量且松散的管理。 Docker 卷是磁盘上或者另外一个容器内的一个目录。 Docker 提供卷驱动程序，但是其功能非常有限。</p><p>Kubernetes 支持很多类型的卷。 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a> 可以同时使用任意数目的卷类型。 临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod 的存活期长。 因此，卷的存在时间会超出 Pod 中运行的所有容器，并且在容器重新启动时数据也会得到保留。 当 Pod 不再存在时，临时卷也将不再存在。但是持久卷会继续存在。</p><p>卷的核心是包含一些数据的一个目录，Pod 中的容器可以访问该目录。 所采用的特定的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。</p><p>使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在 <code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。 容器中的进程看到的是由它们的 Docker 镜像和卷组成的文件系统视图。 <a href="https://docs.docker.com/userguide/dockerimages/" target="_blank" rel="noopener">Docker 镜像</a> 位于文件系统层次结构的根部。各个卷则挂载在镜像内的指定路径上。 卷不能挂载到其他卷之上，也不能与其他卷有硬链接。 Pod 配置中的每个容器必须独立指定各个卷的挂载位置。</p><h3 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h3><p>Kubernetes 支持很多类型的卷，下面主要列举一些常用的卷：</p><h4 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h4><p>当 Pod 分派到某个 Node 上时，<code>emptyDir</code> 卷会被创建，并且在 Pod 在该节点上运行期间，卷一直存在。 就像其名称表示的那样，卷最初是空的。 尽管 Pod 中的容器挂载 <code>emptyDir</code> 卷的路径可能相同也可能不同，这些容器都可以读写 <code>emptyDir</code> 卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时，<code>emptyDir</code> 卷中的数据也会被永久删除。</p><p>说明： 容器崩溃并不会导致 Pod 被从节点上移除，因此容器崩溃期间 emptyDir 卷中的数据是安全的。</p><p>取决于你的环境，<code>emptyDir</code> 卷存储在该节点所使用的介质上；这里的介质可以是磁盘或 SSD 或网络存储。但是，你可以将 <code>emptyDir.medium</code> 字段设置为 <code>&quot;Memory&quot;</code>，以告诉 Kubernetes 为你挂载 tmpfs（基于 RAM 的文件系统）。 虽然 tmpfs 速度非常快，但是要注意它与磁盘不同。 tmpfs 在节点重启时会被清除，并且你所写入的所有文件都会计入容器的内存消耗，受容器内存限制约束。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>containers    <span class="token key atrule">image</span><span class="token punctuation">:</span> ikubernetes/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 容器的/usr/share/nginx/html目录挂载到emptyDir卷</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">name</span><span class="token punctuation">:</span> html  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 容器的/data目录挂载到emptyDir卷</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data      <span class="token key atrule">name</span><span class="token punctuation">:</span> html    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"while true; do echo $(date) >> /data/index.html; sleep 2;done"</span><span class="token punctuation">]</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 在pod所在节点定义emptyDir卷</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 同一pod的两个不同的容器挂载到同一个emptyDir卷,实现数据共享和数据交互</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h4><p><code>hostPath</code> 卷能将主机节点文件系统上的文件或目录挂载到你的 Pod 中。 虽然这不是大多数 Pod 需要的，但是它为一些应用程序提供了强大的逃生舱。</p><p>除了必需的 <code>path</code> 属性之外，用户可以选择性地为 <code>hostPath</code> 卷指定 <code>type</code>。</p><p>支持的 <code>type</code> 值如下：</p><table><thead><tr><th align="left">取值</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left"></td><td align="left">空字符串（默认）用于向后兼容，这意味着在安装 hostPath 卷之前不会执行任何检查。</td></tr><tr><td align="left"><code>DirectoryOrCreate</code></td><td align="left">如果在给定路径上什么都不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 kubelet 相同的组和属主信息。</td></tr><tr><td align="left"><code>Directory</code></td><td align="left">在给定路径上必须存在的目录。</td></tr><tr><td align="left"><code>FileOrCreate</code></td><td align="left">如果在给定路径上什么都不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 kubelet 相同的组和所有权。</td></tr><tr><td align="left"><code>File</code></td><td align="left">在给定路径上必须存在的文件。</td></tr><tr><td align="left"><code>Socket</code></td><td align="left">在给定路径上必须存在的 UNIX 套接字。</td></tr><tr><td align="left"><code>CharDevice</code></td><td align="left">在给定路径上必须存在的字符设备。</td></tr><tr><td align="left"><code>BlockDevice</code></td><td align="left">在给定路径上必须存在的块设备。</td></tr></tbody></table><p>当使用这种类型的卷时要小心，因为：</p><ul><li>具有相同配置（例如基于同一 PodTemplate 创建）的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。</li><li>下层主机上创建的文件或目录只能由 root 用户写入。你需要在 <a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">特权容器</a> 中以 root 身份运行进程，或者修改主机上的文件权限以便容器能够写入 <code>hostPath</code> 卷。</li></ul><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html <span class="token comment" spellcheck="true"># 容器里目录位置</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> html  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data <span class="token comment" spellcheck="true"># 宿主上目录位置</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> DirectoryOrCreate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h4><p><code>nfs</code> 卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。 不像 <code>emptyDir</code> 那样会在删除 Pod 的同时也会被删除，<code>nfs</code> 卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 <code>nfs</code> 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。</p><p>注意： 在使用 NFS 卷之前，你必须运行自己的 NFS 服务器并将目标 share 导出备用。</p><p>部署 NFS 服务端：</p><pre class="line-numbers language-shell"><code class="language-shell">apt-get updateapt-get install nfs-kernel-server -ymkdir /mnt/nfs/vim /etc/exports/mnt/nfs 10.10.110.0/24(rw,no_root_squash,no_subtree_check) # 将NFS服务端的/mnt/nfs目录share出去systemctl restart nfs-server.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意： NFS 服务端和客户端之间需要关闭防火墙，Kubernetes 节点必须支持驱动 NFS 存储设备。</p><p>客户端（Kubernetes 所有工作节点）：</p><pre class="line-numbers language-shell"><code class="language-shell">apt-get updateapt-get install nfs-common -y # 客户端连接NFS服务器所需的包mount -t nfs nfs:/mnt/nfs /mnt/nfs # 将nfs节点的/mnt/nfs目录挂载到本地节点的/mnt/nfs目录,创建文件测试两个节点的目录是否共享<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 NFS 存储类的资源配置清单：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">name</span><span class="token punctuation">:</span> html  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html    <span class="token key atrule">nfs</span><span class="token punctuation">:</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /mnt/nfs      <span class="token key atrule">server</span><span class="token punctuation">:</span> www.nfs.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：我们的 Kubernetes 工作节点不需要提前挂载 NFS 卷，创建 pod 时会自动挂载，pod 销毁之后 NFS 卷也会自动卸载。</p><p>运行 pod 之后，我们可以在 pod 所在节点查看 NFS 挂载情况：</p><pre class="line-numbers language-shell"><code class="language-shell">df -h | grep nfsnfs:/mnt/nfs       19G  4.5G   14G  26% /var/lib/kubelet/pods/0a87a303-9e44-4388-9e89-4bf848d159cf/volumes/kubernetes.io~nfs/html# nfs:/mnt/nfs 这是pod所在节点挂载NFS服务的目录# /var/lib/kubelet/pods/0a87a303-9e44-4388-9e89-4bf848d159cf/volumes/kubernetes.io~nfs/html 是pod内/usr/share/nginx/html目录在宿主机上的映射<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这时候我们在 NFS 服务器修改 NFS 共享目录 <code>/mnt/nfs</code> ，数据会同步到 pod 内的 <code>/usr/share/nginx/html</code> 目录。</p><h4 id="persistentVolumeClaim"><a href="#persistentVolumeClaim" class="headerlink" title="persistentVolumeClaim"></a>persistentVolumeClaim</h4><p><code>persistentVolumeClaim</code> 卷用来将<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">持久卷</a>（PersistentVolume） 挂载到 Pod 中。 持久卷申领（PersistentVolumeClaim）是用户在不知道特定云环境细节的情况下”申领”持久存储 （例如 GCE PersistentDisk 或者 iSCSI 卷）的一种方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/6083dc2bd1a9ae528fb6be67.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>持久卷（PersistentVolume，PV）是集群中的一块存储，可以由管理员事先供应，或者使用<a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener">存储类（Storage Class）</a>来动态供应。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样，也是使用卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。 此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。</p><p>持久卷申领（PersistentVolumeClaim，PVC）表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载）</p><p>每个 PV 对象都包含 <code>spec</code> 部分和 <code>status</code> 部分，分别对应卷的规约和状态：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Retain  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /mnt/pv1    <span class="token key atrule">server</span><span class="token punctuation">:</span> www.nfs.com<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv2<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 2Gi  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadOnlyMany    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Retain  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /mnt/pv2    <span class="token key atrule">server</span><span class="token punctuation">:</span> www.nfs.com<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv3<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 3Gi  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany    <span class="token punctuation">-</span> ReadWriteOnce    <span class="token punctuation">-</span> ReadOnlyMany  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Retain  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /mnt/pv3    <span class="token key atrule">server</span><span class="token punctuation">:</span> www.nfs.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言，每个 PV 卷都有确定的存储容量。 容量属性是使用 PV 对象的 <code>capacity</code> 属性来设置的。</p><p>目前，存储大小是可以设置和请求的唯一资源。 未来可能会包含 IOPS、吞吐量等属性。</p><p>针对 PV 持久卷，Kuberneretes 支持两种卷模式（<code>volumeModes</code>）：<code>Filesystem（文件系统）</code> 和 <code>Block（块）</code>。 <code>volumeMode</code> 是一个可选的 API 参数。 如果该参数被省略，默认的卷模式是 <code>Filesystem</code>。</p><p><code>volumeMode</code> 属性设置为 <code>Filesystem</code> 的卷会被 Pod 挂载（Mount）到某个目录。 如果卷的存储来自某块设备而该设备目前为空，Kuberneretes 会在第一次挂载卷之前在设备上创建文件系统。</p><p>你可以将 <code>volumeMode</code> 设置为 <code>Block</code>，以便将卷作为原始块设备来使用。 这类卷以块设备的方式交给 Pod 使用，其上没有任何文件系统。 这种模式对于为 Pod 提供一种使用最快可能方式来访问卷而言很有帮助，Pod 和卷之间不存在文件系统层。另外，Pod 中运行的应用必须知道如何处理原始块设备。 关于如何在 Pod 中使用 <code>volumeMode: Block</code> 的卷，可参阅 <a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#raw-block-volume-support" target="_blank" rel="noopener">原始块卷支持</a>。</p><p>PersistentVolume 卷可以用资源提供者所支持的任何方式挂载到宿主系统上。 如下表所示，提供者（驱动）的能力不同，每个 PV 卷的访问模式都会设置为对应卷所支持的模式值。 例如，NFS 可以支持多个读写客户，但是某个特定的 NFS PV 卷可能在服务器上以只读的方式导出。每个 PV 卷都会获得自身的访问模式集合，描述的是特定 PV 卷的能力。</p><p>访问模式有：</p><ul><li>ReadWriteOnce – 卷可以被一个节点以读写方式挂载；</li><li>ReadOnlyMany – 卷可以被多个节点以只读方式挂载；</li><li>ReadWriteMany – 卷可以被多个节点以读写方式挂载；</li></ul><p>在命令行接口（CLI）中，访问模式也使用以下缩写形式：</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul><p>目前的回收策略有：</p><ul><li>Retain – 手动回收（pvc 被删除后，pv 还保留着数据，只是 pv 的状态变为 Released ，并且 pv 不能再次被 pvc 绑定）</li><li>Recycle – 基本擦除 (pvc 被删除后，pv 不保留数据，pv 可以再次被 pvc 绑定， <code>rm -rf /thevolume/*</code>)</li><li>Delete – 诸如 AWS EBS、GCE PD、Azure Disk 或 OpenStack Cinder 卷这类关联存储资产也被删除</li></ul><p>目前，仅 NFS 和 HostPath 支持回收（Recycle）。 AWS EBS、GCE PD、Azure Disk 和 Cinder 卷都支持删除（Delete）。</p><p>每个 PVC 对象都有 <code>spec</code> 和 <code>status</code> 部分，分别对应申领的规约和状态：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1      <span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>             <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc1          <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>   <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> ReadWriteOnce   <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">resources</span><span class="token punctuation">:</span>            <span class="token key atrule">requests</span><span class="token punctuation">:</span>             <span class="token key atrule">storage</span><span class="token punctuation">:</span> 800Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>申领在请求具有特定访问模式的存储时，使用与卷相同的访问模式约定。</p><p>申领使用与卷相同的约定来表明是将卷作为文件系统还是块设备来使用。</p><p>申领和 Pod 一样，也可以请求特定数量的资源。在这个上下文中，请求的资源是存储。 卷和申领都使用相同的 <a href="https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md" target="_blank" rel="noopener">资源模型</a>。</p><p>申领可以设置<a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签选择算符</a>来进一步过滤卷集合。只有标签与选择算符相匹配的卷能够绑定到申领上。 选择算符包含两个字段：</p><ul><li><code>matchLabels</code> - 卷必须包含带有此值的标签</li><li><code>matchExpressions</code> - 通过设定键（key）、值列表和操作符（operator） 来构造的需求。合法的操作符有 In、NotIn、Exists 和 DoesNotExist。</li></ul><p>定义 PersistentVolume 的标签：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get persistentvolume --show-labels NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM          STORAGECLASS   REASON   AGE   LABELSpv1    1Gi        RWO,RWX        Retain           Available   default/pvc1                           43m   release=stablepv2    2Gi        RWO,ROX        Retain           Available                                          43m   <none>pv3    3Gi        RWO,ROX,RWX    Retain           Available                                          43m   <none><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PersistentVolumeClaim 通过 PersistentVolume 的标签去进行绑定：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1      <span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>             <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc1          <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>   <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> ReadWriteOnce   <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">resources</span><span class="token punctuation">:</span>            <span class="token key atrule">requests</span><span class="token punctuation">:</span>             <span class="token key atrule">storage</span><span class="token punctuation">:</span> 800Mi  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">release</span><span class="token punctuation">:</span> <span class="token string">"stable"</span>    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">key</span><span class="token punctuation">:</span> release<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>stable<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>StorageClass 为管理员提供了描述存储 “类” 的方法。 不同的类型可能会映射到不同的服务质量等级或备份策略，或是由集群管理员制定的任意策略。 Kubernetes 本身并不清楚各种类代表的什么。这个类的概念在其他存储系统中有时被称为 “配置文件”。</p><h3 id="StorageClass-资源"><a href="#StorageClass-资源" class="headerlink" title="StorageClass 资源"></a>StorageClass 资源</h3><p>每个 StorageClass 都包含 <code>provisioner</code>、<code>parameters</code> 和 <code>reclaimPolicy</code> 字段， 这些字段会在 StorageClass 需要动态分配 PersistentVolume 时会使用到。</p><p>StorageClass 对象的命名很重要，用户使用这个命名来请求生成一个特定的类。 当创建 StorageClass 对象时，管理员设置 StorageClass 对象的命名和其他参数，一旦创建了对象就不能再对其更新。</p><h3 id="存储制备器"><a href="#存储制备器" class="headerlink" title="存储制备器"></a>存储制备器</h3><p>每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。</p><table><thead><tr><th align="left">卷插件</th><th align="center">内置制备器</th><th align="center">配置例子</th></tr></thead><tbody><tr><td align="left">AWSElasticBlockStore</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#aws-ebs" target="_blank" rel="noopener">AWS EBS</a></td></tr><tr><td align="left">AzureFile</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#azure-file" target="_blank" rel="noopener">Azure File</a></td></tr><tr><td align="left">AzureDisk</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#azure-disk" target="_blank" rel="noopener">Azure Disk</a></td></tr><tr><td align="left">CephFS</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Cinder</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#openstack-cinder" target="_blank" rel="noopener">OpenStack Cinder</a></td></tr><tr><td align="left">FC</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">FlexVolume</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Flocker</td><td align="center">✓</td><td align="center">-</td></tr><tr><td align="left">GCEPersistentDisk</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#gce-pd" target="_blank" rel="noopener">GCE PD</a></td></tr><tr><td align="left">Glusterfs</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#glusterfs" target="_blank" rel="noopener">Glusterfs</a></td></tr><tr><td align="left">iSCSI</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Quobyte</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#quobyte" target="_blank" rel="noopener">Quobyte</a></td></tr><tr><td align="left">NFS</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">RBD</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#ceph-rbd" target="_blank" rel="noopener">Ceph RBD</a></td></tr><tr><td align="left">VsphereVolume</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#vsphere" target="_blank" rel="noopener">vSphere</a></td></tr><tr><td align="left">PortworxVolume</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#portworx-volume" target="_blank" rel="noopener">Portworx Volume</a></td></tr><tr><td align="left">ScaleIO</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#scaleio" target="_blank" rel="noopener">ScaleIO</a></td></tr><tr><td align="left">StorageOS</td><td align="center">✓</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#storageos" target="_blank" rel="noopener">StorageOS</a></td></tr><tr><td align="left">Local</td><td align="center">-</td><td align="center"><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#local" target="_blank" rel="noopener">Local</a></td></tr></tbody></table><h2 id="动态卷供应"><a href="#动态卷供应" class="headerlink" title="动态卷供应"></a>动态卷供应</h2><p>动态卷供应允许按需创建存储卷。 如果没有动态供应，集群管理员必须手动地联系他们的云或存储提供商来创建新的存储卷， 然后在 Kubernetes 集群创建<a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener"><code>PersistentVolume</code> 对象</a>来表示这些卷。 动态供应功能消除了集群管理员预先配置存储的需要。 相反，它在用户请求时自动供应存储。</p><p>由于 NFS 卷插件并不支持内置制备器，所以我们用 NFS 作为底层存储去配置动态卷供应时，需要使用第三方的 NFS 插件 <a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner" target="_blank" rel="noopener">nfs-subdir-external-provisioner</a>。</p><p>部署 NFS 插件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment" spellcheck="true"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> Recreate  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner          <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/external_storage/nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">:</span>latest          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /persistentvolumes          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PROVISIONER_NAME              <span class="token key atrule">value</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>sigs.io/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_SERVER              <span class="token key atrule">value</span><span class="token punctuation">:</span> 10.10.110.193 <span class="token comment" spellcheck="true"># NFS的服务地址</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_PATH              <span class="token key atrule">value</span><span class="token punctuation">:</span> /data/kubernetes <span class="token comment" spellcheck="true"># NFS的Export路径</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> 10.10.110.193            <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/kubernetes<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> managed<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>sigs.io/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner <span class="token comment" spellcheck="true"># or choose another name, must match deployment's env PROVISIONER_NAME'</span><span class="token key atrule">parameters</span><span class="token punctuation">:</span>  <span class="token key atrule">archiveOnDelete</span><span class="token punctuation">:</span> <span class="token string">"false"</span> <span class="token comment" spellcheck="true"># "false": 删除pvc之后NFS存储后端不会保留数据目录,"true": 删除pvc之后NFS存储后端会保留数据目录</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment" spellcheck="true"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"nodes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumeclaims"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storage.k8s.io"</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storageclasses"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"events"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> run<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment" spellcheck="true"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment" spellcheck="true"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"endpoints"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment" spellcheck="true"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment" spellcheck="true"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 PersistentVolumeClaim 测试动态卷供应：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 指定storageClassName</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 800Mi  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"managed-nfs-storage"</span><span class="token comment" spellcheck="true"># 使用annotations</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc1  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">volume.beta.kubernetes.io/storage-class</span><span class="token punctuation">:</span> <span class="token string">"managed-nfs-storage"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 800Mi<span class="token comment" spellcheck="true"># 指定sc作为默认存储后端</span>kubectl patch storageclass managed<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage <span class="token punctuation">-</span>p '<span class="token punctuation">{</span><span class="token key atrule">"metadata"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>"annotations"<span class="token punctuation">:</span><span class="token punctuation">{</span>"storageclass.kubernetes.io/is<span class="token punctuation">-</span>default<span class="token punctuation">-</span>class"<span class="token punctuation">:</span><span class="token string">"true"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>'<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pvc1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 800Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/issues/25" target="_blank" rel="noopener">关于 kubernetes 1.20 版本使用 NFS 插件出现 unexpected error getting claim reference: selfLink was empty, can’t make reference 的报错。</a>这是因为 kubernetes 1.20 版本禁用了 selfLink 。解决方法：</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /etc/kubernetes/manifests/kube<span class="token punctuation">-</span>apiserver.yaml<span class="token punctuation">...</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> kube<span class="token punctuation">-</span>apiserver    <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>feature<span class="token punctuation">-</span>gates=RemoveSelfLink=false <span class="token comment" spellcheck="true"># 添加这一行</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>此模块 整合了 Kubernetes 所有资源的配置。</p><h2 id="配置最佳实践"><a href="#配置最佳实践" class="headerlink" title="配置最佳实践"></a>配置最佳实践</h2><p><a href="https://kubernetes.io/zh/docs/concepts/configuration/overview/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/configuration/overview/</a></p><h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pods</a> 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</p><p>ConfigMap 将您的环境配置信息和 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image" target="_blank" rel="noopener">容器镜像</a> 解耦，便于应用配置的修改。</p><blockquote><p>注意：ConfigMap 并不提供保密或者加密功能。 如果你想存储的数据是机密的，请使用 <a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Secret</a>， 或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。</p></blockquote><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>使用 ConfigMap 来将你的配置数据和应用程序代码分开。</p><p>比如，假设你正在开发一个应用，它可以在你自己的电脑上（用于开发）和在云上 （用于实际流量）运行。 你的代码里有一段是用于查看环境变量 <code>DATABASE_HOST</code>，在本地运行时， 你将这个变量设置为 <code>localhost</code>，在云上，你将其设置为引用 Kubernetes 集群中的公开数据库组件的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">服务</a>。</p><p>这让你可以获取在云中运行的容器镜像，并且如果有需要的话，在本地调试完全相同的代码。</p><p>ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1 MiB。如果你需要保存超出此尺寸限制的数据，你可能希望考虑挂载存储卷或者使用独立的数据库或者文件服务。</p><h3 id="ConfigMap-对象"><a href="#ConfigMap-对象" class="headerlink" title="ConfigMap 对象"></a>ConfigMap 对象</h3><p>ConfigMap 是一个 API <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank" rel="noopener">对象</a>， 让你可以存储其他对象所需要使用的配置。 和其他 Kubernetes 对象都有一个 <code>spec</code> ，不同的是，ConfigMap 使用 <code>data</code> 和 <code>binaryData</code> 字段。这些字段能够接收键-值对作为其取值。<code>data</code> 和 <code>binaryData</code> 字段都是可选的。<code>data</code> 字段设计用来保存 UTF-8 字节序列，而 <code>binaryData</code> 则被设计用来保存二进制数据作为 base64 编码的字串。</p><p>ConfigMap 的名字必须是一个合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank" rel="noopener">DNS 子域名</a>。</p><p><code>data</code> 或 <code>binaryData</code> 字段下面的每个键的名称都必须由字母数字字符或者 <code>-</code>、<code>_</code> 或 <code>.</code> 组成。在 <code>data</code> 下保存的键名不可以与在 <code>binaryData</code> 下出现的键名有重叠。</p><p>从 v1.19 开始，你可以添加一个 <code>immutable</code> 字段到 ConfigMap 定义中，创建 <a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/#configmap-immutable" target="_blank" rel="noopener">不可变更的 ConfigMap</a>。</p><h3 id="ConfigMaps-和-Pods"><a href="#ConfigMaps-和-Pods" class="headerlink" title="ConfigMaps 和 Pods"></a>ConfigMaps 和 Pods</h3><p>你可以写一个引用 ConfigMap 的 Pod 的 <code>spec</code>，并根据 ConfigMap 中的数据在该 Pod 中配置容器。这个 Pod 和 ConfigMap 必须要在同一个 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">名字空间</a> 中。</p><p>这是一个 ConfigMap 的示例，它的一些键只有一个值，其他键的值看起来像是配置的片段格式。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> configmap<span class="token punctuation">-</span>demo<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 类属性键:每一个键都映射到一个简单的值</span>  <span class="token key atrule">nginx_server_port</span><span class="token punctuation">:</span> <span class="token string">"80"</span>  <span class="token key atrule">nginx_server_host</span><span class="token punctuation">:</span> <span class="token string">"www.missf.top"</span>  <span class="token comment" spellcheck="true"># 类文件键</span>  <span class="token key atrule">nginx.config</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    location / {        root /usr/local/nginx/html/;        index index.html;    }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以使用四种方式来使用 ConfigMap 配置 Pod 中的容器：</p><ol><li>在容器命令和参数内</li><li>容器的环境变量</li><li>在只读卷里面添加一个文件，让应用来读取</li><li>编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap</li></ol><p>这些不同的方法适用于不同的数据使用方式。 对前三个方法，<a href="https://kubernetes.io/docs/reference/generated/kubelet" target="_blank" rel="noopener">kubelet</a> 使用 ConfigMap 中的数据在 Pod 中启动容器。</p><p>第四种方法意味着你必须编写代码才能读取 ConfigMap 和它的数据。然而， 由于你是直接使用 Kubernetes API，因此只要 ConfigMap 发生更改，你的应用就能够通过订阅来获取更新，并且在这样的情况发生的时候做出反应。 通过直接进入 Kubernetes API，这个技术也可以让你能够获取到不同的名字空间里的 ConfigMap。</p><p>下面是一个 Pod 的示例，它通过使用 <code>configmap-demo</code> 中的值来配置一个 Pod：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> configmap<span class="token punctuation">-</span>pod  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> configmap<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NGINX_SERVER_PORT        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> configmap<span class="token punctuation">-</span>demo            <span class="token key atrule">key</span><span class="token punctuation">:</span> nginx_server_port      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NGINX_SERVER_HOST        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> configmap<span class="token punctuation">-</span>demo            <span class="token key atrule">key</span><span class="token punctuation">:</span> nginx_server_host    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/config"</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> configmap<span class="token punctuation">-</span>demo        <span class="token key atrule">items</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"nginx.config"</span>          <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"nginx.config"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ConfigMap 不会区分单行属性值和多行类似文件的值，重要的是 Pods 和其他对象如何使用这些值。（能否自动更新也是看 Pods 如何去使用 ConfigMap）</p><p>上面的例子定义了一个卷并将它作为 <code>/config</code> 文件夹挂载到 <code>demo</code> 容器内， 创建一个文件，<code>/config/nginx.config</code></p><h3 id="使用-ConfigMap"><a href="#使用-ConfigMap" class="headerlink" title="使用 ConfigMap"></a>使用 ConfigMap</h3><p>ConfigMap 可以作为数据卷挂载。ConfigMap 也可被系统的其他组件使用，而不一定直接暴露给 Pod。例如，ConfigMap 可以保存系统中其他组件要使用的配置数据。</p><p>ConfigMap 最常见的用法是为同一命名空间里某 Pod 中运行的容器执行配置。 你也可以单独使用 ConfigMap。</p><p>比如，你可能会遇到基于 ConfigMap 来调整其行为的 <a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">插件</a> 或者 <a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/" target="_blank" rel="noopener">operator</a>。</p><h4 id="在-Pod-中将-ConfigMap-当做文件使用"><a href="#在-Pod-中将-ConfigMap-当做文件使用" class="headerlink" title="在 Pod 中将 ConfigMap 当做文件使用"></a>在 Pod 中将 ConfigMap 当做文件使用</h4><ol><li>创建一个 ConfigMap 对象或者使用现有的 ConfigMap 对象。多个 Pod 可以引用同一个 ConfigMap。</li><li>修改 Pod 定义，在 <code>spec.volumes[]</code> 下添加一个卷。 为该卷设置任意名称，之后将 <code>spec.volumes[].configMap.name</code> 字段设置为对你的 ConfigMap 对象的引用。</li><li>为每个需要该 ConfigMap 的容器添加一个 <code>.spec.containers[].volumeMounts[]</code>。 设置 <code>.spec.containers[].volumeMounts[].readOnly=true</code> 并将 <code>.spec.containers[].volumeMounts[].mountPath</code> 设置为一个未使用的目录名， ConfigMap 的内容将出现在该目录中。</li><li>更改你的镜像或者命令行，以便程序能够从该目录中查找文件。ConfigMap 中的每个 <code>data</code> 键会变成 <code>mountPath</code> 下面的一个文件名。</li></ol><p>下面是一个将 ConfigMap 以卷的形式进行挂载的 Pod 示例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/foo"</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo    <span class="token key atrule">configMap</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> myconfigmap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你希望使用的每个 ConfigMap 都需要在 <code>spec.volumes</code> 中被引用到。</p><p>如果 Pod 中有多个容器，则每个容器都需要自己的 <code>volumeMounts</code> 块，但针对每个 ConfigMap，你只需要设置一个 <code>spec.volumes</code> 块。</p><h4 id="被挂载的-ConfigMap-内容会被自动更新"><a href="#被挂载的-ConfigMap-内容会被自动更新" class="headerlink" title="被挂载的 ConfigMap 内容会被自动更新"></a>被挂载的 ConfigMap 内容会被自动更新</h4><p>当卷中使用的 ConfigMap 被更新时，所投射的键最终也会被更新。 kubelet 组件会在每次周期性同步时检查所挂载的 ConfigMap 是否为最新。 不过，kubelet 使用的是其本地的高速缓存来获得 ConfigMap 的当前值。 高速缓存的类型可以通过 <a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubelet/config/v1beta1/types.go" target="_blank" rel="noopener">KubeletConfiguration 结构</a> 的 <code>ConfigMapAndSecretChangeDetectionStrategy</code> 字段来配置。</p><p>ConfigMap 既可以通过 watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，这一 时间跨度可能与 kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型 （分别对应 watch 操作的传播延迟、高速缓存的 TTL 时长或者 0）。</p><p>以环境变量方式使用的 ConfigMap 数据不会被自动更新。 更新这些数据需要重新启动 Pod。</p><h3 id="不可变更的-ConfigMap"><a href="#不可变更的-ConfigMap" class="headerlink" title="不可变更的 ConfigMap"></a>不可变更的 ConfigMap</h3><p>Kubernetes 不可变更的 Secret 和 ConfigMap 提供了一种将各个 Secret 和 ConfigMap 设置为不可变更的选项。对于大量使用 ConfigMap 的集群（至少有数万个各不相同的 ConfigMap 给 Pod 挂载）而言，禁止更改 ConfigMap 的数据有以下好处：</p><ul><li>保护应用，使之免受意外（不想要的）更新所带来的负面影响。</li><li>通过大幅降低对 kube-apiserver 的压力提升集群性能，这是因为系统会关闭对已标记为不可变更的 ConfigMap 的监视操作。</li></ul><p>此功能特性由 <code>ImmutableEphemeralVolumes</code> <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/feature-gates/" target="_blank" rel="noopener">特性门控</a> 来控制。你可以通过将 <code>immutable</code> 字段设置为 <code>true</code> 创建不可变更的 ConfigMap。 例如：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token punctuation">...</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token punctuation">...</span><span class="token key atrule">immutable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一旦某 ConfigMap 被标记为不可变更，则无法逆转这一变化，也无法更改 <code>data</code> 或 <code>binaryData</code> 字段的内容。你只能删除并重建 ConfigMap。 因为现有的 Pod 会维护一个对已删除的 ConfigMap 的挂载点，建议重新创建这些 Pods。</p><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p><code>Secret</code> 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 <code>secret</code> 中比放在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a> 的定义或者 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image" target="_blank" rel="noopener">容器镜像</a> 中来说更加安全和灵活。 参阅 <a href="https://git.k8s.io/community/contributors/design-proposals/auth/secrets.md" target="_blank" rel="noopener">Secret 设计文档</a> 获取更多详细信息。</p><p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 用户可以创建 Secret，同时系统也创建了一些 Secret。</p><p><strong>注意：</strong>Kubernetes Secret 默认情况下存储为 base64-编码的、非加密的字符串。 默认情况下，能够访问 API 的任何人，或者能够访问 Kubernetes 下层数据存储（etcd） 的任何人都可以以明文形式读取这些数据。 为了能够安全地使用 Secret，我们建议你（至少）：</p><ol><li>为 Secret <a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/encrypt-data/" target="_blank" rel="noopener">启用静态加密</a>；</li><li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">启用或配置 RBAC 规则</a>来限制对 Secret 的读写操作。 要注意，任何被允许创建 Pod 的人都默认地具有读取 Secret 的权限。</li></ol><h3 id="Secret-概览"><a href="#Secret-概览" class="headerlink" title="Secret 概览"></a>Secret 概览</h3><p>要使用 Secret，Pod 需要引用 Secret。 Pod 可以用三种方式之一来使用 Secret：</p><ul><li>作为挂载到一个或多个容器上的 <a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/" target="_blank" rel="noopener">卷</a> 中的<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod" target="_blank" rel="noopener">文件</a>。</li><li>作为<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-secrets-as-environment-variables" target="_blank" rel="noopener">容器的环境变量</a></li><li>由 <a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/#using-imagepullsecrets" target="_blank" rel="noopener">kubelet 在为 Pod 拉取镜像时使用</a></li></ul><p>Secret 对象的名称必须是合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank" rel="noopener">DNS 子域名</a>。 在为创建 Secret 编写配置文件时，你可以设置 <code>data</code> 与/或 <code>stringData</code> 字段。 <code>data</code> 和 <code>stringData</code> 字段都是可选的。<code>data</code> 字段中所有键值都必须是 base64 编码的字符串。如果不希望执行这种 base64 字符串的转换操作，你可以选择设置 <code>stringData</code> 字段，其中可以使用任何字符串作为其取值。</p><h3 id="Secret-的类型"><a href="#Secret-的类型" class="headerlink" title="Secret 的类型"></a>Secret 的类型</h3><p>在创建 Secret 对象时，你可以使用 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#secret-v1-core" target="_blank" rel="noopener"><code>Secret</code></a> 资源的 <code>type</code> 字段，或者与其等价的 <code>kubectl</code> 命令行参数（如果有的话）为其设置类型。 Secret 的类型用来帮助编写程序处理 Secret 数据。</p><p>Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。 针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。</p><table><thead><tr><th>内置类型</th><th>用法</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>用户定义的任意数据</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>服务账号令牌</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td><code>~/.dockercfg</code> 文件的序列化形式</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td><code>~/.docker/config.json</code> 文件的序列化形式</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>用于基本身份认证的凭据</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>用于 SSH 身份认证的凭据</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>用于 TLS 客户端或者服务器端的数据</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>启动引导令牌数据</td></tr></tbody></table><p>通过为 Secret 对象的 <code>type</code> 字段设置一个非空的字符串值，你也可以定义并使用自己 Secret 类型。如果 <code>type</code> 值为空字符串，则被视为 <code>Opaque</code> 类型。 Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。</p><h3 id="创建-Secret"><a href="#创建-Secret" class="headerlink" title="创建 Secret"></a>创建 Secret</h3><p>有几种不同的方式来创建 Secret：</p><p><a href="https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-kubectl/" target="_blank" rel="noopener">使用 <code>kubectl</code> 命令创建 Secret</a></p><p>一个 <code>Secret</code> 可以包含 Pod 访问数据库所需的用户凭证。 例如，由用户名和密码组成的数据库连接字符串。 你可以在本地计算机上，将用户名存储在文件 <code>./username.txt</code> 中，将密码存储在文件 <code>./password.txt</code> 中。</p><pre class="line-numbers language-shell"><code class="language-shell">echo -n 'admin' > ./username.txtecho -n 'Er34ff5ghoo' > ./password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这些命令中，<code>-n</code> 标志确保生成的文件在文本末尾不包含额外的换行符。 这一点很重要，因为当 <code>kubectl</code> 读取文件并将内容编码为 base64 字符串时，多余的换行符也会被编码。</p><p><code>kubectl create secret</code> 命令将这些文件打包成一个 Secret 并在 API 服务器上创建对象。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl create secret generic db-user-pass --from-file=user=username.txt --from-file=pass=password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">secret/db-user-pass created<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认密钥名称是文件名。 你可以选择使用 <code>--from-file=[key=]source</code> 来设置密钥名称。例如：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl create secret generic db-user-pass \  --from-file=username=./username.txt \  --from-file=password=./password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查 secret 是否已创建：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get secrets<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以查看 <code>Secret</code> 的描述：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl describe secrets/db-user-pass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要查看创建的 Secret 的内容，运行以下命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get secret db-user-pass -o jsonpath='{.data}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"pass"</span><span class="token operator">:</span><span class="token string">"RXIzNGZmNWdob28="</span><span class="token punctuation">,</span><span class="token property">"user"</span><span class="token operator">:</span><span class="token string">"YWRtaW4="</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在你可以解码 <code>pass</code> 的数据：</p><pre class="line-numbers language-shell"><code class="language-shell">echo "RXIzNGZmNWdob28=" | base64 --decode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">Er34ff5ghoo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-config-file/" target="_blank" rel="noopener">使用配置文件来创建 Secret</a></p><p>你可以先用 JSON 或 YAML 格式在文件中创建 Secret，然后创建该对象。 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#secret-v1-core" target="_blank" rel="noopener">Secret</a> 资源包含2个键值对： <code>data</code> 和 <code>stringData</code>。 <code>data</code> 字段用来存储 base64 编码的任意数据。 提供 <code>stringData</code> 字段是为了方便，它允许 Secret 使用未编码的字符串。 <code>data</code> 和 <code>stringData</code> 的键必须由字母、数字、<code>-</code>，<code>_</code> 或 <code>.</code> 组成。</p><p>例如，要使用 Secret 的 <code>data</code> 字段存储两个字符串，请将字符串转换为 base64 ，如下所示：</p><pre class="line-numbers language-shell"><code class="language-shell">echo -n 'admin' | base64echo -n 'Er34ff5ghoo' | base64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">YWRtaW4=RXIzNGZmNWdob28=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编写一个 Secret 配置文件，如下所示：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">username</span><span class="token punctuation">:</span> YWRtaW4=  <span class="token key atrule">password</span><span class="token punctuation">:</span> RXIzNGZmNWdob28=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于某些场景，你可能希望使用 <code>stringData</code> 字段。 这字段可以将一个非 base64 编码的字符串直接放入 Secret 中， 当创建或更新该 Secret 时，此字段将被编码。</p><p>例如，如果你的应用程序使用以下配置文件:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiUrl</span><span class="token punctuation">:</span> <span class="token string">"https://my.api.com/api/v1"</span><span class="token key atrule">username</span><span class="token punctuation">:</span> <span class="token string">"&lt;user>"</span><span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token string">"&lt;password>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你可以使用以下定义将其存储在 Secret 中:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">stringData</span><span class="token punctuation">:</span>  <span class="token key atrule">config.yaml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    apiUrl: "https://my.api.com/api/v1"    username: &lt;user>    password: &lt;password></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://kubernetes.io/zh/docs/tasks/configmap-secret/managing-secret-using-kustomize/" target="_blank" rel="noopener">使用 kustomize 来创建 Secret</a></p><p>你可以在 <code>kustomization.yaml</code> 中定义 <code>secreteGenerator</code>，并在定义中引用其他现成的文件，生成 Secret。 例如：下面的 kustomization 文件 引用了 <code>./username.txt</code> 和 <code>./password.txt</code> 文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">secretGenerator</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db<span class="token punctuation">-</span>user<span class="token punctuation">-</span>pass  <span class="token key atrule">files</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> username.txt  <span class="token punctuation">-</span> password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以在 <code>kustomization.yaml</code> 文件中指定一些字面量定义 <code>secretGenerator</code>。 例如：下面的 <code>kustomization.yaml</code> 文件中包含了 <code>username</code> 和 <code>password</code> 两个字面量：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">secretGenerator</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> db<span class="token punctuation">-</span>user<span class="token punctuation">-</span>pass  <span class="token key atrule">literals</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> username=admin  <span class="token punctuation">-</span> password=1f2d1e2e67df<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，上面两种情况，你都不需要使用 base64 编码。</p><p>使用 <code>kubectl apply</code> 命令应用包含 <code>kustomization.yaml</code> 文件的目录创建 Secret。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl apply -k .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="编辑-Secret"><a href="#编辑-Secret" class="headerlink" title="编辑 Secret"></a>编辑 Secret</h3><p>你可以通过下面的命令编辑现有的 Secret：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl edit secrets mysecret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用-Secret"><a href="#使用-Secret" class="headerlink" title="使用 Secret"></a>使用 Secret</h3><p>Secret 可以作为数据卷被挂载，或作为 <a href="https://kubernetes.io/zh/docs/concepts/containers/container-environment/" target="_blank" rel="noopener">环境变量</a> 暴露出来以供 Pod 中的容器使用。它们也可以被系统的其他部分使用，而不直接暴露在 Pod 内。 例如，它们可以保存凭据，系统的其他部分将用它来代表你与外部系统进行交互。</p><p>将 Secret 作为 Pod 中的<a href="https://kubernetes.io/zh/docs/concepts/containers/container-environment/" target="_blank" rel="noopener">环境变量</a>使用：</p><ol><li>创建一个 Secret 或者使用一个已存在的 Secret。多个 Pod 可以引用同一个 Secret。</li><li>修改 Pod 定义，为每个要使用 Secret 的容器添加对应 Secret 键的环境变量。 使用 Secret 键的环境变量应在 <code>env[x].valueFrom.secretKeyRef</code> 中指定要包含的 Secret 名称和键名。</li><li>更改镜像并／或者命令行，以便程序在指定的环境变量中查找值。</li></ol><p>这是一个使用来自环境变量中的 Secret 值的 Pod 示例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>env<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SECRET_USERNAME        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret            <span class="token key atrule">key</span><span class="token punctuation">:</span> username      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SECRET_PASSWORD        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>                 <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret            <span class="token key atrule">key</span><span class="token punctuation">:</span> password  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Pod 中使用存放在卷中的 Secret：</p><ol><li>创建一个 Secret 或者使用已有的 Secret。多个 Pod 可以引用同一个 Secret。</li><li>修改你的 Pod 定义，在 <code>spec.volumes[]</code> 下增加一个卷。可以给这个卷随意命名， 它的 <code>spec.volumes[].secret.secretName</code> 必须是 Secret 对象的名字。</li><li>将 <code>spec.containers[].volumeMounts[]</code> 加到需要用到该 Secret 的容器中。 指定 <code>spec.containers[].volumeMounts[].readOnly = true</code> 和 <code>spec.containers[].volumeMounts[].mountPath</code> 为你想要该 Secret 出现的尚未使用的目录。</li><li>修改你的镜像并且／或者命令行，让程序从该目录下寻找文件。 Secret 的 <code>data</code> 映射中的每一个键都对应 <code>mountPath</code> 下的一个文件名。</li></ol><p>这是一个在 Pod 中使用存放在挂载卷中 Secret 的例子：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>volume<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/foo"</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo    <span class="token key atrule">secret</span><span class="token punctuation">:</span>      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> mysecret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="挂载的-Secret-会被自动更新"><a href="#挂载的-Secret-会被自动更新" class="headerlink" title="挂载的 Secret 会被自动更新"></a>挂载的 Secret 会被自动更新</h3><p>当已经存储于卷中被使用的 Secret 被更新时，被映射的键也将被更新。 组件 kubelet 在周期性同步时检查被挂载的 Secret 是不是最新的。 但是，它会使用其本地缓存的数值作为 Secret 的当前值。</p><h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p><p>StatefulSet 用来管理某 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a> 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p><p>和 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a> 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p><p>StatefulSets 对于需要满足以下一个或多个需求的应用程序很有价值：</p><ul><li>稳定的、唯一的网络标识符。</li><li>稳定的、持久的存储。</li><li>有序的、优雅的部署和缩放。</li><li>有序的、自动的滚动更新。</li></ul><p>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或伸缩，则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a> 或者 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet</a> 可能更适用于你的无状态应用部署需要。</p><h2 id="创建-StatefulSet"><a href="#创建-StatefulSet" class="headerlink" title="创建 StatefulSet"></a>创建 StatefulSet</h2><p>作为开始，使用如下示例创建一个 StatefulSet。它和 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets</a> 概念中的示例相似。 它创建了一个 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener">Headless Service</a> <code>statefulset-service</code> 用来发布 StatefulSet <code>web</code> 中的 Pod 的 IP 地址。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> statefulset<span class="token punctuation">-</span>service  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> statefulset<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"statefulset-service"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> web        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> www    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"managed-nfs-storage"</span>      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 2Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="顺序创建-Pod"><a href="#顺序创建-Pod" class="headerlink" title="顺序创建 Pod"></a>顺序创建 Pod</h3><p>对于一个拥有 N 个副本的 StatefulSet，Pod 被部署时是按照 {0 …… N-1} 的序号顺序创建的。 在第一个终端中使用 <code>kubectl get</code> 检查输出。这个输出最终将看起来像下面的样子。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pod -w -l app=nginxNAME    READY   STATUS    RESTARTS   AGEweb-0   0/1     Pending   0          0sweb-0   0/1     Pending   0          0sweb-0   0/1     ContainerCreating   0          0sweb-0   0/1     ContainerCreating   0          2sweb-0   1/1     Running             0          18sweb-1   0/1     Pending             0          0sweb-1   0/1     Pending             0          0sweb-1   0/1     ContainerCreating   0          0sweb-1   0/1     ContainerCreating   0          1sweb-1   1/1     Running             0          17sweb-2   0/1     Pending             0          0sweb-2   0/1     Pending             0          0sweb-2   0/1     ContainerCreating   0          0sweb-2   0/1     ContainerCreating   0          1sweb-2   1/1     Running             0          17s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意在 <code>web-0</code> Pod 处于 <a href="https://kubernetes.io/zh/docs/user-guide/pod-states" target="_blank" rel="noopener">Running和Ready</a> 状态后 <code>web-1</code> Pod 才会被启动。</p><h2 id="StatefulSet-中的-Pod"><a href="#StatefulSet-中的-Pod" class="headerlink" title="StatefulSet 中的 Pod"></a>StatefulSet 中的 Pod</h2><p>StatefulSet 中的 Pod 拥有一个唯一的顺序索引和稳定的网络身份标识。</p><h3 id="检查-Pod-的顺序索引"><a href="#检查-Pod-的顺序索引" class="headerlink" title="检查 Pod 的顺序索引"></a>检查 Pod 的顺序索引</h3><p>获取 StatefulSet 的 Pod。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods -l app=nginxNAME    READY   STATUS    RESTARTS   AGEweb-0   1/1     Running   0          5m11sweb-1   1/1     Running   0          4m53sweb-2   1/1     Running   0          4m36s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如同 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets</a> 概念中所提到的， StatefulSet 中的 Pod 拥有一个具有黏性的、独一无二的身份标志。 这个标志基于 StatefulSet 控制器分配给每个 Pod 的唯一顺序索引。 Pod 的名称的形式为<code>&lt;statefulset name&gt;-&lt;ordinal index&gt;</code>。 <code>web</code>StatefulSet 拥有两个副本，所以它创建了三个 Pod：<code>web-0</code>，<code>web-1</code> 和 <code>web-2</code>。</p><h3 id="使用稳定的网络身份标识"><a href="#使用稳定的网络身份标识" class="headerlink" title="使用稳定的网络身份标识"></a>使用稳定的网络身份标识</h3><p>每个 Pod 都拥有一个基于其顺序索引的稳定的主机名。使用<a href="https://kubernetes.io/zh/docs/reference/generated/kubectl/kubectl-commands/#exec" target="_blank" rel="noopener"><code>kubectl exec</code></a>在每个 Pod 中执行<code>hostname</code>。</p><pre class="line-numbers language-shell"><code class="language-shell">for i in 0 1; do kubectl exec "web-$i" -- sh -c 'hostname'; doneweb-0web-1web-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <a href="https://kubernetes.io/zh/docs/reference/generated/kubectl/kubectl-commands/#run" target="_blank" rel="noopener"><code>kubectl run</code></a> 运行一个提供 <code>nslookup</code> 命令的容器，该命令来自于 <code>dnsutils</code> 包。 通过对 Pod 的主机名执行 <code>nslookup</code>，你可以检查他们在集群内部的 DNS 地址。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将启动一个新的 shell。在新 shell 中，运行：</p><pre class="line-numbers language-shell"><code class="language-shell"># Run this in the dns-test container shellnslookup statefulset-service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">Server:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName:      statefulset-serviceAddress 1: 10.244.169.165 web-0.statefulset-service.default.svc.cluster.localAddress 2: 10.244.36.98 web-1.statefulset-service.default.svc.cluster.localAddress 3: 10.244.169.166 web-2.statefulset-service.default.svc.cluster.local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使 Pod 重建之后 IP 发生改变，Headless Service 还是能够根据 web-{0-1}.statefulset-service.default.svc.cluster.local 这个 DNS A 记录来找到每个 pod 的 IP 地址。</p><h3 id="标准-Service-和-Headless-Service-的区别"><a href="#标准-Service-和-Headless-Service-的区别" class="headerlink" title="标准 Service 和 Headless Service 的区别"></a>标准 Service 和 Headless Service 的区别</h3><p>这里要提到 <code>无状态应用控制器</code> 和 <code>有状态应用控制器</code> 的设计理念，无状态的 Pod 是完全相等的，提供相同的服务，可以飘移在任意节点，例如三个 NGINX Pod 所提供的 Web 服务。而像一些分布式应用程序，例如 zookeeper 集群、etcd 集群、mysql 主从等服务，每个实例都会维护着一种状态，每个实例都有自己的数据，并且每个实例之间必须有固定的访问地址（组建集群），这就是有状态应用。由于标准 Service 是通过访问 ClusterIP 负载均衡到一组 Pod 上，这是没有办法指定访问到某个 Pod 的（由 iptables 决定）。所以这里就出现了 Headless Service ，而且 Headless Service 不需要 ClusterIP ，它是通过访问 Pod DNS 名称解析到对应的 Pod IP，为每一个 Pod 都固定一个 DNS 名称，即使 Pod 的 IP 发生改变，Pod 的 DNS 名称还是指向对应的 Pod IP 地址。</p><h3 id="写入稳定的存储"><a href="#写入稳定的存储" class="headerlink" title="写入稳定的存储"></a>写入稳定的存储</h3><p>Kubernetes 为每个 VolumeClaimTemplate 创建一个 <a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">PersistentVolume</a>。 在上面的 nginx 示例中，每个 Pod 将会得到基于 StorageClass <code>managed-nfs-storage</code> 提供的 2 Gib 的 PersistentVolume。如果没有声明 StorageClass，就会使用默认的 StorageClass。 当一个 Pod 被调度（重新调度）到节点上时，它的 <code>volumeMounts</code> 会挂载与其 PersistentVolumeClaims 相关联的 PersistentVolume。 请注意，当 Pod 或者 StatefulSet 被删除时，与 PersistentVolumeClaims 相关联的 PersistentVolume 并不会被删除。要删除它必须通过手动方式来完成。</p><p>获取 StatefulSet 创建的 PersistentVolumeClaims。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get pvc -l app=nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGEwww-web-0   Bound    pvc-83489225-7d08-4506-9f75-1fefd3aee287   2Gi        RWO            managed-nfs-storage   23hwww-web-1   Bound    pvc-e5afdbfa-952e-4120-8885-00cf5a524eb0   2Gi        RWO            managed-nfs-storage   23hwww-web-2   Bound    pvc-21e9a5b1-a040-41c6-9b94-6bcf7a8a8966   2Gi        RWO            managed-nfs-storage   23h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>StatefulSet 控制器创建了三个 PersistentVolumeClaims，绑定到三个 <a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/" target="_blank" rel="noopener">PersistentVolumes</a>。由于本教程使用的集群配置为动态提供 PersistentVolume，所有的 PersistentVolume 都是自动创建和绑定的，对于动态配置的 PersistentVolumes 来说，默认回收策略为 “Delete”。</p><p>NGINX web 服务器默认会加载位于 <code>/usr/share/nginx/html/index.html</code> 的 index 文件。 StatefulSets <code>spec</code> 中的 <code>volumeMounts</code> 字段保证了 <code>/usr/share/nginx/html</code> 文件夹由一个 PersistentVolume 支持。</p><p>将 Pod 的主机名写入它们的<code>index.html</code>文件并验证 NGINX web 服务器使用该主机名提供服务。</p><pre class="line-numbers language-shell"><code class="language-shell">for i in 0 1 2; do kubectl exec "web-$i" -- sh -c 'echo $(hostname) > /usr/share/nginx/html/index.html'; donefor i in 0 1 2; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在另一个终端删除 StatefulSet 所有的 Pod。</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl delete pod -l app=nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证所有 web 服务器在继续使用它们的主机名提供服务。</p><pre class="line-numbers language-shell"><code class="language-shell">for i in 0 1 2; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然 Pod<code>web-{0-2}</code> 被重新调度了，但它们仍然继续监听各自的主机名，因为和它们的 PersistentVolumeClaim 相关联的 PersistentVolume 被重新挂载到了各自的 <code>volumeMount</code> 上。 不管 Pod 被调度到了哪个节点上，它们的 PersistentVolumes 将会被挂载到合适的挂载点上。</p><h1 id="认证、授权与准入控制"><a href="#认证、授权与准入控制" class="headerlink" title="认证、授权与准入控制"></a>认证、授权与准入控制</h1><p>在任何将资源或服务提供给有限使用者的系统上，认证和授权是两个必不可少的功能，前者用于身份鉴别，负责验证“来者是谁”，而后者则实现权限分派，负责验证“他有权做什么事”。Kubernetes 系统完全分离了身份验证和授权功能，将二者分别以多种不同的插件实现，而且还有特有的准入控制机制，能在“写”请求上辅助完成更为精细的操作验证及变异功能。</p><h2 id="Kubernetes-访问控制"><a href="#Kubernetes-访问控制" class="headerlink" title="Kubernetes 访问控制"></a>Kubernetes 访问控制</h2><p>API Server 作为 Kubernetes 集群系统的网关，是访问及管理资源对象的唯一入口，它默认监听 TCP 的 6443 端口，通过 HTTPS 协议暴露了一个 RESTful 风格的接口。所有需要访问集群资源的集群组件或客户端，包括 kube-controller-manager、kube-scheduler、kubelet 和 kube-proxy 等集群基础组件，CoreDNS 等集群附加组件，以及 kubectl 命令等都必须要经过网关请求与集群通信。所有客户端均要经由 API Server 访问或改变集群状态以及完成数据存储，并且 API Server 会对每一次的访问请求进行合法检验，包括用户身份鉴别，操作权限验证以及操作是否符合全局规范的约束等。所有检查均正常完成且对象配置信息合法性检验无误后才能访问或存入数据到后端存储系统 ETCD 中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/60dc32565132923bf89d6d18.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>客户端认证操作由 API Server 配置的一到多个认证插件完成。收到请求后，API Server 依次调用配置的认证插件来校验客户端的身份，直到其中一个插件可以识别出请求者的身份为止。授权操作则由一到多个授权插件完成，这些插件负责确定通过认证的用户是否有权限执行发出的资源请求，该类操作包括创建、读取、删除或修改指定的对象等。随后通过授权检测的用户请求修改相关的操作还要经由一到多个准入控制插件的遍历式检测，例如使用默认值补足要创建的目标资源对象中未定义的各个字段、检查目标 Namespace 资源对象是否存在、检查请求创建的 Pod 对象是否违反系统资源限制等，其中的任何检查失败都可能导致写入操作失败。</p><h3 id="用户账号与用户组"><a href="#用户账号与用户组" class="headerlink" title="用户账号与用户组"></a>用户账号与用户组</h3><p>Kubernetes 系统上的用户账号及用户组的实现机制与常规应用略有不同。Kubernetes 集群将那些通过命令行工具 kubectl 、客户端库或者直接使用 RESTful 接口向 API Server 发起请求的客户端上的请求主体分为两个不同的类别：现实中的“人”和 Pod 对象，它们的用户身份分别对应用户账号（User Account，也称普通用户）和服务账号（Service Account，简称 SA）。</p><p>用户账户：其使用主体往往是“人”，一般由外部的用户管理系统存储和管理，Kubernetes 本身不维护这一类的任何用户账户信息，他们不会存储到 API Server 之上，仅仅用于检验用户是否有权限执行其所请求的操作。</p><p>服务账号：其使用主体是“应用程序”，专用于为 Pod 资源中的服务进程提供访问 Kubernetes API 时的身份标识（identity），Service Account 资源通常要绑定到特定的名称空间，它们由 API Server 自动创建或通过 API 调用，由管理员手动创建，通常附带着一组访问 API Server 的认证凭据 —— Secret，可由同一名称空间的 Pod 应用访问 API Server 时使用。</p><p>用户账号通常是用于复杂的业务逻辑管控，作用于系统全局，因而名称必须全局唯一。Kubernetes 并不会存储由认证插件从客户端请求中提取的用户及所属的组信息，因而也就没有办法对普通用户进行身份认证，他们仅仅用于检验该操作主体是否有权限执行其所请求的操作。相比较来说，服务账号则隶属于名称空间级别，仅用于实现某些特定操作任务，因此功能上要轻量得多。这两类账号都可以隶属于一个或多个用户组。</p><p>对 API Server 来说，来自客户端的请求要么与用户账户进行绑定，要么以某个服务账户的身份进行，否则会被视为匿名请求。这意味着集群内部或外部的每个进程，包括由人类用户使用 kubectl，以及各节点上运行的 kubelet 进程，再到控制平面的成员组件，必须在向 API Server 发出请求时进行身份验证。</p><h3 id="认证、授权、准入控制基础"><a href="#认证、授权、准入控制基础" class="headerlink" title="认证、授权、准入控制基础"></a>认证、授权、准入控制基础</h3><p>Kubernetes 使用身份验证插件对 API Server 请求进行身份验证，它允许管理员自定义服务账号和用户账号要启用或禁用的插件，并支持各自同时启用多种认证机制。具体设定时，至少应该为服务账号和用户账号各自启用一个认证插件。</p><p>如果启用了多种认证机制，账号认证过程由认证插件以串行的方式进行，直到其中一种认证机制成功完成即结束。若认证失败，服务器则返回 401 状态码，反之，请求者就会被 Kubernetes 识别为某个具体的用户（以其用户名进行标识），并且该连接上随后的操作都会以此用户身份进行。API Server 对于接收到的每个访问请求会调用认证插件，尝试将以下属性与访问请求相关联。</p><ul><li>用户名：用户名，例如 Kubernetes-admin 等。</li><li>用户 ID：用户的数字标签符，用于确保用户身份的唯一性。</li><li>用户组：用户所属的组，用于权限指派和继承， 常见的值可能是 <code>system:masters</code> 或者 <code>devops-team</code> 等。</li><li>附加字段：键值数据类型的字符串，用于提供认证需要用到的额外信息。</li></ul><p>API Server 支持以下几种具体的认证方式，其中所有的令牌认证机制通常被统称为“承载令牌认证”。</p><p>X509 客户证书认证：通过给 API 服务器传递 <code>--client-ca-file=SOMEFILE</code> 选项，就可以启动客户端证书身份认证。 所引用的文件必须包含一个或者多个证书机构，用来验证向 API 服务器提供的客户端证书。 如果提供了客户端证书并且证书被验证通过，则 subject 中的公共名称（Common Name）就被作为请求的用户名。</p><p>静态令牌文件认证：当 API 服务器的命令行设置了 <code>--token-auth-file=SOMEFILE</code> 选项时，会从文件中读取持有者令牌。目前，令牌会长期有效，并且在不重启 API 服务器的情况下无法更改令牌列表。</p><p>启动引导令牌认证：一种动态管理承载令牌进行身份认证的方式，常用于简化组建新 Kubernetes 集群时将节点加入集群的认证过程，需要由 Kube-apiserver 通过 –enable-bootstrap-token-auth 选项启用，新的工作节点首次加入时，Master 使用引导令牌确认节点身份的合法性之后自动为其签署数字证书以用于后续的安全通信，kubeadm 初始化的集群也是这种认证方式。</p><p>Server Account 令牌：该认证方式会由 kube-apiserver 程序自动启用，它同样使用签名的承载令牌来验证请求，该认证方式还支持通过可选项 –service-account-key-file 加载签署承载令牌的秘钥文件，未指定时将使用 API Server 自己的 TLS 私钥，Server Account 通常由 API Server 自动创建，并通过 Server Account 准入控制器将其注入 Pod 对象，包括 Server Account 上的承载令牌，容器中的应用程序请求 API Server 的服务时以此完成身份认证。 </p><p>那些未能被任何验证插件明确拒绝的请求中的用户即为匿名用户，该类用户会被冠以 system：anonymous 用户名，隶属于 system：unauthenticated 用户组。若 API Server 启用了除 Always Allow 以外的认证机制，则匿名用户处于启用状态，但是，处于安全因素考虑，建议管理员通过 –anonymous-auth=false 选项将其禁用。</p><p>除了身份信息，请求报文还需要提供操作方法及其目标对象，例如针对某 Pod 资源对象进行的创建、查看、修改或者删除操作等。具体包含以下信息。</p><ul><li>API：用于定义请求的目标是否为一个 API 资源。</li><li>Request path：请求的非资源路径，例如 /api 或 /healthz。</li><li>API group：要访问的 API 组，仅对资源型请求有效，默认为 core API group。</li><li>Namespace：目标资源的名称空间，仅对于隶属于名称空间类型的资源有效。</li><li>API request verb：API 请求类的操作，即资源请求，包括 get、list、create、update、patch、watch、delete 等。</li><li>HTTP request verb：HTTP 请求类的操作，即非资源类请求要执行的操作，如 get、post、put、delete 等。</li><li>Resource：请求的目标资源的 ID 或名称。</li><li>Subersource：请求的子资源。</li></ul><p>为了核验用户的操作许可，成功通过身份认证后的操作请求还需要转交给授权插件进行许可权限检查，以确保其拥有相应操作的许可。API Server 只要支持使用 4 类内置的授权插件来定义用户的操作权限。</p><ul><li>Node：基于 Pod 资源的目标调度节点来实现对 kubelet 的访问控制。</li><li>ABAC：Attribute-based access control，基于属性的访问控制。</li><li>RBAC：Role-based access control，基于角色的访问控制。</li><li>Webhook：基于 HTTP 回调机制实现外部 REST 服务检查，确认用户授权的访问控制。</li></ul><p>另外，还有 AlwaysDeny 和 AlwaysAllow 两个特殊的授权插件，其中 AlwaysDeny（总是拒绝）仅用于测试，而 AlwaysAllow（总是允许），则用于不期望进行授权检查时直接在授权检查阶段放行所有的操作请求。–authorization-mode 选项用于定义 API Server 要启用的授权机制，多个选项值彼此间以逗号进行分隔。</p><p>而准入控制器则用于在客户端请求经过身份验证和授权检查之后，将对象持久化存储到 etcd 之前拦截请求，从而实现在资源的创建，更新和删除操作期间强制执行对象的语义验证等功能，而读取资源信息的操作请求则不会经由准入控制器检查。API Server 内置了许多准入控制器，常用的包含下面列出的几种。</p><ul><li>AlwaysAdmin 和 AlwaysDeny：前者允许所有请求，后者则拒绝所有请求。（已废弃，仅了解）</li><li>AlwaysPullmages：总是下载镜像，即每次创建 Pod 对象之前都要去下载镜像。</li><li>NamespaceLifecycle：拒绝在不存在的名称空间中创建资源，而删除名称空间则会级联删除其下的所有其他资源。</li><li>LimitRanger：可用资源范围界定，用于对设置了 LimitRange 的对象所发出的所有请求进行监控，以确保其资源请求不会超限。</li><li>ServiceAccount：用于实现服务账号管控机制的自动化，实现创建 Pod 对象时自动为其附加相关的 Service Account 对象。</li><li>DefaultStorageClass：监控所有创建 PVC 对象的请求，以保证那些没有附加任何专用 StorageClass 的请求会被自动设定一个默认值。</li><li>ResourceQuota：用于为名称空间设置可用资源上限，并确保当其中创建的任何设置了资源限额的对象时，不会超出名称空间的资源配额。       </li></ul><p>早期的准入控制器代码需要由管理员编译进 kube-apiserver 中才能使用，实现方式缺乏灵活性。于是 Kubernetes 自 v1.7 版本引入了 Initializers 和 External Admin Webhooks 来尝试突破此限制，而且 v1.9 版本起，External Admin Webhooks 被分为 Mutating-Admission Webhooks 和 ValidatingAdmission Webhooks 两种类型，分别用于在 API 中执行对象配置的变异和验证操作。检查期间，仅那些顺利通过所有准入控制器检查的资源操作请求的结果才能保存到 etcd 中，而任何一个准入控制器的拒绝都将导致写入请求失败。</p><h2 id="ServiceAccount-及认证"><a href="#ServiceAccount-及认证" class="headerlink" title="ServiceAccount 及认证"></a>ServiceAccount 及认证</h2><p> Kubernetes 原生的应用程序意味着专为运行于 Kubernetes 系统之上而开发的应用程序，这些程序托管运行在 Kubernetes 之上，能够直接与 API Server 进行交互，并进行资源状态的查询或更新，例如 Flannel 和 CoreDNS 等。显然，API Server 同样需要对来自 Pod 资源中的客户端程序进行身份验证，服务账号也是专用于这类场景的账号。ServiceAccount 资源一般由用户身份信息及保存了认证信息的 Secret 对象组成。</p><h3 id="ServiceAccount-自动化"><a href="#ServiceAccount-自动化" class="headerlink" title="ServiceAccount 自动化"></a>ServiceAccount 自动化</h3><p>我们创建的每个 Pod 资源都自动关联了一个 Secret 存储卷，并由其容器挂载至 /var/run/secret/kubernetes.io/serviceaccount 目录。各容器的挂载点目录通常存在 3 个文件：ca.crt、namespace 和 token，其中，token 文件保存了 ServiceAccount 的认证令牌，容器中的进程使用该账户认证到 API Server ，进而由认证插件完成用户认证并将其用户名传递给授权插件。</p><p>每个 Pod 对象只有一个服务账号，若创建 Pod 资源时未予以明确指定，则 ServiceAccount 准入控制器会为其自动附加当前名称空间中默认的服务账号，其名称通常为 default。  </p><p>Kubernetes 系统通过 3 个独立的组件相互协作实现了上面描述的 Pod 对象服务账号的自动化过程：ServiceAccount 准入控制器、令牌控制器和 ServiceAccount 控制器。ServiceAccount 控制器负责为名称空间管理相应的资源对象，它需要确保每个名称空间中都存在一个名为 default 的服务账号对象。ServiceAccount 准入控制器内置在 API Server 中，负责在创建或更新 Pod 时按需进行 ServiceAccount 资源对象相关信息的修改，这包括如下操作。</p><ul><li>若 Pod 没有显式定义使用的 ServiceAccount 对象，则将其设置为 default。</li><li>若 Pod 显式引用了 ServiceAccount，则负责检查被引用的对象是否存在，不存在时将拒绝 Pod 资源的创建请求。</li><li>若 Pod 中不包含 ImagePullSecret，则把 ServiceAccount 的 ImagePullSecret 附加其上。</li><li>为带有访问 API 的令牌的 Pod 对象添加一个存储卷。</li><li>为 Pod 对象中的每个容器添加一个 volumeMount，将 ServiceAccount 的存储卷挂载至 /var/run/secret/kubernetes.io/serviceaccount。</li></ul><p>令牌控制器是控制平面组件 Controller Manager 中的一个专用控制器，它工作于异步模式，负责完成如下任务。</p><ul><li>监控 ServiceAccount 的创建操作，并为其添加用于访问 API 的 Secret 对象。</li><li>监控 ServiceAccount 的删除操作，并删除其相关的所有 ServiceAccount 令牌秘钥。</li><li>监控 Secret 对象的添加操作，确保其引用的 ServiceAccount 存在，并在必要时为 Secret 对象添加认证令牌。</li><li>监控 Secret 对象的删除操作，以确保删除每个 ServiceAccount 对此 Secret 的引用。</li></ul><h3 id="ServiceAccount-基础应用"><a href="#ServiceAccount-基础应用" class="headerlink" title="ServiceAccount 基础应用"></a>ServiceAccount 基础应用</h3><p>ServiceAccount 是 Kubernetes API 上的一种资源类型，它属于名称空间级别，用于让 Pod 对象内部的应用程序在与 API Server 通信时完成身份认证。</p><p>命令式 ServiceAccount 资源创建：</p><p>kubectl create serviceaccount 命令能够快速创建自定义的 ServiceAccount 资源，我们仅需要在命令后给出目标 ServiceAccount 资源的名称。</p><pre class="line-numbers language-shell"><code class="language-shell">[root@k8s-master ~]# kubectl create serviceaccount my-service-accountserviceaccount/my-service-account created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Kubernetes 会为创建的 ServiceAccount 资源自动生成并附加一个 Secret 对象，该对象以 ServiceAccount 资源名称为前缀。该 Secret 对象属于特殊的 kubernetes.io/service-account-token 类型，它包含 ca.crt、namespace 和 secret 这 3 个数据项，它们分别是 Kubernetes Root CA 证书、Secret 对象所在名称空间和访问 API Server 的令牌。</p><p>ServiceAccount 资源清单：</p><p>更完善的创建 ServiceAccount 资源的方式是使用资源规范，该规范比较简单，它没有 spec 字段，仅指定了资源名称，以及允许 Pod 对象将其自动挂载为存储卷，引用的 Secret 对象则由系统自动生成。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccout<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> sa<span class="token punctuation">-</span>demo  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">automountServiceAccountToken</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 是否让Pod自动挂载API令牌</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="kubeconfig-配置文件"><a href="#kubeconfig-配置文件" class="headerlink" title="kubeconfig 配置文件"></a>kubeconfig 配置文件</h2><p>基于无状态协议 HTTP/HTTPS 的 API Server 需要验证每次连接请求中的用户身份，因而 kube-controller-manager、kube-scheduler 和 kube-proxy 等各类客户端组件必须能自动完成身份认证信息的提交，但通过程序选项来提供这些信息会导致敏感信息泄露。另外，管理员还面临着使用 kubectl 工具接入不同集群时的认证及认证信息映射难题。为此，Kubernetes 设计了一种称为 kubeconfig 的配置文件，它保存有接入一到多个 Kubernetes 集群的相关配置信息，并允许管理员按需在各配置间灵活切换。</p><pre class="line-numbers language-shell"><code class="language-shell">                              kubernetes cluster1 API Serverkubectl ---> kubeconfig --->  kubernetes cluster2 API Server                              kubernetes cluster3 API Server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>客户端程序可以通过默认路径、–kubeconfig 选项或者 KUBECONFIG 环境变量自定义要加载的 kubeconfig 文件，从而能够在每次的访问请求中可认证到目标 API Server。</p><h3 id="kubeconfig-文件格式"><a href="#kubeconfig-文件格式" class="headerlink" title="kubeconfig 文件格式"></a>kubeconfig 文件格式</h3><p>kubeconfig 文件中，各集群的接入端点以列表形式定义在 clusters 配置段中，每个列表项代表一个 Kubernetes 集群，并拥有名称识别；各身份认证信息定义在 users 配置段中，每个列表项代表一个能够认证到某 Kubernetes 集群的凭据。将身份凭据与集群分开定义以便复用，具体使用时还要以 context（上下文）在二者之间按需建立映射关系，各 context 以列表形式定义在 context 配置段中，而当前使用的映射关系则定义在 current-context 配置段中。 </p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">clusters</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">cluster</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes  <span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">users</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin  <span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">contexts</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">context</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin@kubernetes  <span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">current-context</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin@kubernetes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 kubeadm 初始化 Kubernetes 集群过程中，在 Master 节点上生成的 /etc/kubernetes/admin.conf 文件就是一个 kubeconfig 格式的文件，它由 kubeadm init 命令自动生成，可由 kubectl 加载后接入当前集群的 API Server。kubeconfig 文件的默认加载路径为 $HOME/.kube/config，在 kubeadm init 命令初始化集群过程中有一个步骤便是将 /etc/kubenetes/admin.conf 复制为该默认搜索路径上的文件。当然也可以通过 –kubeconfig 选项或 KUBECONFIG 环境变量将其修改为其他路径。</p><p>kubectl config view 命令能打印 kubeconfig 文件的内容，下面的命令结果显示了默认路径下的文件配置，包括集群列表、用户列表、上下文列表以及当前使用的上下文等。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl config view</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Config<span class="token key atrule">preferences</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token key atrule">clusters</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">cluster</span><span class="token punctuation">:</span>    <span class="token key atrule">certificate-authority-data</span><span class="token punctuation">:</span> DATA+OMITTED    <span class="token key atrule">server</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//10.10.110.190<span class="token punctuation">:</span><span class="token number">6443</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token key atrule">users</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin  <span class="token key atrule">user</span><span class="token punctuation">:</span>    <span class="token key atrule">client-certificate-data</span><span class="token punctuation">:</span> REDACTED    <span class="token key atrule">client-key-data</span><span class="token punctuation">:</span> REDACTED<span class="token key atrule">contexts</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">context</span><span class="token punctuation">:</span>    <span class="token key atrule">cluster</span><span class="token punctuation">:</span> kubernetes    <span class="token key atrule">user</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin  <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin@kubernetes<span class="token key atrule">current-context</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>admin@kubernetes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户可以在 kubeconfig 配置文件中按需自定义相关的配置信息，以实现使用不同的用户账号接入集群等功能。kubeconfig 是一个文本文件，尽管可以使用文本处理工具直接编辑，但强烈建议用户使用 kubectl config 及其子命令进行该文件的设定，以便利用其它自动进行语法检测等额外功能。kubectl config 的常用子命令有如下几项。</p><ul><li>view：打印 kubeconfig 文件内容。</li><li>set-cluster：设定新的集群信息，以单独的列表项保存于 cluster 配置段。</li><li>set-credentials：设置认证凭据，保存为 users 配置段的一个列表项。</li><li>set-context：设置新的上下文信息，保存为 context 配置段的一个列表项。</li><li>use-context：设定 current-context 配置段，确定当前以哪个用户的身份接入到哪个集群当中。</li><li>delete-cluster：删除 cluster 中指定的列表项。</li><li>delete-context：删除 context 中指定的列表项。</li><li>get-cluster：获取 cluster 中定义的集群列表。</li><li>get-context：获取 context 中定义的上下文列表。<a href="https://www.vcbank.app/change" target="_blank" rel="noopener">https://www.vcbank.app/change</a></li></ul><h3 id="自定义-kubeconfig-文件"><a href="#自定义-kubeconfig-文件" class="headerlink" title="自定义 kubeconfig 文件"></a>自定义 kubeconfig 文件</h3><p>通常，一个完整 kubeconfig 配置文件的定义至少应该包括集群、身份凭证、上下文以及当前上下文 4 项，但在保存有集群身份和身份凭据的现有 kubeconfig 文件基础上添加新的上下文时，可能只需要提供身份凭据而复用现有的集群定义，具体操作步骤需要按实际情况判定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;此文档仅为个人的学习笔记，记录下来是为了以后遗忘时可以翻阅。最好的 Kubernetes 文档在 &lt;a href=
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.missf.top/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://www.missf.top/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 18.04 系统初始化</title>
    <link href="https://www.missf.top/post/23473589.html"/>
    <id>https://www.missf.top/post/23473589.html</id>
    <published>2021-03-02T05:26:52.000Z</published>
    <updated>2021-07-26T10:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-18-04-系统初始化"><a href="#Ubuntu-18-04-系统初始化" class="headerlink" title="Ubuntu 18.04 系统初始化"></a>Ubuntu 18.04 系统初始化</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Author: Created by MoWenJie</span><span class="token comment" spellcheck="true">#Function: Ubuntu 18.04 Server System initialization</span>kernel_optimize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">cat</span> <span class="token operator">></span>/etc/sysctl.conf<span class="token operator">&lt;&lt;</span><span class="token string">EOFfs.file-max = 10000000fs.nr_open = 10000000net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 204800net.ipv4.tcp_max_tw_buckets = 204800net.ipv4.tcp_max_orphans = 204800net.core.netdev_max_backlog = 204800net.core.somaxconn = 65000 vm.swappiness = 0net.ipv4.ip_nonlocal_bind = 1net.ipv6.ip_nonlocal_bind = 1net.unix.max_dgram_qlen = 128net.ipv4.ip_forward = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-arptables = 0net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.all.accept_source_route = 0net.ipv4.conf.default.accept_source_route = 0net.ipv4.neigh.default.gc_thresh1 = 512net.ipv4.neigh.default.gc_thresh2 = 28672net.ipv4.neigh.default.gc_thresh3 = 32768net.ipv6.neigh.default.gc_thresh1 = 512net.ipv6.neigh.default.gc_thresh2 = 28672net.ipv6.neigh.default.gc_thresh3 = 32768EOF</span>sysctl --system<span class="token punctuation">}</span>limits_process<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">cat</span> <span class="token operator">></span>/etc/security/limits.d/sys_init.conf<span class="token operator">&lt;&lt;</span><span class="token string">EOF*       soft    nproc   2000000*       hard    nproc   2000000*       soft    nofile  2000000*       hard    nofile  2000000root    soft    nproc   2000000root    hard    nproc   2000000root    soft    nofile  2000000root    hard    nofile  2000000EOF</span><span class="token function">ulimit</span> -HSn 2000000<span class="token punctuation">}</span>time_sync<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">crontab</span> -l <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ntpdate"</span> <span class="token operator">></span> /dev/null    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token keyword">echo</span>  <span class="token string">"Time sync already exists"</span>    <span class="token keyword">else</span>        timedatectl set-local-rtc 1        timedatectl set-timezone Asia/Shanghai        <span class="token keyword">echo</span> <span class="token string">"*/5 *  *  *  * /usr/sbin/ntpdate ntp.aliyun.com &amp;>/dev/null"</span> <span class="token operator">|</span> <span class="token function">crontab</span>        <span class="token keyword">echo</span> <span class="token string">"Time sync Configuration successful"</span>    <span class="token keyword">fi</span><span class="token punctuation">}</span>sshd_permitrootlogin<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">grep</span> <span class="token string">"#PermitRootLogin prohibit-password"</span> /etc/ssh/sshd_config    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token function">sed</span> -i <span class="token string">'s!#PermitRootLogin prohibit-password!PermitRootLogin yes!g'</span> /etc/ssh/sshd_config     <span class="token keyword">else</span>        <span class="token keyword">echo</span> <span class="token string">"root Remote Login open"</span>    <span class="token keyword">fi</span><span class="token punctuation">}</span>install_soft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>apt update <span class="token operator">&amp;&amp;</span> apt upgradeapt <span class="token function">install</span> -y tcpdump bash-completion tcptraceroute <span class="token function">bc</span> <span class="token function">git</span> gcc <span class="token function">make</span> net-tools <span class="token function">mtr</span> <span class="token function">traceroute</span> psmisc tcptrack nload ntpdate vim <span class="token function">lsof</span> tree    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">!=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token keyword">echo</span> <span class="token string">"Apt installation error"</span>    <span class="token keyword">fi</span>apt clean <span class="token operator">&amp;&amp;</span> apt autoremove<span class="token punctuation">}</span>command_line<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">'PS1="\[\e[0m\][\[\e[32;40m\]\u\[\e[33;40m\]@\[\e[34;40m\]\h \[\e[36;40m\]\w\[\e[0m\]]\\$ "'</span> <span class="token operator">>></span> /root/.bashrc <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span><span class="token punctuation">}</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>kernel_optimizelimits_processtime_syncsshd_permitrootlogininstall_softcommand_line<span class="token punctuation">}</span>main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu-18-04-系统初始化&quot;&gt;&lt;a href=&quot;#Ubuntu-18-04-系统初始化&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 18.04 系统初始化&quot;&gt;&lt;/a&gt;Ubuntu 18.04 系统初始化&lt;/h1&gt;&lt;pre clas
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://www.missf.top/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://www.missf.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>TCP SOCKET 的 backlog 参数用途</title>
    <link href="https://www.missf.top/post/fe2ea6ca.html"/>
    <id>https://www.missf.top/post/fe2ea6ca.html</id>
    <published>2021-01-25T02:17:28.000Z</published>
    <updated>2021-03-12T08:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># tcp三次握手</span>tcp标志位有6种标示: SYN<span class="token punctuation">(</span>synchronous建立联机<span class="token punctuation">)</span> ACK<span class="token punctuation">(</span>acknowledgement确认<span class="token punctuation">)</span> PSH<span class="token punctuation">(</span>push传送<span class="token punctuation">)</span> FIN<span class="token punctuation">(</span>finish结束<span class="token punctuation">)</span> RST<span class="token punctuation">(</span>reset重置<span class="token punctuation">)</span> URG<span class="token punctuation">(</span>urgent紧急<span class="token punctuation">)</span>Sequence number<span class="token punctuation">(</span>顺序号码<span class="token punctuation">)</span> Acknowledge number<span class="token punctuation">(</span>确认号码<span class="token punctuation">)</span>第一次握手: client ---------------<span class="token operator">></span> server    <span class="token comment" spellcheck="true"># client发送后状态为:SYN_SEND server接受后状态为:SYN_RCVD server收到请求后会将这个请求放到syns queue队列中</span>client发送位码为 <span class="token punctuation">[</span>SYN＝1,seq number<span class="token operator">=</span> x<span class="token punctuation">(</span>随机产生<span class="token punctuation">)</span><span class="token punctuation">]</span> 的数据包到server,server由SYN<span class="token operator">=</span>1得知client要求建立联机第二次握手: server ---------------<span class="token operator">></span> client    <span class="token comment" spellcheck="true"># client收到SYN+ACK将状态改为:ESTABLISHED(半连接状态)</span>server收到client建立联机的请求后,向client发送<span class="token punctuation">[</span>ack number<span class="token operator">=</span>x + 1<span class="token punctuation">(</span>client的seq number+1<span class="token punctuation">)</span>,SYN<span class="token operator">=</span>1,ACK<span class="token operator">=</span>1,seq number<span class="token operator">=</span> y<span class="token punctuation">(</span>随机产生<span class="token punctuation">)</span><span class="token punctuation">]</span>的数据包第三次握手: client ---------------<span class="token operator">></span> server    <span class="token comment" spellcheck="true"># server收到ACK将状态修改为:ESTABLISHED 并把该请求从syns queue队列放到accept queue队列</span>client收到数据包后检查ack number是否正确<span class="token punctuation">(</span>即client第一次发送的seq number+1<span class="token punctuation">)</span>,以及位码是否为ACK<span class="token operator">=</span>1,如果正确,client会发送 <span class="token punctuation">[</span>ack number<span class="token operator">=</span>y+1<span class="token punctuation">(</span>server的seq number+1<span class="token punctuation">)</span>,ACK<span class="token operator">=</span>1<span class="token punctuation">]</span>数据包给server,server接受之后确认ack number<span class="token operator">=</span>y+1值与ACK<span class="token operator">=</span>1,连接建立成功<span class="token comment" spellcheck="true"># syns queue队列: 用于保存半连接状态的请求</span>队列大小通过/proc/sys/net/ipv4/tcp_max_syn_backlog指定,著名的SYN洪水攻击就是建立大量的半连接状态请求,然后丢弃,导致syns queue不能保存正常的请求,注意半连接队列长度不能超过全连接队列长度<span class="token comment" spellcheck="true"># accept queue队列: 用于保存全连接状态的请求</span>队列大小通过/proc/sys/net/core/somaxconn指定,net.core.somaxconn 定义了系统级别的全连接队列最大长度,backlog 只是应用层传入的参数,不可能超过内核参数,所以 backlog 必须小于等于 net.core.somaxconn<span class="token comment" spellcheck="true"># backlog 的定义是已连接但未进行 accept 处理的 SOCKET 队列大小</span>backlog 是底层方法 int listen 的一个参数,Nginx/Tomcat 等这种 Web 服务器,都提供了 backlog 参数设置入口只增大应用层 backlog 参数大小是没有意义的,因为可能内核参数关于连接队列设置的都很小,必须综合应用层和内核参数一起调整systemnet.core.somaxconn <span class="token operator">=</span> 65535 <span class="token comment" spellcheck="true"># 默认为128,定义系统中每一个端口最大的监听队列长度</span>net.core.netdev_max_backlog <span class="token operator">=</span> 65535 <span class="token comment" spellcheck="true"># 默认为1000,请求被切换到CPU处理前被网卡缓存的速率包,根据网卡文档加大值可以提高性能</span>net.ipv4.tcp_max_syn_backlog <span class="token operator">=</span> 65535 <span class="token comment" spellcheck="true"># 默认为1024,对于还未获得对方确认的连接请求,可保存在syns queue队列中的最大数目</span>前端 Nginx/Tomcatlisten 80 backlog<span class="token operator">=</span>65535<span class="token punctuation">;</span> 后台 PHPlisten.backlog <span class="token operator">=</span> 65535<span class="token comment" spellcheck="true"># 这里还有一个需要注意的点</span>如果机器的性能不高,我们依然增大 backlog 参数和内核连接队列,反而会适得其反假设 PHP-fpm 的 QPS<span class="token punctuation">(</span>每秒响应次数<span class="token punctuation">)</span> 是 5000,那么处理完 65535 个请求大概需要 13 秒但是前端 Nginx 和 PHP-fpm 的连接已经等待超时,当 PHP-fpm 处理完最后一个请求,再往这个 SOCKET ID 写数据时,却发现连接已经关闭,得到的是<span class="token string">"error: Broken Pipe"</span>这也是为什么 2013 年 12 月 14 日发布的 PHP5.5.6 中 backlog 参数被修改为 65535,后来在 2014 年 7 月 22 日又修改为了 511<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; class=&quot;headerlink&quot; title=&quot;小记&quot;&gt;&lt;/a&gt;小记&lt;/h1&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span
      
    
    </summary>
    
    
      <category term="Backlog" scheme="https://www.missf.top/categories/Backlog/"/>
    
    
      <category term="Backlog" scheme="https://www.missf.top/tags/Backlog/"/>
    
      <category term="高并发" scheme="https://www.missf.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Vim 学习笔记</title>
    <link href="https://www.missf.top/post/bc97b757.html"/>
    <id>https://www.missf.top/post/bc97b757.html</id>
    <published>2021-01-20T05:47:57.000Z</published>
    <updated>2021-08-23T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习缘由"><a href="#学习缘由" class="headerlink" title="学习缘由"></a>学习缘由</h1><p>我也想成为使用 vim 写 python 代码的人，我觉得这样非常酷</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>vim 源于 vi 但不是 vi，vi 作为计算机的文本编辑器历史极为悠远，它是由美国计算机科学家比尔·乔伊编写并于 1976 年发布的。vim 诞生得要晚一些，它的第一个版本由布莱姆·米勒在 1991 年发布，这个兄弟也是一位声名显赫的程序员，80 年代买了一台 Amiga 电脑，打开电脑一看，居然没有他最常用的 vi 编辑器，对于米勒来说这是不可接受的。愤怒的米勒决定自己开发一个文本编辑器，完全复制 vi 的功能，并起名为 vi IMitation(模拟)。随着 vim 的不断发展，更多更好的功能被加了进来，正式名称改成了 vi IMproved(增强)，也就形成了现代的 vim，vim 的开发语言是 C 和 VimScript，目前最新的稳定版本是 8.2</p><h1 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h1><p>vim 是一款完全面向程序员的软件，几乎没有使用 vim 编辑文字的普通用户，这可能是因为 vim 的学习曲线陡峭导致的。但是一旦熟练使用 vim 之后，就可以不依赖鼠标，双手尽可能停留在键盘中央的区域，这样使得我们编码、 插入、移动、定位、查找都不需要产生停顿和间隙，极大的提高了我们工作的效率</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Red Hat 和 CentOS 系统默认的 vim 版本是 7.4，我们使用编译安装可以升级到最新版本</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 现在 vim 最新版本是 8.2</span>yum -y remove vim<span class="token function">wget</span> -O vim-8.2.2377.tar.gz https://github.com/vim/vim/archive/v8.2.2377.tar.gz<span class="token function">tar</span> xf vim-8.2.2377.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> vim-8.2.2377./configure --prefix<span class="token operator">=</span>/usr/local/vim/ --enable-pythoninterp<span class="token operator">=</span>yes --with-python-config-dir<span class="token operator">=</span>/usr/lib64/python2.7/config<span class="token function">make</span> -j4 <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">ln</span> -s /usr/local/vim/bin/vim /usr/bin/vim<span class="token function">ln</span> -s /usr/local/vim/bin/vimdiff /usr/bin/vimdiff<span class="token comment" spellcheck="true"># 如果 ./configure 过程中遇到</span>no terminal library foundchecking <span class="token keyword">for</span> tgetent<span class="token punctuation">(</span><span class="token punctuation">)</span>… configure: error: NOT FOUND<span class="token operator">!</span>      You need to <span class="token function">install</span> a terminal library<span class="token punctuation">;</span> <span class="token keyword">for</span> example ncurses.      Or specify the name of the library with –with-tlib.<span class="token comment" spellcheck="true"># Ubuntu 解决方法</span><span class="token function">sudo</span> apt <span class="token function">install</span> libncurses5-dev<span class="token comment" spellcheck="true"># CentOS 解决方法</span>yum <span class="token function">install</span> ncurses-devel.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>打开文件</p><pre class="line-numbers language-bash"><code class="language-bash">vim filename<span class="token comment" spellcheck="true"># 如果文件名称存在,就直接打开文件</span><span class="token comment" spellcheck="true"># 如果文件名称不存在,vim 会在退出保存时自动创建文件</span><span class="token comment" spellcheck="true"># vim 命令后没有跟任何文件名称时,无法实现 ":wq" 退出保存的,需要用 ":wq filename" 定义文件名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>退出文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">":q"</span>    <span class="token comment" spellcheck="true"># 退出</span><span class="token string">":q!"</span>    <span class="token comment" spellcheck="true"># 强制不保存退出</span><span class="token string">":w"</span>    <span class="token comment" spellcheck="true"># 保存编辑后的内容(将内存缓冲区的数据写到文件中)</span><span class="token string">":w!"</span>    <span class="token comment" spellcheck="true"># 强制保存编辑后的内容</span><span class="token string">":wq"</span>    <span class="token comment" spellcheck="true"># 保存并退出</span><span class="token string">":wq!"</span>    <span class="token comment" spellcheck="true"># 强制保存并退出</span><span class="token string">":x"</span>    <span class="token comment" spellcheck="true"># 保存并退出</span><span class="token comment" spellcheck="true"># ":x" 和 ":wq" 的区别在于:</span><span class="token string">":wq"</span> 强制性写入文件并退出,即使文件没有被修改也强制写入并更新文件的修改时间<span class="token string">":x"</span> 仅当文件被修改时才写入并更新文件修改时间,否则不会更新文件修改时间<span class="token comment" spellcheck="true"># ":x" 和 ":wq" 在一般情况下没有什么区别,但是进行编程时,如果修改的是源代码文件,即使文件内容没有被修改,但是文件修改时间更新了,在重新编译项目时就得重新编译,产生不必要的系统资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于更多的 vim 基本使用会在后面一一讲解</p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>vim 设计得最特别的地方就是它的模式，与其他大部分编辑器不同，进入 vim 后默认是正常模式，此时键入的字符并不会被插入到所编辑的文件之中。vim 的模式(mode)，是它的麻烦所在，但同时也是它的厉害所在，vim 有四种主要的模式。正常模式(normal 也称普通模式)，如果不加特殊的说明，一般提到的命令都直接在正常模式下输入，在其他的任何模式中，都可以通过 Esc 键返回到正常模式。插入模式(insert)，输入字符时使用，例如在正常模式下键入 i (insert) 或者 a (append) 即可进入插入模式。按 v 进入可视模式(visual)，用于选定文本块，vim 里还提供其他不同的选定方法，包括按行和按列块。命令行模式(command-line)，用于执行较长、较复杂的命令、在正常模式下键入冒号 : 即可进入该模式，使用斜杠 / 和问号 ? 开始搜索也算作命令行模式，命令行模式的命令需要输入回车键才会执行</p><h1 id="配置和选项"><a href="#配置和选项" class="headerlink" title="配置和选项"></a>配置和选项</h1><p>vim 是有配置文件的，我们可以根据使用习惯，配置属于自己的 vim。vim 的配置文件有三个路径，我们可以敲 vim –version 就能看到三行信息，配置文件是存在优先级的。一开始的配置文件是一个很简单的，甚至是一个空文件，随着我们的深入学习和使用，配置文件会变得越来越复杂</p><pre class="line-numbers language-bash"><code class="language-bash">system vimrc file: <span class="token string">"/etc/vimrc"</span>        <span class="token comment" spellcheck="true"># 系统配置</span>     user vimrc file: <span class="token string">"<span class="token variable">$HOME</span>/.vimrc"</span>    <span class="token comment" spellcheck="true"># 用户配置</span> 2nd user vimrc file: <span class="token string">"~/.vim/vimrc"</span>    <span class="token comment" spellcheck="true"># 第二用户配置</span><span class="token comment" spellcheck="true"># 优先级</span>三个文件只要存在一个,vim 就能正常运行如果有用户配置,第二用户配置就无法生效相同的配置项,用户配置会覆盖系统配置系统配置里有而用户配置里没有的配置项,以系统配置为准<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="鼠标支持"><a href="#鼠标支持" class="headerlink" title="鼠标支持"></a>鼠标支持</h1><p>在 vim 里也可以使用鼠标，我们可以设置鼠标在 vim 的那个模式下生效。启用鼠标支持之后在不同的终端使用场景下，也有一定的区别，如果使用 xterm 兼容终端，在多窗口编辑的情况下可以使用鼠标进行窗口切换和拖拽窗口大小，如果使用 linux 兼容终端，那么鼠标支持是不生效的</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 鼠标模式</span>n 普通模式<span class="token function">v</span> 可视模式i 插入模式c 命令行模式h 在帮助文件里a 以上所有模式<span class="token comment" spellcheck="true"># 启用鼠标支持</span><span class="token keyword">set</span> mouse<span class="token operator">=</span>a<span class="token comment" spellcheck="true"># 关闭鼠标支持</span><span class="token keyword">set</span> mouse-<span class="token operator">=</span>a<span class="token comment" spellcheck="true"># 判断终端类型启用鼠标支持模式</span><span class="token keyword">if</span> has<span class="token punctuation">(</span><span class="token string">'mouse'</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> has<span class="token punctuation">(</span><span class="token string">'gui_running'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>term <span class="token operator">=</span>~ <span class="token string">'xterm'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>has<span class="token punctuation">(</span><span class="token string">'mac'</span><span class="token punctuation">))</span>    <span class="token keyword">set</span> mouse<span class="token operator">=</span>a  <span class="token keyword">else</span>    <span class="token keyword">set</span> mouse<span class="token operator">=</span>nvi  endifendif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="备份和撤销文件"><a href="#备份和撤销文件" class="headerlink" title="备份和撤销文件"></a>备份和撤销文件</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">set</span> backup    <span class="token comment" spellcheck="true"># 对一个文件修改之后生成对应的备份文件</span><span class="token keyword">set</span> undofile    <span class="token comment" spellcheck="true"># 对一个文件修改之后生成对应的撤销文件</span><span class="token keyword">set</span> undodir<span class="token operator">=</span>~/.vim/undodir    <span class="token comment" spellcheck="true"># 指定撤销文件的存放目录</span><span class="token keyword">set</span> backupdir<span class="token operator">=</span>~/.vim/backupdir    <span class="token comment" spellcheck="true"># 指定备份文件的存放目录</span><span class="token comment" spellcheck="true"># 如果没有此目录则自动创建目录</span><span class="token keyword">if</span> <span class="token operator">!</span>isdirectory<span class="token punctuation">(</span><span class="token operator">&amp;</span>undodir<span class="token punctuation">)</span>  call mkdir<span class="token punctuation">(</span><span class="token operator">&amp;</span>undodir, <span class="token string">'p'</span>, 0700<span class="token punctuation">)</span>endif<span class="token keyword">if</span> <span class="token operator">!</span>isdirectory<span class="token punctuation">(</span><span class="token operator">&amp;</span>backupdir<span class="token punctuation">)</span>  call mkdir<span class="token punctuation">(</span><span class="token operator">&amp;</span>backupdir, <span class="token string">'p'</span>, 0700<span class="token punctuation">)</span>endif<span class="token keyword">set</span> enc<span class="token operator">=</span>utf-8    <span class="token comment" spellcheck="true"># enc 是显示文件时的编码(fenc 是当前文件编码,fencs 是打开文件时进行解码的)</span><span class="token keyword">set</span> nocompatible    <span class="token comment" spellcheck="true"># 设置 vim 不需要和 vi 兼容</span><span class="token keyword">set</span> backspace<span class="token operator">=</span>indent,eol,start    <span class="token comment" spellcheck="true"># backspace 键的工作模式,indent:允许删除自动缩进的空格 eol:能够将一行删除完后合并到上一行 start:删除此次进入插入模式前的输入</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><p>vim 里的基本光标移动是通过 h、j、k、l 四个键来实现的，之所以使用这四个键，是有历史原因的，当时的 vi 开发者的键盘上还没有我们现在独立的光标键，四个光标的符号直接标注在 h、j、k、l 四个字母按键上。因此，即使今天所有的键盘都有了光标移动键，很多资深的 vim 用户仍然使用这四个键来移动光标</p><p>vim 跳转到行首的命令是 0，跳转到行尾的命令是 $，还有使用 ^ 跳转到行首的第一个非空白字符</p><p>对于一次移动超过一个字符的情况，vim 支持使用 b/w 和 B/W，来进行以单词为单位的跳转，用来向后或向前跳转一个单词。大写个小写命令的区别在于，小写命令跟编程语言里的标识符规则相似，认为一个单词是由字母、数字、下划线组成的，而大写的命令则认为非空字符都是单词</p><p>根据单个字符来进行光标移动，分别是 f(find) 和 t(till)，fa 是移动光标到下一个 a 字符，ta 是移动光标到下一个字符 a 的前一个字符，大写的 F/T 代表反向</p><p>对于使用 vim 去阅读一些文档的时候，使用 ( 和 ) 分别是移动光标到上一句和下一句，使用 { 和 } 分别是移动光标到上一段和下一段</p><p>很多环境里，vim 支持使用 &lt;Home&gt; 和 &lt;End&gt; 跳转到文件的开头行和结尾行，如果不行，还可以使用 vi 兼容的 gg 和 G 跳转到开头行和结尾行(G 是跳转到结尾行的第一个字符)</p><pre class="line-numbers language-bash"><code class="language-bash">h:左j:下k:上l:右0:跳转到行首$:跳转到行尾^:跳转到行首的第一个非空白字符b/B:光标移至光标当前所在单词的词首,如果光标已经在单词的词首,则会跳至前一个单词的词首e/E:光标移至光标当前所在单词的词尾,如果光标已经在单词的词尾,则会跳至后一个单词的词尾w/W:向前跳转一个单词或字符串,光标停留在单词词首A:光标移至行尾并进入编辑模式I:光标移至行首并进入编辑模式fa:移动光标到当前行下一个 a 字符2fa:移动光标到当前行第二个 a 字符ta:移动光标到当前行下一个字符 a 的前一个字符2ta:移动光标到当前行第二个字符 a 的前一个字符F/T:代表反向<span class="token punctuation">(</span>:移动光标到上一句<span class="token punctuation">)</span>:移动光标到下一句<span class="token punctuation">{</span>:移动光标到上一段<span class="token punctuation">}</span>:移动光标到下一段%:匹配括号移动光标,包括 <span class="token punctuation">(</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>,需要将光标先移动到括号上<span class="token punctuation">(</span>编辑 Nginx 的配置文件时非常方便<span class="token punctuation">)</span>*/<span class="token comment" spellcheck="true">#:匹配光标当前所在的单词的下一个和上一个</span>gg:移动光标到首行的第一个字符G:移动光标到尾行的第一个字符:n/ngg/nG:指定光标跳转到 n 行<span class="token operator">&lt;</span>PageUp<span class="token operator">></span>:向上翻页<span class="token operator">&lt;</span>PageDown<span class="token operator">></span>:向下翻页n<span class="token operator">|</span>:n代表数字,移动到指定的列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h1><p>在 vim 的一般原则里，常用的功能，按键应尽可能少，因此很多相近的功能在 vim 里会有不同的按键，不仅如此，大写键也一般会重载一个相近但稍稍不同的含义</p><pre class="line-numbers language-bash"><code class="language-bash">dd:删除整行d0:光标位置<span class="token punctuation">(</span>不包含<span class="token punctuation">)</span>删除到行首的所有字符d$/D:光标位置<span class="token punctuation">(</span>包含<span class="token punctuation">)</span>删除到行尾的所有字符db:删除光标当前位置<span class="token punctuation">(</span>不包含<span class="token punctuation">)</span>到单词起始处的所有字符de:删除光标当前位置<span class="token punctuation">(</span>包含<span class="token punctuation">)</span>到单词结尾处的所有字符dw:删除光标当前位置<span class="token punctuation">(</span>包含<span class="token punctuation">)</span>到下个单词起始处的所有字符cc/S:删除整行并进入插入模式c$/C:光标位置删除到行尾并进入插入模式s/cl:删除一个字符并进入插入模式i:在当前光标字符前面进入插入模式I:光标移动到行首非空白字符并进入插入模式a:在当前光标字符后面进入插入模式<span class="token variable">$a</span>/A:光标移动到行尾并进入插入模式o:在当前行的下方插入新行并进入插入模式O:在当前行的上方插入新行并进入插入模式ra:光标下的字符替换为aR:进入替换模式,每次按键替换一个字符<span class="token punctuation">(</span>直到按下<span class="token operator">&lt;</span>Esc<span class="token operator">></span><span class="token punctuation">)</span>u:撤销上一个修改动作<span class="token punctuation">(</span>可多次撤销<span class="token punctuation">)</span>U:撤销当前行上的所有修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h1><p>如果想要在 vim 里拥有高效编辑的能力， 必然要掌握超过单个字符编辑的能力，也就是说，要掌握词(word)、句子(sentense)、段落(paragraph)级别的编辑能力。在 Vim 里，这样以一定标准分隔符界定的概念叫做文本对象(text objects)。文本对象是一个很强大的功能，无论光标处于该文本对象的哪个字符中，我们都可以对整个文本对象进行操作，这也是为什么 vim 是世界上最快的编辑器的原因</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 文本对象常用的编辑命令</span>y:复制d:删除c:替换v:选中<span class="token comment" spellcheck="true"># 文本对象有以下几种(标签用 t 表示)</span>w s p <span class="token string">''</span> <span class="token string">""</span> <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span>tag<span class="token operator">></span><span class="token comment" spellcheck="true"># 文本对象的操作范围有两种</span>i:是inner的意思,操作时不包括单词边上的空格符或包围符号a:是arround的意思,操作时包括单词边上的空格符或包围符号<span class="token comment" spellcheck="true"># 文本对象操作列子</span>操作文本对象:<span class="token operator">&lt;</span>h1<span class="token operator">></span>Sample Title<span class="token operator">&lt;</span>/h1<span class="token operator">></span>,光标在Sample单词的S上dw:<span class="token operator">&lt;</span>h1<span class="token operator">></span>Title<span class="token operator">&lt;</span>/h1<span class="token operator">></span>diw:<span class="token operator">&lt;</span>h1<span class="token operator">></span> Title<span class="token operator">&lt;</span>/h1<span class="token operator">></span>daw:<span class="token operator">&lt;</span>h1<span class="token operator">></span>Title<span class="token operator">&lt;</span>/h1<span class="token operator">></span>dit:<span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token operator">&lt;</span>/h1<span class="token operator">></span> <span class="token punctuation">(</span>t代表的是<span class="token operator">&lt;</span>tag<span class="token operator">></span>文本对象<span class="token punctuation">)</span>dat:Empty    <span class="token punctuation">(</span>这里因为文本对象的操作范围是a,所有连同包围符号也一并删除<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 操作文本对象:cdmuwfon.rg("stwq jkntrc," + "opac liixisq"),光标在stwq单词的s上(对于成对的标签符号操作时,光标可以在标签内的任何位置)</span>di<span class="token string">":cdmuwfon.rg("</span><span class="token string">" + "</span>opac liixisq<span class="token string">")da"</span>:cdmuwfon.rg<span class="token punctuation">(</span>+ <span class="token string">"opac liixisq"</span><span class="token punctuation">)</span>di<span class="token punctuation">(</span>:cdmuwfon.rg<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># (和)都可以</span>da<span class="token punctuation">(</span>:cdmuwfon.rgci<span class="token string">":cdmuwfon.rg("</span><span class="token string">" + "</span>opac liixisq<span class="token string">")  # 并且进入了插入模式ca"</span>:cdmuwfon.rg<span class="token punctuation">(</span>+ <span class="token string">"opac liixisq"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 并且进入了插入模式</span>ci<span class="token punctuation">(</span>:cdmuwfon.rg<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 并且进入了插入模式,这在编程中非常方便</span>ca<span class="token punctuation">(</span>:cdmuwfon.rg  <span class="token comment" spellcheck="true"># 并且进入了插入模式</span>vi<span class="token punctuation">(</span>:进入视图模式并且选中<span class="token string">"stwq jkntrc,"</span> + <span class="token string">"opac liixisq"</span>  <span class="token comment" spellcheck="true"># 可以按d进行删除</span>va<span class="token punctuation">(</span>:进入视图模式并且选中<span class="token punctuation">(</span><span class="token string">"stwq jkntrc,"</span> + <span class="token string">"opac liixisq"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的文本对象操作可以使用如下的示例进行各种各样的组合，让复杂的操作只需要几个简单的组合键就能完成，极大的提高了我们的工作效率</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>y:复制 d:删除 c:替换 v:选中<span class="token punctuation">]</span> <span class="token punctuation">[</span>i和a 文本对象的操作范围<span class="token punctuation">]</span> <span class="token punctuation">[</span>w s p <span class="token string">''</span> <span class="token string">""</span> <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span>tag<span class="token operator">></span> 文本对象<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="重复操作"><a href="#重复操作" class="headerlink" title="重复操作"></a>重复操作</h1><p>vim 里有非常多的命令组合，如果我们需要重复这样的命令，每次都要手敲一遍，这显示不是一件容易的事情。其实 vim 已经想到了这个问题，提前定义好了一些简单的重复键</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">;</span>:重复最近的字符查找操作<span class="token punctuation">(</span>f t<span class="token punctuation">)</span>,:反向n:重复最近的字符查找操作<span class="token punctuation">(</span>/ ?<span class="token punctuation">)</span>N:反向.:重复执行最近的修改操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>vim 的工作环境是由运行支持文件来设定的，如果想要定制 vim ，就需要知道 vim 的目录结构</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以 vim8.2 为例,标准的安装位置分别在</span>Unix:/usr/share/vim/vim82<span class="token punctuation">(</span>如果是编译安装则取决于你的安装目录<span class="token punctuation">)</span>Windows:C:\Program Files<span class="token punctuation">(</span>x86<span class="token punctuation">)</span>\Vim\vim82<span class="token comment" spellcheck="true"># 这个目录下面还有很多子目录,这些子目录下面就是分类放置的 vim 支持文件</span>syntax:vim的语法加亮文件doc:vim的帮助文件colors:vim的配色方案plugin:vim的<span class="token string">"插件"</span>,即用来增强vim功能的工具<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以 syntax 目录为例，目录下有 628 个文件都是以 .vim 作为后缀，就代表 vim 对 628 不同的文件类型提供语法加亮支持，例如 java.vim 文件，就是对 java 类型的文件进行语法加亮，也可以用 :setfiletype java 这样的命令来设置文件的类型</p><p>plugin 目录下的系统内置插件不多</p><pre class="line-numbers language-bash"><code class="language-bash">getscriptPlugin:获得最新的vim脚本的插件<span class="token punctuation">(</span>现在都广泛使用Git<span class="token punctuation">)</span>gzip:编辑.gz压缩文件<span class="token punctuation">(</span>编辑后缀为.gz的文件时自动解压和压缩,用户感知不到这个文件是压缩的<span class="token punctuation">)</span>logiPat:模式匹配的逻辑运算符<span class="token punctuation">(</span>允许以逻辑运算,而非标准正则表达式的方式来写模式匹配表达式<span class="token punctuation">)</span>manpager:使用vim来查看man帮助<span class="token punctuation">(</span>强烈建议试一下,记得使用vim的跳转键 C-<span class="token punctuation">]</span> 和 C-T<span class="token punctuation">)</span>matchparen:对括号进行高亮匹配<span class="token punctuation">(</span>现代编辑器基本都有类似的功能<span class="token punctuation">)</span>netrwPlugin:从网络上编辑文件和浏览远程目录<span class="token punctuation">(</span>支持多种常见协议,如ftp和scp,可直接打开目录来选择文件<span class="token punctuation">)</span>rrhelper:用于支持 --remote-wait 编辑<span class="token punctuation">(</span>vim的多服务器会用到这一功能<span class="token punctuation">)</span>spellfile:在拼写文件缺失时自动下载<span class="token punctuation">(</span>vim一般只安装了英文的拼写文件<span class="token punctuation">)</span>tarPlugin:编辑压缩的tar文件<span class="token punctuation">(</span>tar 不支持写入<span class="token punctuation">)</span>tohtml:把语法加亮的结果转成HTML文件并保存vimballPlugin:创建和解开.vba文件<span class="token punctuation">(</span>过时<span class="token punctuation">)</span>zipPlugin:编辑zip文件<span class="token punctuation">(</span>zip 可支持写入<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 打开远程文件和浏览目录</span>format: protocol://<span class="token punctuation">[</span>user@<span class="token punctuation">]</span>hostname<span class="token punctuation">[</span>:port<span class="token punctuation">]</span>/<span class="token punctuation">[</span>path<span class="token punctuation">]</span>vim scp://root@k8s-node1/test    <span class="token comment" spellcheck="true"># 打开root用户家目录下的test文件</span>vim scp://root@k8s-node1//etc/docker/    <span class="token comment" spellcheck="true"># 使用远程终端的绝对路径,要使用双斜杠</span><span class="token comment" spellcheck="true"># 使用vim查看man帮助文档</span><span class="token function">export</span> MANPAGER<span class="token operator">=</span><span class="token string">"vim -M +MANPAGER -"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h1><p>vim 的插件严格来说应该叫包，我们安装一个插件，就是在 .vim 目录下解压插件包，基本上是安装之后就不管了，即使这个插件有更新，我们也不能及时的更新到最新的版本。现在 git 的流行，让我们对版本的控制变得简单，而在有了包管理器之后，配合 git 的版本控制，能够让我们非常方便的安装插件和更新插件，已经一系列对插件的管理操作</p><p>安装 minpac 包管理器并通过包管理器安装插件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装 minpac</span><span class="token function">git</span> clone https://github.com/k-takata/minpac.git ~/.vim/pack/minpac/opt/minpac<span class="token comment" spellcheck="true"># 初始化包管理器和指定需要安装的插件(写入到 vim 的配置文件)</span>function<span class="token operator">!</span> PackInit<span class="token punctuation">(</span><span class="token punctuation">)</span> abort  packadd minpac  call minpac<span class="token comment" spellcheck="true">#init()</span>  call minpac<span class="token comment" spellcheck="true">#add('k-takata/minpac', {'type': 'opt'})</span>  <span class="token string">" Additional plugins here.  call minpac#add('vim-jp/syntax-vim-ex')  call minpac#add('tyru/open-browser.vim')  call minpac#add('rkulla/pydiction')    # python 补全插件endfunction"</span> Plugin settings here.<span class="token string">" Define user commands for updating/cleaning the plugins."</span> Each of them calls PackInit<span class="token punctuation">(</span><span class="token punctuation">)</span> to load minpac and register" the information of plugins, <span class="token keyword">then</span> performs the task.command<span class="token operator">!</span> PackUpdate call PackInit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> call minpac<span class="token comment" spellcheck="true">#update()    # 自定义命令</span>command<span class="token operator">!</span> PackClean  call PackInit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> call minpac<span class="token comment" spellcheck="true">#clean()</span>command<span class="token operator">!</span> PackStatus packadd minpac <span class="token operator">|</span> call minpac<span class="token comment" spellcheck="true">#status()</span><span class="token comment" spellcheck="true"># 保存 .vimrc 文件,重启 vim 之后我们就有了三个自定义的命令(命令模式下)</span>PackUpdatePackCleanPackStatus<span class="token comment" spellcheck="true"># 安装插件</span>在 .vimrc 文件写入插件的 GitHub 项目的用户名/项目名,通过 :PackUpdate 命令更新插件插件格式为:call minpac<span class="token comment" spellcheck="true">#add('[package-author]/[package-name]')</span><span class="token comment" spellcheck="true"># 删除插件</span>同样需要编辑 .vimrc 文件,删除不需要的插件,通过 :PackClean 命令更新插件,插件就会被删除<span class="token comment" spellcheck="true"># 查看插件状态</span>:PackStatus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插件安装成功的界面</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/601539b33ffa7d37b3df3b31.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h1><p>一般而言，对于终端 vim 来说，它是没法分辨用户是输入操作还是粘贴操作的。因此在粘贴内容时，Vim 的很多功能，特别是智能缩进、制表符转换等功能(这些功能是用于输入操作的)，就会修改粘贴的内容，导致我们粘贴的内容显示的结果不对，或者出现乱码。要解决这个问题，我们就得让 vim 知道，我们的操作到底是输入操作还是粘贴操作，vim 有一个 paste 选项，就是用来切换输入和粘贴的状态的，如果现在处于 :set paste 状态，vim 就认为现在是粘贴操作，智能缩进、制表符转换等功能就不会修改粘贴的内容，不过每次都手动修改这个状态是非常麻烦的，下面有两个优化方法</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 方法一,通过自定义键来切换paste和nopaste的状态</span><span class="token keyword">set</span> pastetoggle<span class="token operator">=</span><span class="token operator">&lt;</span>F2<span class="token operator">></span>  <span class="token comment" spellcheck="true"># 在插入模式下,按&lt;F2>会切换paste状态</span>nnoremap <span class="token operator">&lt;</span>F2<span class="token operator">></span> :set invpaste paste?<span class="token operator">&lt;</span>CR<span class="token operator">></span>  <span class="token comment" spellcheck="true"># 在命令模式下,按&lt;F2>会切换paste状态</span>imap <span class="token operator">&lt;</span>F2<span class="token operator">></span> <span class="token operator">&lt;</span>C-O<span class="token operator">></span>:set invpaste paste?<span class="token operator">&lt;</span>CR<span class="token operator">></span>  <span class="token comment" spellcheck="true"># 以nopaste状态进入插入模式后,可以按一次&lt;F2>切换paste状态</span><span class="token comment" spellcheck="true"># 方法二,进入插入模式的时候自动开启paste,退出插入模式自动关闭paste</span><span class="token keyword">if</span> has<span class="token punctuation">(</span><span class="token string">'autocmd'</span><span class="token punctuation">)</span>  augroup vimrcExtension    autocmd<span class="token operator">!</span>    autocmd InsertEnter * <span class="token keyword">set</span> <span class="token function">paste</span>    autocmd InsertLeave * <span class="token keyword">set</span> nopaste    <span class="token keyword">if</span> <span class="token operator">!</span> has<span class="token punctuation">(</span><span class="token string">'gui_running'</span><span class="token punctuation">)</span>      <span class="token keyword">set</span> ttimeoutlen<span class="token operator">=</span>10      autocmd InsertEnter * <span class="token keyword">set</span> ttimeoutlen<span class="token operator">=</span>0      autocmd InsertEnter * <span class="token keyword">set</span> ttimeoutlen<span class="token operator">=</span>1000    endif  augroup endendif<span class="token comment" spellcheck="true"># 一直处于 paste 开启的状态下虽然不影响基本的功能,但是会影响其他插件的正常工作(例如 python 补全插件就无法使用了)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="交换文件"><a href="#交换文件" class="headerlink" title="交换文件"></a>交换文件</h1><p>对一个单独的文件使用多个 vim 会话进行编辑，很容易出现冲突的情况，所以使用 vim 时肯定会遇到过 Swap file “.filename.swp” already exists! 这个错误提示，出现这个错误提示有两种原因</p><ol><li>上次编辑这个文件时，发生了意外崩溃，导致文件没有存盘就退出了</li><li>有另一个会话正在使用 vim 编辑这个文件</li></ol><p>当错误提示的 process ID 后面没有 (still running) 的字样，就是第一种情况，否则就是第二种情况。第一种情况下，vim 支持即使没有存盘的情况下仍然保存编辑状态，我们可以按 r 键来恢复上次没有存盘的内容，在文件恢复之后，vim 仍然不会删除崩溃时保留下来的那个交换文件，因此我们恢复文件内容之后，确定内容无误就可以保存文件。重新打开文件，按 d 键可以删除交换文件，也可以单独使用 rm -f 删除交换文件(交换文件一般是 .filename.swp 的格式)。第二种情况下，是有另一个会话正在使用 vim 编辑这个文件，这时候是没有 delete 交换文件这一选项的，这时候一般选择 q 或者 a 放弃编辑，如果只是要查看文件，那也可以选择 o 以只读文件打开，需要用到 e 强行进行编辑的情况很少</p><pre class="line-numbers language-bash"><code class="language-bash">Swap <span class="token function">file</span> <span class="token string">".nginx.conf.swp"</span> already exists<span class="token operator">!</span><span class="token punctuation">[</span>O<span class="token punctuation">]</span>pen Read-Only, <span class="token punctuation">(</span>E<span class="token punctuation">)</span>dit anyway, <span class="token punctuation">(</span>R<span class="token punctuation">)</span>ecover, <span class="token punctuation">(</span>Q<span class="token punctuation">)</span>uit, <span class="token punctuation">(</span>A<span class="token punctuation">)</span>bort:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h1><p>vim 支持一次性打开多个文件，只需要在命令行上写出多个文件即可，还支持通配符的方式。例如我们可以使用 vim *.cpp 或者 vim *.yaml 去编辑多个文件，但是执行这个命令之后只会打开所有文件中的第一个文件，这是 vim 为了确保低配置环境也能正常工作而设计的，避免不必要的内存浪费，其实在执行上述命令的时候，vim 建立了一个文件列表，并且暂时只打开其中的第一个文件，接下来用户可以在不退出 vim 的情况下，查看文件列表，继续编辑下一个文件或者退出编辑</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">":args"</span> <span class="token comment" spellcheck="true"># 显示编辑的所有文件列表,其中[]括起来的文件是你正在编辑的文件</span><span class="token string">":args **/*.yaml/filename"</span> <span class="token comment" spellcheck="true"># 在进入 vim 之后,打开当前目录下的 *.yaml 文件和打开指定文件</span><span class="token string">":next/:n"</span> <span class="token comment" spellcheck="true"># 编辑下一个文件,如果当前文件未存盘则会报错,命令后面加!则会放弃修改内容,可以设置 vim 在切换文件时自动存盘:set autowrite</span><span class="token string">":Next/:previous"</span> <span class="token comment" spellcheck="true"># 打开上一个文件</span><span class="token string">":first/rewind"</span> <span class="token comment" spellcheck="true"># 回到文件列表的第一个文件</span><span class="token string">":last"</span> <span class="token comment" spellcheck="true"># 打开文件列表的最后一个文件</span><span class="token string">":n|normal ggp"</span> <span class="token comment" spellcheck="true"># 切换到下一个文件并在正常模式下执行 ggp 命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="缓冲区的管理和切换"><a href="#缓冲区的管理和切换" class="headerlink" title="缓冲区的管理和切换"></a>缓冲区的管理和切换</h1><p>vim 里会对每一个已打开或要打开的文件创建一个缓冲区，这个缓冲区就是文件在 vim 中的映射，它是 vim 里的一个基本概念。缓冲区(buffer)就是一块内存区域，里面存储着正在编辑的文件，如果没有把缓冲区里的文件存盘，那么原始文件不会被更改。在多文件编辑的时候你也会有同样数量的缓冲区，不过缓冲区的数量常常会比编辑多文件时的文件列表数更高，因为你用 :e/:o 等命令另外打开的文件不会改变命令行参数(就是不加入到 :args 的文件列表)，但同样会增加缓冲区的数量。 此外 :args 代表参数列表 / 文件列表，真的只是文件的列表而已。比起文件列表，缓冲区中有更多信息，最基本的就是记忆了光标的位置。在 vim 里，除了切换到下一个文件这样的批处理操作外，操作缓冲区的命令比简单操作文件的命令更为方便</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用通配符命令编辑多个文件</span>vim *.yaml<span class="token comment" spellcheck="true"># :args 查看文件列表</span><span class="token punctuation">[</span>deployment.yaml<span class="token punctuation">]</span> emptyDir.yaml     hostpath-vol.yaml ingress.yaml      nfs-vol.yaml      service.yaml<span class="token comment" spellcheck="true"># :ls/:files/:buffers 查看缓冲区列表</span>  1 %a   <span class="token string">"deployment.yaml"</span>              line 45  2      <span class="token string">"emptyDir.yaml"</span>                line 0  3      <span class="token string">"hostpath-vol.yaml"</span>            line 0  4      <span class="token string">"ingress.yaml"</span>                 line 0  5      <span class="token string">"nfs-vol.yaml"</span>                 line 0  6      <span class="token string">"service.yaml"</span>                 line 0Press ENTER or <span class="token function">type</span> <span class="token function">command</span> to <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，文件列表和缓冲区列表都展示了打开的所有文件，而且分别使用 [] 和 %a 标示了当前正在编辑的文件。不过缓存区列表比文件列表给出了更多的文件信息</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 缓冲区示例</span>1 %a   <span class="token string">"deployment.yaml"</span>              line 45<span class="token comment" spellcheck="true"># 参数意义</span>1:代表缓冲区列表文件的编号%a:缓冲区的状态<span class="token string">"deployment.yaml"</span>:文件名字line 45:光标所在的行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缓冲区状态</p><pre class="line-numbers language-bash"><code class="language-bash">%:当前缓冲区a:活动缓存区,当前显示在屏幕上的<span class="token comment" spellcheck="true">#:交换缓冲区(最近的缓冲区)</span><span class="token operator">=</span>:只读缓冲区+:已经更改的缓冲区-:非活动的缓冲区h:隐藏的缓冲区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开缓冲区</p><pre class="line-numbers language-bash"><code class="language-bash">:buffer number <span class="token comment" spellcheck="true"># 以缓冲区列表文件编号来打开缓冲区</span>:buffer filename <span class="token comment" spellcheck="true"># 以缓冲区列表文件名字来打开缓冲区</span>:sbuffer number/filename <span class="token comment" spellcheck="true"># 分割当前窗口开始编辑另一个缓冲区,如果没有指定 number/filename,则以当前缓冲区进行窗口分割</span>:ball <span class="token comment" spellcheck="true"># 为每一个缓冲区打开一个窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>切换缓冲区</p><pre class="line-numbers language-bash"><code class="language-bash">:bnext <span class="token comment" spellcheck="true"># 切换到下一个缓冲区</span>:bprevious/:bNext <span class="token comment" spellcheck="true"># 切换到上一个缓冲区</span>:blast <span class="token comment" spellcheck="true"># 切换到最后一个缓冲区</span>:bfirst <span class="token comment" spellcheck="true"># 切换到第一个缓冲区</span>:set hidden <span class="token comment" spellcheck="true"># 允许缓冲区在未保存的情况下进行切换(修改由vim进行保存)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除缓冲区</p><pre class="line-numbers language-bash"><code class="language-bash">:bdelete filename/3 <span class="token comment" spellcheck="true"># 根据文件名字或者编号来删除一个缓冲区</span>:1,3 bdelete <span class="token comment" spellcheck="true"># 根据指定范围来删除缓冲区</span>:bdelete<span class="token operator">!</span> filename <span class="token comment" spellcheck="true"># 强制删除缓冲区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>卸载缓冲区</p><pre class="line-numbers language-bash"><code class="language-bash">:bunload filename <span class="token comment" spellcheck="true"># 从内存中卸载一个缓冲区,这个缓冲区打开的所有窗口都会关闭,如果缓冲区被改动过,那么该命令将失败    </span>:bunload<span class="token operator">!</span> <span class="token comment" spellcheck="true"># 强制卸载缓冲区,但所有的改动也将会丢失</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="多窗口编辑"><a href="#多窗口编辑" class="headerlink" title="多窗口编辑"></a>多窗口编辑</h1><p>前面所讲的编辑多个文件，也只是在单个窗口进行的，这样的局限在于，我们既不能同时修改两个文件，也不能在同一窗口对比两个文件。我们想要自己同时查看、编辑多个文件，最基本的命令就是 :split (缩写 :sp)，这个命令后面如果有文件名，表示分割窗口并打开指定的文件，如果没有文件名，那就表示仅仅把当前窗口分割开，当前编辑的文件在两个窗口里都显示，:split 默认使用水平分割的方式。竖直分割的命令是 :vsplit (缩写 :vs)，竖直分割要求屏幕比较宽，但如果你想对比两个文件时，竖直分割就会更方便</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> s/:split/:sp <span class="token comment" spellcheck="true"># 水平分割当前窗口</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> v/:vsplit/:vs <span class="token comment" spellcheck="true"># 竖直分割当前窗口</span>:split/:sp filename <span class="token comment" spellcheck="true"># 水平分割窗口并打开指定的文件</span>:vsplit/:vs filename <span class="token comment" spellcheck="true"># 竖直分割窗口并打开指定的文件</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> <span class="token punctuation">(</span>h j k l 方向键<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 可以在多窗口之间跳转</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> w <span class="token comment" spellcheck="true"># 跳转到下一个(往右和往下跳)窗口,W反向</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> n/:new <span class="token comment" spellcheck="true"># 打开一个新窗口</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> c/:close <span class="token comment" spellcheck="true"># 关闭当前窗口,如果当前窗口已经是最后一个则无效</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> q/:quit <span class="token comment" spellcheck="true"># 退出当前窗口,当最后一个窗口退出时则退出 vim</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> o/:only <span class="token comment" spellcheck="true"># 只保留当前窗口,关闭其他所有窗口</span><span class="token operator">&lt;</span>Ctrl-w<span class="token operator">></span> <span class="token operator">=</span> <span class="token comment" spellcheck="true"># 使得所有窗口大小相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h1><p>多窗口编辑中有一个非常有用的功能，那就是比较两个文件的内容。vim 对此有特殊的支持，使用 vimdiff 或 gvimdiff 命令，后面跟上需要比较的两个文件，就能打开两个窗口比较两个文件了。在比较时，vim 会折叠相同的代码行，并加亮两边文本不同的部分，窗口的滚动也是联动的</p><pre class="line-numbers language-bash"><code class="language-bash">vimdiff emptyDir1.yaml emptyDir2.yaml <span class="token comment" spellcheck="true"># 比较两个文件的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比较文件的实际截图如下</p><p><img src="https://img.imgdb.cn/item/60337cf45f4313ce25aab2e2.jpg" alt=""></p><h1 id="NERDTree-插件"><a href="#NERDTree-插件" class="headerlink" title="NERDTree 插件"></a>NERDTree 插件</h1><p>NERDTree 是最为著名的一个文件浏览 / 管理插件，就是你知道文件大概在哪里，但不知道文件具体名字时的一个好选择。跟很多 vim 插件一 样，NERDTree 会利用多窗口的特性</p><p>安装 NERDTree 插件</p><pre class="line-numbers language-bash"><code class="language-bash">在vimrc的<span class="token string">"Other plugins"</span>下面加入以下语句call minpac<span class="token comment" spellcheck="true">#add('preservim/nerdtree')</span>执行:PackUpdate命令进行安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装成功之后，NERDTree 缺省就会抢占 netrw 使用的路径形式，我们在 vim 中可以使用 e . 来打开 NERDTree(. 代表当前路径) ，也可以在打开一个文件之后使用 :NERDTreeToggle 命令。在打开 NERDTree 窗口之后，使用还是相当直观的，并且按下 ? 就可以查看帮助信息</p><p>在文件或目录上敲回车或双击立即打开该文件或目录</p><p>在文件上使用 go 会预览该文件，也就是光标不会跳转到文件所在的窗口中</p><p>按 i 会打开文件到一个新的水平分割的窗口中，按 s 会打开文件到一个新的竖直分割的窗口中，按 t 会打开文件到一个新的标签页中</p><p>NERDTree 会自动过滤隐藏文件和目录，但如果你需要看到它们的话，也可以用 I 来开启和关闭隐藏文件的显示</p><p>按 m 会出现一个菜单，允许添加、删除、更名等操作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/60338c755f4313ce25b1dffc.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>通过前面的学习，可能你已经知道搜索命令 / 和替换命令 :s 的用法了。其实，我们输入的待查找内容是被 vim 当成正则表达式来看待的，这里我们来简单学习一下 vim 里的正则表达式，它跟其他常用的正则表达式还是有区别的。在一个搜索表达式里(或者称为模式 pattern)，. 、* 、^ 、$ 、~ 、[] 、\ 是有特殊含义的字符</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">.</span> 可以匹配除换行符外的任何字符: 如a.可以匹配<span class="token string">"aa"</span> <span class="token string">"ab"</span> <span class="token string">"ac"</span>等,但不能匹配<span class="token string">"a"</span> <span class="token string">"b"</span>或<span class="token string">"ba"</span>,如果需要匹配换行符<span class="token punctuation">(</span>跨行匹配<span class="token punctuation">)</span>的话,则需要使用\_.* 表示之前的匹配源<span class="token punctuation">(</span>最普通的情况为单个字符,匹配源可以是一个字符串,但需要该字符串需要组成一个项,如:\<span class="token punctuation">(</span>ab\<span class="token punctuation">)</span>*<span class="token punctuation">)</span>重复零次或多次: 如aa*可以匹配<span class="token string">"a"</span> <span class="token string">"aa"</span> <span class="token string">"aaa"</span>^ 匹配一行的开头,如果出现在模式的开头的话<span class="token punctuation">;</span>在其他位置代表字符本身$ 匹配一行的结尾,如果出现在模式的结尾的话<span class="token punctuation">;</span>在其他位置代表字符本身~ 匹配上一次替换的字符串,即如果上一次你把<span class="token string">"foo"</span>替换成了<span class="token string">"bar"</span>,那~就匹配<span class="token string">"bar"</span><span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span> 匹配方括号内的任一字符,方括号内如果第一个字符是^,表示对结果取反,除开头之外的-表示范围:如<span class="token punctuation">[</span>A-Za-z<span class="token punctuation">]</span>表示任意一个拉丁字母,<span class="token punctuation">[</span>^-+*/<span class="token punctuation">]</span> 表示除了<span class="token string">"-"</span> <span class="token string">"+"</span> <span class="token string">"*"</span> <span class="token string">"/"</span>外的任意字符\ 的含义取决于下一个字符,在大部分的情况下把某些含有特殊意义的字符进行转义,让它们代表字符本身<span class="token punctuation">(</span>. * \ ^ $ ~ <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外的字符都是普通字符，没有特殊含义。不过，需要注意的是，如果使用 / 开始一个搜索命令，或者在替换命令(:s)中使用 / 作为模式的分隔符，那模式中的 / 必须写作 / 才行，否则 Vim 看到 / 就会以为模式结束了，导致错误发生。为了方便书写，我们可以用其他的符号作为模式的分隔符，例如想把”/image/“全部替换成”/images/“的话，我们可以把 :%s//image///images//g 写成 :%s#/image/#/images/#g，这只能适用于替换命令，而在使用搜索命令 / 时我们就没有办法了，只能把模式里的 / 写作 /</p><p>通过 \ 开始的特殊表达式</p><pre class="line-numbers language-bash"><code class="language-bash">\? 表示之前的匹配源重复零次或一次:如 aa\? 可以匹配<span class="token string">"a"</span> <span class="token string">"aa"</span>但不能完整匹配<span class="token string">"aaa"</span><span class="token punctuation">(</span>可以匹配其前两个字符、后两个或最后一个字符<span class="token punctuation">)</span>\+ 表示之前的匹配源重复一次或多次:如 aa\+ 可以匹配<span class="token string">"aa"</span> <span class="token string">"aaa"</span>但不能匹配<span class="token string">"a"</span>或<span class="token string">"b"</span>\<span class="token punctuation">{</span>n,m<span class="token punctuation">}</span> 表示之前的匹配源重复 n 到 m 遍之间,两个数字可以省略部分或全部:如 a\<span class="token punctuation">{</span>3<span class="token punctuation">}</span><span class="token punctuation">(</span>可读作:3个<span class="token string">"a"</span><span class="token punctuation">)</span>可以匹配<span class="token string">"aaa"</span> a\<span class="token punctuation">{</span>,3<span class="token punctuation">}</span><span class="token punctuation">(</span>可读作:最多3个<span class="token string">"a"</span><span class="token punctuation">)</span>可以匹配<span class="token string">""</span> <span class="token string">"a"</span> <span class="token string">"aa"</span>和<span class="token string">"aaa"</span> 两个数字都省略时等价于* 也就是之前的匹配源可以重复零次或多次\<span class="token punctuation">(</span>和\<span class="token punctuation">)</span> 括起一个模式,将其组成为单个匹配源:如 \<span class="token punctuation">(</span>foo\<span class="token punctuation">)</span>\? 可以表示单词<span class="token string">"foo"</span>出现零次或一次 \<span class="token punctuation">(</span>和\<span class="token punctuation">)</span>还有一个附加作用,是捕获匹配的内容,按\<span class="token punctuation">(</span>出现的先后顺序,可以用 \1 \2到 \9来引用,如果你不需要捕获匹配内容的话,用\%<span class="token punctuation">(</span> 和 \<span class="token punctuation">)</span> 的性能更高\<span class="token operator">&amp;</span> 是分支内多个邻接<span class="token punctuation">(</span>concat<span class="token punctuation">)</span>的分隔符,概念上可以和与操作相比,表示每一项都需要匹配成功,然后取最后一项的结果返回:如 .*foo.*\<span class="token operator">&amp;</span>.*bar.* 匹配同时出现了<span class="token string">"foo"</span>和<span class="token string">"bar"</span>的完整行\<span class="token operator">|</span> 是多个分支的分隔符,概念上可以和或操作相比,表示任意一项匹配成功即可:如foo\<span class="token operator">|</span>bar 可匹配<span class="token string">"foo"</span>或<span class="token string">"bar"</span>两单词之一\<span class="token operator">&lt;</span> 匹配单词的开头\<span class="token operator">></span> 匹配单词的结尾\s 匹配空白字符 <span class="token operator">&lt;</span>Space<span class="token operator">></span> 和 <span class="token operator">&lt;</span>Tab<span class="token operator">></span>\S 匹配非空白字符\d 匹配数字,相当于 <span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>\D 匹配非数字,相当于 <span class="token punctuation">[</span>^0-9<span class="token punctuation">]</span>\x 匹配十六进制数字,相当于 <span class="token punctuation">[</span>0-9A-Fa-f<span class="token punctuation">]</span>\X 匹配非十六进制数字,相当于 <span class="token punctuation">[</span>^0-9A-Fa-f<span class="token punctuation">]</span>\w 匹配单词字符,相当于 <span class="token punctuation">[</span>0-9A-Za-z_<span class="token punctuation">]</span>\W 匹配非单词字符,相当于 <span class="token punctuation">[</span>^0-9A-Za-z_<span class="token punctuation">]</span>\h 匹配单词首字符,相当于 <span class="token punctuation">[</span>A-Za-z_<span class="token punctuation">]</span>\H 匹配非单词首字符,相当于 ^<span class="token punctuation">[</span>A-Za-z_<span class="token punctuation">]</span>\c 忽略大小写进行匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>抽象地讨论正则表达式恐怕你也不容易记住，还是拿一些具体的例子来练习一下吧</p><h1 id="搜索替换实例"><a href="#搜索替换实例" class="headerlink" title="搜索替换实例"></a>搜索替换实例</h1><p>搜索表达式</p><pre class="line-numbers language-bash"><code class="language-bash">/aae <span class="token comment" spellcheck="true"># 往后查找aae,没有使用界定符,会查找到aaes qaae等单词</span>/\<span class="token operator">&lt;</span>name\<span class="token operator">></span> <span class="token comment" spellcheck="true"># 搜索单词name,使用\&lt; \>进行界定单词的开头和结尾,这样的话names是搜索不到的</span>/\<span class="token operator">&lt;</span>\<span class="token punctuation">(</span>red\<span class="token operator">|</span>blue\<span class="token punctuation">)</span>\<span class="token operator">></span> <span class="token comment" spellcheck="true"># 搜索单词red或blue</span>?aae <span class="token comment" spellcheck="true"># 往前查找aae,没有使用界定符,会查找到aaes qaae等单词</span>* <span class="token comment" spellcheck="true"># 搜索光标下的单词(光标停留在name上,键入*会跳转到下一个name)</span>n <span class="token comment" spellcheck="true"># 光标跳转到后一个</span>N <span class="token comment" spellcheck="true"># 光标跳转到前一个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>替换表达式</p><pre class="line-numbers language-bash"><code class="language-bash">Example:<span class="token punctuation">[</span>range<span class="token punctuation">]</span>s/<span class="token punctuation">{</span>pattern<span class="token punctuation">}</span>/<span class="token punctuation">{</span>string<span class="token punctuation">}</span>/<span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># flags 有如下四个选项</span>c confirm 每次替换前询问e error 不显示错误g globle 不询问,整行替换,如果不加g选项,则只替换每行的第一个匹配到的字符串i ignore 忽略大小写这些选项可以合并使用,如cgi表示不区分大小写,整行替换,替换前询问<span class="token comment" spellcheck="true"># 替换例子</span>:s<span class="token operator">!</span>ma<span class="token operator">!</span>am<span class="token operator">!</span> <span class="token comment" spellcheck="true"># 把当前行的ma替换成am</span>:s<span class="token operator">!</span>ma<span class="token operator">!</span>am<span class="token operator">!</span>g <span class="token comment" spellcheck="true"># g标记表示替换行中的所有匹配点(不加g只会替换行中的一个匹配点)</span>:%s<span class="token operator">!</span>ma<span class="token operator">!</span>am<span class="token operator">!</span>g <span class="token comment" spellcheck="true"># 把全文的ma替换成am(1,$s!ma!am!g也是一样的效果)</span>:1,10s<span class="token operator">!</span>ma<span class="token operator">!</span>am<span class="token operator">!</span> <span class="token comment" spellcheck="true"># 表示把第1到第10行(包含1到10行)的ma替换成am</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除替换表达式</p><pre class="line-numbers language-bash"><code class="language-bash">:%s<span class="token operator">!</span>\s\+<span class="token variable">$!!g</span> <span class="token comment" spellcheck="true"># 删除全文行尾的空白字符(&lt;Space> 和 &lt;Tab>)</span>:%s<span class="token operator">!</span>^\s\+<span class="token operator">!</span><span class="token operator">!</span>g <span class="token comment" spellcheck="true"># 删除全文行首的空白字符(&lt;Space> 和 &lt;Tab>)</span>:g/^\s*$/d <span class="token comment" spellcheck="true"># 全局删除沒有內容的空行</span>:%s<span class="token operator">!</span>^\s*$\n<span class="token operator">!</span><span class="token operator">!</span>g <span class="token comment" spellcheck="true"># 把沒有內容的空行(空格 制表符 换行符)替换为空,等于删除空行的效果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件类型和关联设定"><a href="#文件类型和关联设定" class="headerlink" title="文件类型和关联设定"></a>文件类型和关联设定</h1><p>程序源代码通常由文件组成，每个文件都有一个关联的文件类型。这个文件类型决定了 vim 对其进行处理的一些基本设定，可能受影响的设定具体有以下方面</p><p>如何对文件进行高亮(不同的语言高亮不一样，例如 .c 和 .py 文件)</p><p>制表符 &lt;tab&gt; 的宽度(4个空格数或者8个空格)</p><p>是否在键入 &lt;tab&gt; 时扩展为空格字符</p><p>每次缩进的空格数(可以和制表符宽度不同)</p><p>采用何种自动缩进方法</p><p>其他可适用的选项</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启文件类型检测(写入vimrc配置文件)</span>filetype plugin indent on <span class="token comment" spellcheck="true"># filetype on</span>打开文件类型检测功能,它相当于文件类型检测功能的开关<span class="token comment" spellcheck="true"># filetype plugin on</span>允许vim加载文件类型插件,vim会根据检测到的文件类型,在runtimepath中搜索该类型的所有插件并执行<span class="token comment" spellcheck="true"># filetype indent on </span>允许vim为不同类型的文件定义不同的缩进格式<span class="token comment" spellcheck="true"># 查看文件类型检测是否开启</span>:filetype<span class="token comment" spellcheck="true"># 如果文件的类型未能被正确的检测出来,可以手动设置文件类型</span>:set filetype<span class="token operator">=</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="插入模式自动补全"><a href="#插入模式自动补全" class="headerlink" title="插入模式自动补全"></a>插入模式自动补全</h1><p>自动补全是一个编辑器中很主流的功能，编辑器能够在用户输入一部分内容时就能猜到用户希望输入的是什么，并能够予以提示。自动补全可以节约我们输入的工作量，非常值得我们去学习，vim 内置就有自动补全的功能，补全的对象如下</p><pre class="line-numbers language-bash"><code class="language-bash">整行补全 CTRL-X CTRL-L根据当前文件里关键字补全 CTRL-N/CTRL-P根据字典补全 CTRL-X CTRL-K根据同义词字典补全 CTRL-X CTRL-T根据头文件内关键字补全 CTRL-X CTRL-I根据标签补全 CTRL-X CTRL-<span class="token punctuation">]</span>补全文件名或路径 CTRL-X CTRL-F补全宏定义 CTRL-X CTRL-D补全vim命令 CTRL-X CTRL-V用户自定义补全方式 CTRL-X CTRL-U拼写建议 CTRL-X CTRL-S停止补全并且不应用匹配项 CTRL-E在补全菜单应用对象且离开补全模式 CTRL-Y/<span class="token operator">&lt;</span>Enter<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CTRL-N 和 CTRL-P 分别是对当前文件里的关键字进行补全(往下查找和往上查找)，其他补全都需要先进入 CTRL-X 模式，再键入对应的命令进入对应的补全模式。使用 CTRL-N 和 CTRL-P 上下移动时，输入的文本也会随之变化。使用 &lt;Up&gt; 和 &lt;Down&gt; 上下移动时，输入的文字并不会变化。使用 &lt;PageUp&gt; 和 &lt;PageDown&gt; 键，可以在补全菜单中翻页。使用 Esc 键，将关闭弹出菜单，但会保留之前应用的对象。也就是说，如果你不希望应用任何对象完成补全时，应该使用 CTRL-E 键，而不是使用 Esc 键来取消补全操作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/603c67ca5f4313ce252d81e4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>补全文件名字或者路径(基于文件系统)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.imgdb.cn/item/603c68635f4313ce252e318f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Python-开发环境"><a href="#Python-开发环境" class="headerlink" title="Python 开发环境"></a>Python 开发环境</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习缘由&quot;&gt;&lt;a href=&quot;#学习缘由&quot; class=&quot;headerlink&quot; title=&quot;学习缘由&quot;&gt;&lt;/a&gt;学习缘由&lt;/h1&gt;&lt;p&gt;我也想成为使用 vim 写 python 代码的人，我觉得这样非常酷&lt;/p&gt;
&lt;h1 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历
      
    
    </summary>
    
    
      <category term="Vim" scheme="https://www.missf.top/categories/Vim/"/>
    
    
      <category term="Vim" scheme="https://www.missf.top/tags/Vim/"/>
    
      <category term="编辑器" scheme="https://www.missf.top/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Wrk 性能测试工具</title>
    <link href="https://www.missf.top/post/bcbad8d3.html"/>
    <id>https://www.missf.top/post/bcbad8d3.html</id>
    <published>2021-01-04T02:58:13.000Z</published>
    <updated>2021-01-20T05:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wrk-简介"><a href="#wrk-简介" class="headerlink" title="wrk 简介"></a>wrk 简介</h1><p>wrk 是一款针对 HTTP 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。wrk 是复用了 redis 的 ae 异步事件驱动框架，准确来说 ae 事件驱动框架并不是 redis 发明的，它来自于 Tcl 的解释器 jim，这个小巧高效的框架，因为被 redis 采用而被大家所熟知</p><h1 id="wrk-安装"><a href="#wrk-安装" class="headerlink" title="wrk 安装"></a>wrk 安装</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Ubuntu/Debian</span><span class="token function">apt-get</span> <span class="token function">install</span> build-essential libssl-dev <span class="token function">git</span> -y<span class="token function">git</span> clone https://github.com/wg/wrk.git wrk<span class="token function">cd</span> wrk <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> -j4<span class="token function">cp</span> wrk /usr/local/bin<span class="token comment" spellcheck="true"># CentOS/RedHat</span>yum groupinstall <span class="token string">'Development Tools'</span>yum <span class="token function">install</span> -y openssl-devel <span class="token function">git</span><span class="token function">git</span> clone https://github.com/wg/wrk.git wrk<span class="token function">cd</span> wrk <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> -j4<span class="token function">cp</span> wrk /usr/local/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证安装是否成功</p><pre class="line-numbers language-bash"><code class="language-bash">wrk -v    <span class="token comment" spellcheck="true"># 查看版本</span>wrk  <span class="token punctuation">[</span>epoll<span class="token punctuation">]</span> Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> 2012 Will GlozerUsage: wrk <span class="token operator">&lt;</span>options<span class="token operator">></span> <span class="token operator">&lt;</span>url<span class="token operator">></span>                              Options:                                                -c, --connections <span class="token operator">&lt;</span>N<span class="token operator">></span>  Connections to keep <span class="token function">open</span> 跟服务器建立并保持的TCP连接数量    -d, --duration    <span class="token operator">&lt;</span>T<span class="token operator">></span>  Duration of <span class="token function">test</span> 压测时间               -t, --threads     <span class="token operator">&lt;</span>N<span class="token operator">></span>  Number of threads to use 使用多少个线程进行压测       -s, --script      <span class="token operator">&lt;</span>S<span class="token operator">></span>  Load Lua script <span class="token function">file</span> 指定Lua脚本路径           -H, --header      <span class="token operator">&lt;</span>H<span class="token operator">></span>  Add header to request 为每一个HTTP请求添加HTTP头              --latency          Print latency statistics 在压测结束后打印延迟统计信息           --timeout     <span class="token operator">&lt;</span>T<span class="token operator">></span>  Socket/request <span class="token function">timeout</span> 超时时间         -v, --version          Print version details 打印wrk的详细版本信息        Numeric arguments may include a SI unit <span class="token punctuation">(</span>1k, 1M, 1G<span class="token punctuation">)</span> 代表数字参数支持国际单位  Time arguments may include a <span class="token function">time</span> unit <span class="token punctuation">(</span>2s, 2m, 2h<span class="token punctuation">)</span> 代表时间参数支持时间单位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于线程数：并不是设置得越大，压测效果越好，线程设置过大，反而会导致线程切换过于频繁，效果降低，一般来说，推荐设置成压测机器 CPU 核心数的 2 倍到 4 倍</p><h1 id="wrk-测试"><a href="#wrk-测试" class="headerlink" title="wrk 测试"></a>wrk 测试</h1><pre class="line-numbers language-bash"><code class="language-bash">wrk -t2 -c10 -d20s --latency http://10.244.169.184Running 20s <span class="token function">test</span> @ http://10.244.169.184  2 threads and 10 connections  Thread Stats   Avg<span class="token punctuation">(</span>平均值<span class="token punctuation">)</span>      Stdev<span class="token punctuation">(</span>标准差<span class="token punctuation">)</span>     Max<span class="token punctuation">(</span>最大值<span class="token punctuation">)</span>   +/- Stdev<span class="token punctuation">(</span>正负一个标准差所占比例<span class="token punctuation">)</span>    Latency<span class="token punctuation">(</span>延迟<span class="token punctuation">)</span>     7.08ms    9.11ms  85.30ms   88.17%    Req/Sec<span class="token punctuation">(</span>每秒请求数<span class="token punctuation">)</span>     1.08k   524.84     2.34k    59.13%  Latency Distribution <span class="token punctuation">(</span>延迟分布<span class="token punctuation">)</span>     50%    3.34ms<span class="token punctuation">(</span>50%的请求在3.34ms效应<span class="token punctuation">)</span>     75%    7.07ms     90%   18.22ms     99%   45.30ms  42574 requests <span class="token keyword">in</span> 20.10s, 34.51MB <span class="token function">read</span>Requests/sec:   2117.96<span class="token punctuation">(</span>QPS 即平均每秒处理请求数为 2117.96<span class="token punctuation">)</span>Transfer/sec:   1.72MB<span class="token punctuation">(</span>平均每秒流量<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这仅仅是一个 get 请求的测试。如果想进行 POST 请求，或者每一次请求的参数都不一样，用来模拟用户使用的实际场景，可以使用 Lua 脚本来进行一系列更复杂的测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wrk-简介&quot;&gt;&lt;a href=&quot;#wrk-简介&quot; class=&quot;headerlink&quot; title=&quot;wrk 简介&quot;&gt;&lt;/a&gt;wrk 简介&lt;/h1&gt;&lt;p&gt;wrk 是一款针对 HTTP 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 
      
    
    </summary>
    
    
      <category term="性能测试" scheme="https://www.missf.top/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="性能测试" scheme="https://www.missf.top/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Wrk" scheme="https://www.missf.top/tags/Wrk/"/>
    
  </entry>
  
  <entry>
    <title>Kubeadm 快速搭建 k8s 集群</title>
    <link href="https://www.missf.top/post/50806d3a.html"/>
    <id>https://www.missf.top/post/50806d3a.html</id>
    <published>2020-11-20T07:47:02.000Z</published>
    <updated>2021-03-18T02:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubeadm-简介"><a href="#Kubeadm-简介" class="headerlink" title="Kubeadm 简介"></a>Kubeadm 简介</h1><p>kubeadm 是一个提供了 kubeadm init 和 kubeadm join 的工具，作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践</p><p>kubeadm 通过执行必要的操作来启动和运行最小可用集群。按照设计，它只关注启动引导，而非配置机器。同样的，安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard，监控方案，以及特定云平台的扩展，都不在讨论范围内</p><p>k8s 官方社区推出 Kubeadm 工具的原因，就是为了让 kubernetes 集群的部署变得快速简单</p><h1 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h1><p>一台或多台机器，操作系统(CentOS 7、Ubuntu 16.04+、Red Hat Enterprise Linux (RHEL) 7 等)</p><p>每台机器 2 GB 或更多的 RAM</p><p>2 核 CPU 或更多</p><p>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</p><p>节点之中不可以有重复的主机名、MAC 地址或 product_uuid</p><p>禁用 swap 分区</p><h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>节点规划</p><pre class="line-numbers language-bash"><code class="language-bash">k8s-master 10.10.110.190k8s-ndoe1 10.10.110.191k8s-node2 10.10.110.192<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>架构图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5fb8cee7b18d6271134d01e7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>配置节点</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 关闭防火墙</span>systemctl stop firewalld.servicesystemctl disable firewalld.service<span class="token comment" spellcheck="true"># 关闭seliinux</span><span class="token function">sed</span> -i <span class="token string">'s#^SELINUX=enforcing#SELINUX=disabled#'</span> /etc/selinux/config<span class="token comment" spellcheck="true"># 关闭swap分区</span>swapoff -a<span class="token function">sed</span> -i <span class="token string">'s!^/dev/mapper/centos-swap!#&amp;!'</span> /etc/fstab<span class="token comment" spellcheck="true"># 设置主机名</span>hostnamectl set-hostname <span class="token punctuation">[</span>hostname<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 配置hosts解析</span><span class="token function">cat</span> <span class="token operator">>></span> /etc/hosts <span class="token operator">&lt;&lt;</span> <span class="token string">EOF10.10.110.190 k8s-master10.10.110.191 k8s-node110.10.110.192 k8s-node2EOF</span><span class="token comment" spellcheck="true"># 避免 iptables 被绕过而导致流量无法正确路由</span><span class="token function">cat</span> <span class="token operator">></span> /etc/sysctl.d/k8s.conf <span class="token operator">&lt;&lt;</span> <span class="token string">EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1vm.swappiness = 0EOF</span>sysctl --system    <span class="token comment" spellcheck="true"># 确保在此步骤之前已加载了 br_netfilter 模块,这可以通过运行 lsmod | grep br_netfilter 来查看,需要加载请执行 modprobe br_netfilter</span><span class="token comment" spellcheck="true"># 时间同步</span>yum <span class="token function">install</span> ntpdate -yntpdate cn.pool.ntp.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="安装-docker-kubeadm-kubelet-kubectl"><a href="#安装-docker-kubeadm-kubelet-kubectl" class="headerlink" title="安装 docker kubeadm kubelet kubectl"></a>安装 docker kubeadm kubelet kubectl</h1><p>在所有节点安装 docker kubeadm kubelet，kubernetes 默认的 CRI 是 docker，因此先安装 docker 。kubeadm 是用来初始化集群的指令，kubelet 负责在集群中的每个节点上用来启动 pod 和容器，kubectl 是用来与集群通信的命令行工具。安装时需要确保kubeadm、kubelet、kubectl 和 kubeadm 安装的版本相匹配，否则存在发生版本偏差的风险</p><p>安装 docker</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装依赖包</span>yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2<span class="token comment" spellcheck="true"># 添加 Docker 阿里云镜像源</span><span class="token function">wget</span> https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo<span class="token comment" spellcheck="true"># 安装 Docker CE</span>yum <span class="token function">install</span> -y docker-ce<span class="token comment" spellcheck="true"># 启动 Docker 服务并设置开机启动</span>systemctl start dockersystemctl <span class="token function">enable</span> docker<span class="token comment" spellcheck="true"># 配置阿里云镜像服务加速地址</span><span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF{    "registry-mirrors": ["https://265wemgl.mirror.aliyuncs.com"]}EOF</span>systemctl daemon-reloadsystemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装 kubeadm kubelet kubectl</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加 kubernetes 阿里云镜像源</span><span class="token function">cat</span> <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</span><span class="token comment" spellcheck="true"># 指定版本安装</span>yum <span class="token function">install</span> -y kubelet-1.19.0 kubeadm-1.19.0 kubectl-1.19.0systemctl <span class="token function">enable</span> kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="初始化-kubernetes-master-节点"><a href="#初始化-kubernetes-master-节点" class="headerlink" title="初始化 kubernetes master 节点"></a>初始化 kubernetes master 节点</h1><p>在 master 节点执行</p><pre class="line-numbers language-bash"><code class="language-bash">kubeadm init \  --apiserver-advertise-address<span class="token operator">=</span>10.10.110.190 \  --image-repository registry.aliyuncs.com/google_containers \  --kubernetes-version v1.19.0 \  --service-cidr<span class="token operator">=</span>10.10.0.0/12 \  --pod-network-cidr<span class="token operator">=</span>10.244.0.0/16 \  --ignore-preflight-errors<span class="token operator">=</span>all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>–apiserver-advertise-address 服务器所公布的其正在监听的 IP 地址</p></li><li><p>–image-repository 默认拉取镜像地址为 k8s.gcr.io ，这里指定阿里云镜像仓库地址</p></li><li><p>–kubernetes-version 指定 k8s 安装版本</p></li><li><p>–service-cidr 集群内部虚拟网络，Pod 统一访问入口</p></li><li><p>–pod-network-cidr 指明 pod 网络可以使用的 IP 地址段</p></li></ul><p>拷贝 kubectl 连接 k8s 所使用的认证文件到当前用户的默认路径</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token variable">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token variable">$HOME</span>/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置 k8s 命令自动补全</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y epel-release bash-completion<span class="token function">source</span> /usr/share/bash-completion/bash_completion<span class="token function">source</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>kubectl completion bash<span class="token punctuation">)</span><span class="token keyword">echo</span> <span class="token string">"source &lt;(kubectl completion bash)"</span> <span class="token operator">>></span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="kubernetes-集群添加节点"><a href="#kubernetes-集群添加节点" class="headerlink" title="kubernetes 集群添加节点"></a>kubernetes 集群添加节点</h1><p>在 10.10.110.191/192 节点上执行，所有 node 节点都需要执行，执行 kubeadm init 输出的 kubeadm join 命令</p><pre class="line-numbers language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 10.10.110.190:6443 --token j3rqzp.ku4k3ift3i6z1hnb \    --discovery-token-ca-cert-hash sha256:c9460068e3b3bd4d3b111dd1581f50eaada11c2e7a47c958b3a7d158c6ae2170<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这时候我们在 master 执行 kubectl get nodes ，发现 node 的状态其实是 NotReady 的</p><h1 id="安装-Pod-网络插件"><a href="#安装-Pod-网络插件" class="headerlink" title="安装 Pod 网络插件"></a>安装 Pod 网络插件</h1><p>我们必须部署一个基于容器网络接口 (CNI) 的 Pod 网络插件，这样 Pods 之间才可以相互通信。在安装网络之前，群集 DNS (CoreDNS)不会启动，这也是为什么 node 的状态其实是 NotReady 的原因。k8s 常用的网络插件包括 calico、flannel、Canal 和 Weave，这里我们使用 calico 来为 kubernetes 集群提供网络策略支持</p><p>部署 calico 网络插件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载 calico 官方配置文件(国内网络可能会下载失败)</span><span class="token function">wget</span> https://docs.projectcalico.org/manifests/calico.yaml<span class="token comment" spellcheck="true"># 修改 calico 配置文件</span>- name: CALICO_IPV4POOL_CIDR  value: <span class="token string">"10.244.0.0/16"</span>    <span class="token comment" spellcheck="true"># 这个默认网段是192.168.0.0/16,修改成前面 kubeadm init 指定的 --pod-network-cidr 一样</span><span class="token comment" spellcheck="true"># 应用配置文件</span>kubectl apply -f calico.yaml<span class="token comment" spellcheck="true"># 查看 pods 运行状态</span>kubectl get pods -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="测试-kubernetes-集群"><a href="#测试-kubernetes-集群" class="headerlink" title="测试 kubernetes 集群"></a>测试 kubernetes 集群</h1><p>我们在搭建好 kubernetes 集群后，创建一个 pod 验证集群是否正常运行</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create deployment nginx-deploy --image<span class="token operator">=</span>nginxkubectl expose deployment nginx-deploy --port<span class="token operator">=</span>8080 --type<span class="token operator">=</span>NodePort --target-port<span class="token operator">=</span>80kubectl get pod,svc -o wideNodePort 类型的 <span class="token function">service</span> 会从 30000-32767 范围随机分配一个端口--port 指的是 <span class="token function">service</span> CLUSTER-IP 的端口--target-port 指的是 pod 的端口<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod,svc -o wide</span>NAME                               READY   STATUS    RESTARTS   AGE   IP               NODE        NOMINATED NODE   READINESS GATESpod/nginx-deploy-8588f9dfb-h28ck   1/1     Running   0          10m   10.244.169.135   k8s-node2   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>NAME                   TYPE        CLUSTER-IP    EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE     SELECTORservice/kubernetes     ClusterIP   10.0.0.1      <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          6d17h   <span class="token operator">&lt;</span>none<span class="token operator">></span>service/nginx-deploy   NodePort    10.4.54.140   <span class="token operator">&lt;</span>none<span class="token operator">></span>        8080:31234/TCP   14s     app<span class="token operator">=</span>nginx-deploy<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get ep</span>NAME           ENDPOINTS            AGEkubernetes     10.10.110.190:6443   6d17hnginx-deploy   10.244.169.135:80    18snodeIP:31234 <span class="token operator">>></span> 10.4.54.140:8080 <span class="token operator">>></span> 10.244.169.135:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用 NodePort 的方式将 service 暴露出去，如果 service 不指定类型那默认是 ClusterIP，只能集群内部访问</p><h1 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h1><p>kubernetes dashboard 是一个用于 kubernetes 集群的通用、基于 web 的用户界面。它允许用户管理在集群中运行的应用程序并对其进行故障排除，以及管理集群本身</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.4/aio/deploy/recommended.yaml<span class="token comment" spellcheck="true"># dashboard 默认的 service 是 ClusterIP 类型,我们需要修改为 NodePort 类型,才能让外部访问到我们的 dashboard</span>---kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  ports:    - port: 443      targetPort: 8443      nodePort: 30023  selector:    k8s-app: kubernetes-dashboard  type: NodePort---kubectl apply -f recommended.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dashboard 访问地址: <a href="https://nodeIP:30023" target="_blank" rel="noopener">https://nodeIP:30023</a></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 我们首先在 kubernetes-dashboard 命名空间中创建名为 admin-user 的 service account</span>kubectl create serviceaccount admin-user -n kubernetes-dashboardkubectl get serviceaccounts -n kubernetes-dashboard<span class="token comment" spellcheck="true"># 给 admin-user 用户授权</span>kubectl create clusterrolebinding admin-user --clusterrole<span class="token operator">=</span>cluster-admin --serviceaccount<span class="token operator">=</span>kubernetes-dashboard:admin-user<span class="token comment" spellcheck="true"># 获取 kubernetes-dashboard 命名空间下 admin-user 用户的 token</span>kubectl -n kubernetes-dashboard describe secret <span class="token punctuation">$(</span>kubectl -n kubernetes-dashboard get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span>}'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用输出的 token 就可以登录到 dashboard 管理页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kubeadm-简介&quot;&gt;&lt;a href=&quot;#Kubeadm-简介&quot; class=&quot;headerlink&quot; title=&quot;Kubeadm 简介&quot;&gt;&lt;/a&gt;Kubeadm 简介&lt;/h1&gt;&lt;p&gt;kubeadm 是一个提供了 kubeadm init 和 kubeadm 
      
    
    </summary>
    
    
      <category term="k8s" scheme="https://www.missf.top/categories/k8s/"/>
    
      <category term="Kubeadm" scheme="https://www.missf.top/categories/k8s/Kubeadm/"/>
    
    
      <category term="k8s" scheme="https://www.missf.top/tags/k8s/"/>
    
      <category term="Kubeadm" scheme="https://www.missf.top/tags/Kubeadm/"/>
    
      <category term="集群" scheme="https://www.missf.top/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>MariaDB 主从复制和 Maxscale 中间件实现读写分离及故障切换</title>
    <link href="https://www.missf.top/post/2c9da2f4.html"/>
    <id>https://www.missf.top/post/2c9da2f4.html</id>
    <published>2020-09-14T03:20:58.000Z</published>
    <updated>2020-10-12T06:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre class="line-numbers language-bash"><code class="language-bash">system version: CentOS Linux release 7.7.1908mariadb version: 10.5.2maxscale version: 2.5.3 GAclient: 10.10.110.84mariadb master: 10.10.110.80mariadb slave1: 10.10.110.81mariadb slave2: 10.10.110.82maxscale proxy: 10.10.110.83<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><p>当 mariadb master 服务器上的数据发生改变时(增、删、改)，则将其改变写入 binlog 二进制日志中。slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开启一个 I/O 线程请求 master 二进制事件，同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从库本地的中继日志中，从库将启动 SQL 线程从中继日志中读取二进制日志，在本地回放，使得从库数据和主库的数据保持一致，最后 IO 线程和 SQL 线程将进入睡眠状态，等待下一次被唤醒</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f602d67160a154a67163d5e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="主从复制的前提条件"><a href="#主从复制的前提条件" class="headerlink" title="主从复制的前提条件"></a>主从复制的前提条件</h1><blockquote><p>master 一定要开启 binlog 二进制日志，并且授予 slave 远程连接的权限</p></blockquote><blockquote><p>主从复制至少需要两个 mysql 实例，可以分布在不同服务器，也可以在同一台服务器</p></blockquote><blockquote><p>master 实例和 slave 实例的 mysql 版本最好相同(如果不同，那么 master 实例版本需要低于 slave 实例)</p></blockquote><blockquote><p>master 实例和 slave 实例之间时间同步</p></blockquote><h1 id="配置-MariaDB-Master-节点"><a href="#配置-MariaDB-Master-节点" class="headerlink" title="配置 MariaDB Master 节点"></a>配置 MariaDB Master 节点</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装MariaDB</span><span class="token function">tee</span> /etc/yum.repos.d/Mariadb.repo <span class="token operator">&lt;&lt;</span> <span class="token string">EOF# mariadb 10.5 CentOS repository list - created 2020-09-14 10:57 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name=mariadbbaseurl=https://mirrors.aliyun.com/mariadb/yum/10.5/centos7-amd64/gpgkey=https://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck=1EOF</span>yum clean all <span class="token operator">&amp;&amp;</span> yum makecacheyum <span class="token function">install</span> -y MariaDB-server MariaDB-client<span class="token comment" spellcheck="true"># 配置文件</span><span class="token function">cat</span> /etc/my.cnf.d/server.cnf<span class="token punctuation">..</span>.<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>log-bin<span class="token operator">=</span>mariadb-binserver_id<span class="token operator">=</span>180port<span class="token operator">=</span>53306<span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 启动mariadb</span>systemctl start mariadb<span class="token comment" spellcheck="true"># 添加用户slave授予远程连接的权限,供从节点复制binlog</span>GRANT REPLICATION SLAVE ON *.* TO <span class="token string">'slave'</span>@<span class="token string">'10.10.110.%'</span> IDENTIFIED BY <span class="token string">'123456'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查看主库的binlog记录日志信息偏移量position</span>mariadb <span class="token punctuation">[</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">></span> show master status<span class="token punctuation">;</span>+--------------------+----------+--------------+------------------+<span class="token operator">|</span> File               <span class="token operator">|</span> Position <span class="token operator">|</span> Binlog_Do_DB <span class="token operator">|</span> Binlog_Ignore_DB <span class="token operator">|</span>+--------------------+----------+--------------+------------------+<span class="token operator">|</span> mariadb-bin.000001 <span class="token operator">|</span>      529 <span class="token operator">|</span>              <span class="token operator">|</span>                  <span class="token operator">|</span>+--------------------+----------+--------------+------------------+1 row <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.000 sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置-MariaDB-Slave-节点"><a href="#配置-MariaDB-Slave-节点" class="headerlink" title="配置 MariaDB Slave 节点"></a>配置 MariaDB Slave 节点</h1><p>mariadb 10.0.2开始，GTID 是默认打开的。因为 maxscale 故障切换功能需要 mariadb 开启基于 GTID 的主从复制，而且是以  <code>master_use_gtid=current_pos</code> 的方式。因为 <code>master_use_gtid=slave_pos</code> 的方式，master 将从最后一个 GTID 开始给 slave 复制 binlog，通过 <code>@@gtid_slave_pos</code> 这个变量来查看目前最后一个 GTID 的位置，如果A节点 (master) 故障了之后由B节点成为了 master，当 A 节点以 slave 的身份加入到集群时，由于 A 节点之前从未成为过 slave，那么 A 节点的 <code>@@gtid_slave_pos</code> 是空的。为了能让故障的 master 节点故障之后能够重新以 slave 的身份加入到集群，我们需要使用 <code>master_use_gtid=current_pos</code> 的 GTID 方式开启主从复制</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 指定主库信息(master信息会存到/var/lib/mysql/master.info文件)mariadb [(none)]> change master to master_host='10.10.110.80',    -> master_user='slave',    -> master_password='123456',    -> master_port=53306,    -> master_use_gtid=current_pos,    -> master_connect_retry=30;Query OK, 0 rows affected (0.017 sec)# 启动slave线程,若要更改指定的主库信息,需先执行stop slave,修改完成后执行start slavemariadb [(none)]> start slave;Query OK, 0 rows affected (0.003 sec)# 查看slave状态(slave_IO_Running和slave_SQL_Running都为Yes状态)mariadb [(none)]> show slave status\G*************************** 1. row ***************************                slave_IO_State: Waiting for master to send event                   master_Host: 10.10.110.80                   master_User: slave                   master_Port: 53306                 Connect_Retry: 30               master_Log_File: mariadb-bin.000001           Read_master_Log_Pos: 529                Relay_Log_File: localhost-relay-bin.000002                 Relay_Log_Pos: 830         Relay_master_Log_File: mariadb-bin.000001              slave_IO_Running: Yes             slave_SQL_Running: Yes               Replicate_Do_DB:            Replicate_Ignore_DB:             Replicate_Do_Table:         Replicate_Ignore_Table:        Replicate_Wild_Do_Table:    Replicate_Wild_Ignore_Table:                     Last_Errno: 0                    Last_Error:                   Skip_Counter: 0           Exec_master_Log_Pos: 529               Relay_Log_Space: 1143               Until_Condition: None                Until_Log_File:                  Until_Log_Pos: 0            master_SSL_Allowed: No            master_SSL_CA_File:             master_SSL_CA_Path:                master_SSL_Cert:              master_SSL_Cipher:                 master_SSL_Key:          Seconds_Behind_master: 0 master_SSL_Verify_Server_Cert: No                 Last_IO_Errno: 0                 Last_IO_Error:                 Last_SQL_Errno: 0                Last_SQL_Error:    Replicate_Ignore_Server_Ids:               master_Server_Id: 80                master_SSL_Crl:             master_SSL_Crlpath:                     Using_Gtid: Current_Pos                   Gtid_IO_Pos: 0-80-1       Replicate_Do_Domain_Ids:    Replicate_Ignore_Domain_Ids:                  Parallel_Mode: optimistic                     SQL_Delay: 0           SQL_Remaining_Delay: NULL       slave_SQL_Running_State: slave has read all relay log; waiting for more updates              slave_DDL_Groups: 1slave_Non_Transactional_Groups: 0    slave_Transactional_Groups: 01 row in set (0.001 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="验证主从复制"><a href="#验证主从复制" class="headerlink" title="验证主从复制"></a>验证主从复制</h1><p>在 mariadb master 上创建测试数据，然后在 mariadb slave 上查看数据是否已经同步过来</p><pre class="line-numbers language-mysql"><code class="language-mysql">create database mariadb;use mariadb;create table mariadb(name varchar(25),city varchar(30),age int);insert into mariadb.mariadb values("mariadb","china",11);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="MariaDB-开启并行复制"><a href="#MariaDB-开启并行复制" class="headerlink" title="MariaDB 开启并行复制"></a>MariaDB 开启并行复制</h1><p>mariadb的复制通过三步完成:</p><blockquote><p>1.从库的IO线程去主库上读取binlog日志变更，并把读取的事件按顺序存放到relay log</p></blockquote><blockquote><p>2.从库的SQL线程一次读取relay log中的一个事件</p></blockquote><blockquote><p>3.SQL线程依次执行relay log中的事件</p></blockquote><p>mariadb 10之前的版本中，第三步是通过SQL线程来执行的，这意味着一次只能执行一个事件，复制本质上是单线程的。mariadb 10之后的版本中，第三步可以由一个单独的复制工作线程池执行，从而通过并行应用多个事件来提高复制性能</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/my.cnf.d/server.cnf<span class="token punctuation">..</span>.<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>slave-parallel-threads<span class="token operator">=</span>8  <span class="token comment" spellcheck="true"># 在工作线程池中创建8个线程</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看工作线程的数量</p><pre class="line-numbers language-mysql"><code class="language-mysql">MariaDB [(none)]> SHOW PROCESSLIST;+----+-------------+-----------+------+--------------+------+--------------------------------------------------------+------------------+----------+| Id | User        | Host      | db   | Command      | Time | State                                                  | Info             | Progress |+----+-------------+-----------+------+--------------+------+--------------------------------------------------------+------------------+----------+|  5 | system user |           | NULL | Slave_IO     |   27 | Waiting for master to send event                       | NULL             |    0.000 ||  7 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 ||  8 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 ||  9 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 || 10 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 || 11 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 || 12 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 || 13 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 || 14 | system user |           | NULL | Slave_worker |   27 | Waiting for work from SQL thread                       | NULL             |    0.000 ||  6 | system user |           | NULL | Slave_SQL    |   27 | Slave has read all relay log; waiting for more updates | NULL             |    0.000 || 15 | root        | localhost | NULL | Query        |    0 | starting                                               | SHOW PROCESSLIST |    0.000 |+----+-------------+-----------+------+--------------+------+--------------------------------------------------------+------------------+----------+11 rows in set (0.000 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="判断主从复制延迟"><a href="#判断主从复制延迟" class="headerlink" title="判断主从复制延迟"></a>判断主从复制延迟</h1><p>Seconds_Behind_Master 是通过 sql_thread 执行的事件的时间戳和 io_thread 复制好的事件的时间戳进行比较，而得到的一个差值</p><blockquote><p> NULL：表示 io_thread 或是 sql_thread 有任何一个发生故障，也就是该线程的 Running 状态是 No 而非 Yes</p></blockquote><blockquote><p>0：该值为零，是我们极为渴望看到的情况，表示主从复制良好，可以认为 lag 不存在</p></blockquote><blockquote><p>正值：表示主从已经出现延时，数字越大表示从库落后主库越多</p></blockquote><blockquote><p>负值：几乎很少见，其实这是一个 BUG 值，该参数是不应该出现负值的</p></blockquote><p>仅仅依靠 Seconds_Behind_Master 的值来监测主从同步数据是否延迟是绝对不可靠的，如果网络存在延迟，即使我们看到 Seconds_Behind_Master 的值为零，也会存在很大的偏差。更加严谨的判断主从延时的做法是：</p><blockquote><p>对 master 和 slave 同时发起 SHOW BINARY LOGS 请求，判断二者 binlog 的差异</p></blockquote><blockquote><p>对 slave 发起 SHOW slave STATUS\G 的请求，查看 Read_Master_Log_Pos 和 Exec_Master_Log_Pos 是否一致</p></blockquote><h1 id="读写分离和故障切换的实现"><a href="#读写分离和故障切换的实现" class="headerlink" title="读写分离和故障切换的实现"></a>读写分离和故障切换的实现</h1><p>数据写入操作在主库执行，数据读取操作在从库执行，在一定程度上减轻了数据库的压力，主从复制保证了数据的安全</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f606ad0160a154a67249d5b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Maxscale-概述"><a href="#Maxscale-概述" class="headerlink" title="Maxscale 概述"></a>Maxscale 概述</h1><p>maxscale 是由 mariadb 团队开发的一个数据库代理工具，将数据库语句转发到一个或多个数据库服务器，转发是使用基于对数据库语句的语义理解和后端数据库集群中服务器角色的规则来执行的，设计目的是为应用程序提供透明的负载平衡和高可用性功能。mariadb  maxscale 具有可扩展和灵活的架构，通过插件组件支持不同的协议和路由方法</p><h1 id="安装-Maxscale"><a href="#安装-Maxscale" class="headerlink" title="安装 Maxscale"></a>安装 Maxscale</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> https://downloads.mariadb.com/MaxScale/2.5.3/rhel/7/x86_64/maxscale-2.5.3-2.rhel.7.x86_64.rpmyum -y <span class="token function">install</span> maxscale-2.5.3-2.rhel.7.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="MariaDB-Master-主库上创建相关的账户"><a href="#MariaDB-Master-主库上创建相关的账户" class="headerlink" title="MariaDB Master 主库上创建相关的账户"></a>MariaDB Master 主库上创建相关的账户</h1><p>在开始配置之前，需要在 mariadb master 中为 maxscale 创建两个用户，用于 maxscale 的监控模块和路由模块</p><p>monitor_user：该账号监控集群状态，如果发现某个从服务器复制线程停掉了，那么就不向其转发请求了</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 创建监控用户,用于[MariaDB-Monitor]配置CREATE USER 'monitor_user'@'%' IDENTIFIED BY '123456';GRANT REPLICATION CLIENT ON *.* TO 'monitor_user'@'%';# 如果使用 MariaDB Monitor 的自动故障转移，用户将需要额外的授权GRANT SUPER, RELOAD ON *.* TO 'monitor_user'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>routing_user：该账号将不同的请求分发到不同的节点上，当客户端连接到 maxscale 这个节点上时，maxscale 节点会使用该账号去查后端数据库，检查客户端登陆的用户是否有权限或密码是否正确等等</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 创建routing user,用于[Read-Write-Service]配置CREATE USER 'routing_user'@'%' IDENTIFIED BY '123456';GRANT SELECT ON mysql.user TO 'routing_user'@'%';GRANT SELECT ON mysql.db TO 'routing_user'@'%';GRANT SELECT ON mysql.tables_priv TO 'routing_user'@'%';GRANT SELECT ON mysql.columns_priv TO 'routing_user'@'%';GRANT SELECT ON mysql.proxies_priv TO 'routing_user'@'%';GRANT SELECT ON mysql.roles_mapping TO 'routing_user'@'%';GRANT SHOW DATABASES ON *.* TO 'routing_user'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置加密密码"><a href="#配置加密密码" class="headerlink" title="配置加密密码"></a>配置加密密码</h1><p>我们创建的数据库用户信息需要填写到 maxscale 配置文件中，为了防止配置文件出现明文密码，我们可以使用秘钥为密码加密，然后将加密后的字符串填写在 maxscale 配置文件中</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成秘钥,密钥将保存到/var/lib/maxscale/.secrets</span>maxkeys    <span class="token comment" spellcheck="true"># 基于秘钥生成123456加密后的字符串(记录下来)</span>maxpasswd /var/lib/maxscale/ 123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Maxscale-配置文件"><a href="#Maxscale-配置文件" class="headerlink" title="Maxscale 配置文件"></a>Maxscale 配置文件</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># grep -v "^#" /etc/maxscale.cnf</span><span class="token punctuation">[</span>maxscale<span class="token punctuation">]</span>threads<span class="token operator">=</span>autoadmin_host<span class="token operator">=</span>0.0.0.0admin_port<span class="token operator">=</span>8080admin_secure_gui<span class="token operator">=</span>false    <span class="token comment" spellcheck="true"># 关闭GUI安全验证,不然需要配置ssl</span><span class="token punctuation">[</span>server1<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 不需要指定哪个是master和slave,maxscale会自动识别</span>type<span class="token operator">=</span>serveraddress<span class="token operator">=</span>10.10.110.80port<span class="token operator">=</span>53306protocol<span class="token operator">=</span>MariaDBBackend<span class="token punctuation">[</span>server2<span class="token punctuation">]</span>type<span class="token operator">=</span>serveraddress<span class="token operator">=</span>10.10.110.81port<span class="token operator">=</span>53306protocol<span class="token operator">=</span>MariaDBBackend<span class="token punctuation">[</span>server3<span class="token punctuation">]</span>type<span class="token operator">=</span>serveraddress<span class="token operator">=</span>10.10.110.82port<span class="token operator">=</span>53306protocol<span class="token operator">=</span>MariaDBBackend<span class="token punctuation">[</span>MariaDB-Monitor<span class="token punctuation">]</span>type<span class="token operator">=</span>monitormodule<span class="token operator">=</span>mariadbmonservers<span class="token operator">=</span>server1,server2,server3user<span class="token operator">=</span>monitor_userpassword<span class="token operator">=</span>EA25B20FBB2B3EF4562F9D585DE8826B64B328C08571D8F656424252F9560A62monitor_interval<span class="token operator">=</span>2000<span class="token punctuation">[</span>Read-Write-Service<span class="token punctuation">]</span>type<span class="token operator">=</span>servicerouter<span class="token operator">=</span>readwritesplit    <span class="token comment" spellcheck="true"># 配置读写分离的路由</span>servers<span class="token operator">=</span>server1,server2,server3user<span class="token operator">=</span>routing_userpassword<span class="token operator">=</span>EA25B20FBB2B3EF4562F9D585DE8826B64B328C08571D8F656424252F9560A62<span class="token punctuation">[</span>Read-Write-Listener<span class="token punctuation">]</span>type<span class="token operator">=</span>listenerservice<span class="token operator">=</span>Read-Write-Service    <span class="token comment" spellcheck="true"># 监听读写分离的服务</span>protocol<span class="token operator">=</span>MariaDBClientport<span class="token operator">=</span>4006    <span class="token comment" spellcheck="true"># maxscale代理的端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="启动-Maxscale-服务"><a href="#启动-Maxscale-服务" class="headerlink" title="启动 Maxscale 服务"></a>启动 Maxscale 服务</h1><pre class="line-numbers language-bash"><code class="language-bash">systemctl start maxscale.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Maxctrl-管理工具的使用"><a href="#Maxctrl-管理工具的使用" class="headerlink" title="Maxctrl 管理工具的使用"></a>Maxctrl 管理工具的使用</h1><p>maxctrl 如果不指定 COMMAND 将会进入交互式模式，在交互式中可以直接输入 COMMAND，以表格格式显示基础信息</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示所有后端服务器</span>maxctrl -h 10.10.110.83:8080 list servers┌─────────┬──────────────┬───────┬─────────────┬─────────────────┬─────────┐│ Server  │ Address      │ Port  │ Connections │ State           │ GTID    │├─────────┼──────────────┼───────┼─────────────┼─────────────────┼─────────┤│ server1 │ 10.10.110.80 │ 53306 │ 0           │ Master, Running │ 0-80-15 │├─────────┼──────────────┼───────┼─────────────┼─────────────────┼─────────┤│ server2 │ 10.10.110.81 │ 53306 │ 0           │ Slave, Running  │ 0-80-15 │├─────────┼──────────────┼───────┼─────────────┼─────────────────┼─────────┤│ server3 │ 10.10.110.82 │ 53306 │ 0           │ Slave, Running  │ 0-80-15 │└─────────┴──────────────┴───────┴─────────────┴─────────────────┴─────────┘list services <span class="token comment" spellcheck="true"># 显示所有服务，例如读写分离服务等</span>list monitors <span class="token comment" spellcheck="true"># 显示所有监控信息</span>list listeners <span class="token comment" spellcheck="true"># 显示监听信息</span><span class="token comment" spellcheck="true"># 更多的命令可以去官网自行了解...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="登录-Maxscale-仪表板"><a href="#登录-Maxscale-仪表板" class="headerlink" title="登录 Maxscale 仪表板"></a>登录 Maxscale 仪表板</h1><p>默认情况下用户名是 admin，密码是 mariadb</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f697016160a154a670f066c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>仪表板界面可以看到以下资源的概览信息：按 monitor 分组的所有服务器，当前会话和所有服务。这些资源的信息每10秒更新一次。监视器、服务器和服务资源都有自己的详细信息页面。可以通过单击仪表板页面上的资源名称来访问它，在详细信息页中，可以修改部分资源参数的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f69996e160a154a6728344b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Maxscale-测试读写分离"><a href="#Maxscale-测试读写分离" class="headerlink" title="Maxscale 测试读写分离"></a>Maxscale 测试读写分离</h1><p>验证读写分离的 “读” 操作是否在从库上</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 分别在两个从库上创建数据create database slave;use slave;create table info(name varchar(25),ip int);insert into slave.info values("slave",inet_aton('10.10.110.81'));create database slave;use slave;create table info(name varchar(25),ip int);insert into slave.info values("slave",inet_aton('10.10.110.82'));# 在主库上创建测试用户grant all on *.* to 'check'@'%' identified by '123456';# 连接maxscale查询数据验证读写分离(读操作自动负载均衡)mysql -ucheck -p123456 -P4006 -h 10.10.110.83MariaDB [(none)]> select name,inet_ntoa(ip) from slave.info;+-------+---------------+| name  | inet_ntoa(ip) |+-------+---------------+| slave | 10.10.110.82  |+-------+---------------+1 row in set (0.002 sec)MariaDB [(none)]> select name,inet_ntoa(ip) from slave.info;+-------+---------------+| name  | inet_ntoa(ip) |+-------+---------------+| slave | 10.10.110.81  |+-------+---------------+1 row in set (0.001 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证读写分离的 “写” 操作是否在主库上</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 连接maxscale往里写数据,看slave上数据有没有同步过来create database test;use test;create table test(name varchar(25),city varchar(30),age int);insert into test.test values("mariadb","china",11);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Maxscale-配置故障切换"><a href="#Maxscale-配置故障切换" class="headerlink" title="Maxscale 配置故障切换"></a>Maxscale 配置故障切换</h1><p>编辑 maxscale 的配置文件，配置故障切换参数</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># grep -v "^#" /etc/maxscale.cnf</span><span class="token punctuation">[</span>maxscale<span class="token punctuation">]</span>threads<span class="token operator">=</span>autoadmin_host<span class="token operator">=</span>0.0.0.0admin_port<span class="token operator">=</span>8080admin_secure_gui<span class="token operator">=</span>false<span class="token punctuation">[</span>server1<span class="token punctuation">]</span>type<span class="token operator">=</span>serveraddress<span class="token operator">=</span>10.10.110.80port<span class="token operator">=</span>53306protocol<span class="token operator">=</span>MariaDBBackend<span class="token punctuation">[</span>server2<span class="token punctuation">]</span>type<span class="token operator">=</span>serveraddress<span class="token operator">=</span>10.10.110.81port<span class="token operator">=</span>53306protocol<span class="token operator">=</span>MariaDBBackend<span class="token punctuation">[</span>server3<span class="token punctuation">]</span>type<span class="token operator">=</span>serveraddress<span class="token operator">=</span>10.10.110.82port<span class="token operator">=</span>53306protocol<span class="token operator">=</span>MariaDBBackend<span class="token punctuation">[</span>MariaDB-Monitor<span class="token punctuation">]</span>type<span class="token operator">=</span>monitormodule<span class="token operator">=</span>mariadbmonservers<span class="token operator">=</span>server1,server2,server3user<span class="token operator">=</span>monitor_userpassword<span class="token operator">=</span>EA25B20FBB2B3EF4562F9D585DE8826B64B328C08571D8F656424252F9560A62monitor_interval<span class="token operator">=</span>2000replication_user<span class="token operator">=</span>slave    <span class="token comment" spellcheck="true"># 复制用户</span>replication_password<span class="token operator">=</span>EA25B20FBB2B3EF4562F9D585DE8826B64B328C08571D8F656424252F9560A62auto_failover<span class="token operator">=</span>true    <span class="token comment" spellcheck="true"># 开启自动故障转移</span>auto_rejoin<span class="token operator">=</span>true    <span class="token comment" spellcheck="true"># 自动重新连接</span>failcount<span class="token operator">=</span>3    <span class="token comment" spellcheck="true"># 故障次数</span>failover_timeout<span class="token operator">=</span>90    <span class="token comment" spellcheck="true"># 故障转移超时</span>switchover_timeout<span class="token operator">=</span>90    <span class="token comment" spellcheck="true"># 故障切换超时</span>verify_master_failure<span class="token operator">=</span>true    <span class="token comment" spellcheck="true"># 自动故障转移启用额外的主故障验证</span>master_failure_timeout<span class="token operator">=</span>10    <span class="token comment" spellcheck="true"># </span><span class="token punctuation">[</span>Read-Write-Service<span class="token punctuation">]</span>type<span class="token operator">=</span>servicerouter<span class="token operator">=</span>readwritesplitservers<span class="token operator">=</span>server1,server2,server3user<span class="token operator">=</span>routing_userpassword<span class="token operator">=</span>EA25B20FBB2B3EF4562F9D585DE8826B64B328C08571D8F656424252F9560A62<span class="token punctuation">[</span>Read-Write-Listener<span class="token punctuation">]</span>type<span class="token operator">=</span>listenerservice<span class="token operator">=</span>Read-Write-Serviceprotocol<span class="token operator">=</span>MariaDBClientport<span class="token operator">=</span>4006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>手动关闭 master 节点，使用 maxctrl 查看 master 状态，可以看到 master 节点会自动切换。当 master节点修复之后会自动重新加入集群</p><pre class="line-numbers language-mysql"><code class="language-mysql">[root@localhost ~]# maxctrl -h 10.10.110.83:8080 list servers┌─────────┬──────────────┬───────┬─────────────┬────────────────┬─────────┐│ Server  │ Address      │ Port  │ Connections │ State          │ GTID    │├─────────┼──────────────┼───────┼─────────────┼────────────────┼─────────┤│ server1 │ 10.10.110.80 │ 53306 │ 0           │ Down           │ 0-80-26 │├─────────┼──────────────┼───────┼─────────────┼────────────────┼─────────┤│ server2 │ 10.10.110.81 │ 53306 │ 0           │ Slave, Running │ 0-81-27 │├─────────┼──────────────┼───────┼─────────────┼────────────────┼─────────┤│ server3 │ 10.10.110.82 │ 53306 │ 0           │ Slave, Running │ 0-82-27 │└─────────┴──────────────┴───────┴─────────────┴────────────────┴─────────┘[root@localhost ~]# maxctrl -h 10.10.110.83:8080 list servers┌─────────┬──────────────┬───────┬─────────────┬─────────────────┬─────────┐│ Server  │ Address      │ Port  │ Connections │ State           │ GTID    │├─────────┼──────────────┼───────┼─────────────┼─────────────────┼─────────┤│ server1 │ 10.10.110.80 │ 53306 │ 0           │ Down            │ 0-80-26 │├─────────┼──────────────┼───────┼─────────────┼─────────────────┼─────────┤│ server2 │ 10.10.110.81 │ 53306 │ 0           │ Master, Running │ 0-81-27 │├─────────┼──────────────┼───────┼─────────────┼─────────────────┼─────────┤│ server3 │ 10.10.110.82 │ 53306 │ 0           │ Slave, Running  │ 0-82-27 │└─────────┴──────────────┴───────┴─────────────┴─────────────────┴─────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;pre class=&quot;line-numbers language-bash&quot;&gt;&lt;code class=&quot;language-bas
      
    
    </summary>
    
    
      <category term="MariaDB" scheme="https://www.missf.top/categories/MariaDB/"/>
    
      <category term="Maxscale" scheme="https://www.missf.top/categories/MariaDB/Maxscale/"/>
    
    
      <category term="MariaDB" scheme="https://www.missf.top/tags/MariaDB/"/>
    
      <category term="数据库" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="读写分离" scheme="https://www.missf.top/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Elastic 收集 Java 日志</title>
    <link href="https://www.missf.top/post/5a1ae96.html"/>
    <id>https://www.missf.top/post/5a1ae96.html</id>
    <published>2020-09-08T10:20:14.000Z</published>
    <updated>2021-01-20T10:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h1><p>Tomcat 属于 Java 应用，这里收集 Tomcat 日志作为示例</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载软件包</span><span class="token function">wget</span> -P /server/tools/https://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.53/bin/apache-tomcat-8.5.53.tar.gz<span class="token comment" spellcheck="true"># 解压</span><span class="token function">tar</span> xf apache-tomcat-8.5.53.tar.gz -C /usr/local/ <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> /usr/local/apache-tomcat-8.5.53/ /usr/local/tomcat<span class="token comment" spellcheck="true"># 启动 tomcat</span>/usr/local/tomcat/bin/startup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编写-Filebeat-pipeline"><a href="#编写-Filebeat-pipeline" class="headerlink" title="编写 Filebeat pipeline"></a>编写 Filebeat pipeline</h1><p>filebeat 获取所有不以 “[“ 开头的行，并将它们合并到上一行以 “[“ 开头的行之后</p><pre class="line-numbers language-json"><code class="language-json">filebeat.inputs<span class="token operator">:</span>- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  paths<span class="token operator">:</span>    - /usr/local/tomcat/logs/catalina.out  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"catalina"</span><span class="token punctuation">]</span>  fields<span class="token operator">:</span>    server<span class="token operator">:</span> tomcat    type<span class="token operator">:</span> tomcat-catalina  fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>  multiline<span class="token operator">:</span>    pattern<span class="token operator">:</span> '^\<span class="token punctuation">[</span>'    negate<span class="token operator">:</span> <span class="token boolean">true</span>    match<span class="token operator">:</span> after#output.console<span class="token operator">:</span>output.redis<span class="token operator">:</span>  hosts<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"10.10.110.194:56379"</span><span class="token punctuation">]</span>  password<span class="token operator">:</span> <span class="token string">"123456"</span>  key<span class="token operator">:</span> <span class="token string">"tomcat"</span>  db<span class="token operator">:</span> <span class="token number">0</span>  datatype<span class="token operator">:</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="模拟-Tomcat-报错日志"><a href="#模拟-Tomcat-报错日志" class="headerlink" title="模拟 Tomcat 报错日志"></a>模拟 Tomcat 报错日志</h1><p>往 Tomcat 的日志写入错误信息，模拟报错信息</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /usr/local/tomcat/logs/catalina.out <span class="token operator">&lt;&lt;</span> <span class="token string">EOFSep 09, 2020 5:50:33 PM org.apache.catalina.startup.Catalina stopServerSEVERE: Catalina.stop: org.xml.sax.SAXParseException; systemId: file:/usr/local/tomcat/conf/server.xml; lineNumber: 22; columnNumber: 45; Attribute name "dda" associated with an element type "Server" must be followed by the ' = ' character.        at java.xml/com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1243)        at java.xml/com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl<span class="token variable">$JAXPSAXParser</span>.parse(SAXParserImpl.java:635)        at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1495)        at org.apache.catalina.startup.Catalina.stopServer(Catalina.java:485)        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        at java.base/java.lang.reflect.Method.invoke(Method.java:566)        at org.apache.catalina.startup.Bootstrap.stopServer(Bootstrap.java:389)        at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:479)EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编写-Logstash-pipeline"><a href="#编写-Logstash-pipeline" class="headerlink" title="编写 Logstash pipeline"></a>编写 Logstash pipeline</h1><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  redis <span class="token punctuation">{</span>    host => <span class="token string">"10.10.110.194"</span>    port => <span class="token number">56379</span>    password => <span class="token string">"123456"</span>    db => <span class="token string">"0"</span>    data_type => <span class="token string">"list"</span>    key => <span class="token string">"tomcat"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  if <span class="token punctuation">[</span>type<span class="token punctuation">]</span> == <span class="token string">"tomcat-catalina"</span> <span class="token punctuation">{</span>    if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"catalina"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"filebeat-tomcat-%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Kibana-展示数据"><a href="#Kibana-展示数据" class="headerlink" title="Kibana 展示数据"></a>Kibana 展示数据</h1><p>这里展示数据是不显示完全的，我们可以指定字段查看更详细的信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f588106160a154a67e70090.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>指定 message 字段，查看被合并成一行的 Tomcat 报错日志</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f5881ef160a154a67e7b65a.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装-Tomcat&quot;&gt;&lt;a href=&quot;#安装-Tomcat&quot; class=&quot;headerlink&quot; title=&quot;安装 Tomcat&quot;&gt;&lt;/a&gt;安装 Tomcat&lt;/h1&gt;&lt;p&gt;Tomcat 属于 Java 应用，这里收集 Tomcat 日志作为示例&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic 收集 Nginx 日志</title>
    <link href="https://www.missf.top/post/baa98a96.html"/>
    <id>https://www.missf.top/post/baa98a96.html</id>
    <published>2020-08-25T06:27:22.000Z</published>
    <updated>2020-09-28T03:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-配置-Json-格式日志"><a href="#Nginx-配置-Json-格式日志" class="headerlink" title="Nginx 配置 Json 格式日志"></a>Nginx 配置 Json 格式日志</h1><p>修改 Nginx 配置文件，定义输出 json 格式的日志，便于 filebeat 和 logstash 收集</p><pre class="line-numbers language-json"><code class="language-json">http <span class="token punctuation">{</span>    log_format  main  '<span class="token punctuation">{</span><span class="token property">"@timestamp"</span><span class="token operator">:</span> <span class="token string">"$time_iso8601"</span><span class="token punctuation">,</span> '                        '<span class="token property">"clientRealIp"</span><span class="token operator">:</span> <span class="token string">"$remote_addr"</span><span class="token punctuation">,</span> '                        '<span class="token property">"scheme"</span><span class="token operator">:</span> <span class="token string">"$scheme"</span><span class="token punctuation">,</span> '                        '<span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"$request_method"</span><span class="token punctuation">,</span> '                        '<span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"$host"</span><span class="token punctuation">,</span> '                        '<span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"$request_uri"</span><span class="token punctuation">,</span> '                        '<span class="token property">"size"</span><span class="token operator">:</span> $body_bytes_sent<span class="token punctuation">,</span> '                        '<span class="token property">"referrer"</span><span class="token operator">:</span> <span class="token string">"$http_referer"</span><span class="token punctuation">,</span> '                        '<span class="token property">"agent"</span><span class="token operator">:</span> <span class="token string">"$http_user_agent"</span><span class="token punctuation">,</span> '                        '<span class="token property">"upstream_addr"</span><span class="token operator">:</span> <span class="token string">"$upstream_addr"</span><span class="token punctuation">,</span> '                        '<span class="token property">"request_time"</span><span class="token operator">:</span> $request_time<span class="token punctuation">,</span> '                        '<span class="token property">"request_length"</span><span class="token operator">:</span> $request_length<span class="token punctuation">,</span> '                        '<span class="token property">"upstream_connect_time"</span><span class="token operator">:</span> <span class="token string">"$upstream_connect_time"</span><span class="token punctuation">,</span> '                        '<span class="token property">"upstream_response_time"</span><span class="token operator">:</span> <span class="token string">"$upstream_response_time"</span><span class="token punctuation">,</span> '                        '<span class="token property">"upstream_status"</span><span class="token operator">:</span> <span class="token string">"$upstream_status"</span><span class="token punctuation">,</span> '                        '<span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"$status"</span><span class="token punctuation">}</span>'<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Filebeat-配置文件"><a href="#Filebeat-配置文件" class="headerlink" title="Filebeat 配置文件"></a>Filebeat 配置文件</h1><p>编写 filebeat 配置文件，收集 Nginx 的 access.log 和 error.log，并且添加自定义字段和标签存储到 redis</p><pre class="line-numbers language-json"><code class="language-json">cat /etc/filebeat/filebeat-nginx.yml filebeat.inputs<span class="token operator">:</span>- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  json.keys_under_root<span class="token operator">:</span> <span class="token boolean">true</span>  paths<span class="token operator">:</span>    - /usr/local/nginx/logs/access.log  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"access"</span><span class="token punctuation">]</span>  fields<span class="token operator">:</span>    server<span class="token operator">:</span> nginx    type<span class="token operator">:</span> nginx-access  fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  json.keys_under_root<span class="token operator">:</span> <span class="token boolean">true</span>  paths<span class="token operator">:</span>    - /usr/local/nginx/logs/error.log  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"error"</span><span class="token punctuation">]</span>  fields<span class="token operator">:</span>    server<span class="token operator">:</span> nginx    type<span class="token operator">:</span> nginx-error  fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>processors<span class="token operator">:</span>- drop_fields<span class="token operator">:</span>    fields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"input_type"</span><span class="token punctuation">,</span> <span class="token string">"ecs.version"</span><span class="token punctuation">,</span> <span class="token string">"host.name"</span><span class="token punctuation">,</span> <span class="token string">"agent"</span><span class="token punctuation">,</span> <span class="token string">"log.offset"</span><span class="token punctuation">]</span>#output.console<span class="token operator">:</span>output.redis<span class="token operator">:</span>  hosts<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"10.10.110.194:56379"</span><span class="token punctuation">]</span>  password<span class="token operator">:</span> <span class="token string">"123456"</span>  key<span class="token operator">:</span> <span class="token string">"nginx"</span>  db<span class="token operator">:</span> <span class="token number">0</span>  datatype<span class="token operator">:</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="控制台调试-Filebeat-输出的日志数据"><a href="#控制台调试-Filebeat-输出的日志数据" class="headerlink" title="控制台调试 Filebeat 输出的日志数据"></a>控制台调试 Filebeat 输出的日志数据</h1><p>通过 drop_fields 去控制我们想要输出的字段，得到精简的日志数据</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"@timestamp"</span><span class="token operator">:</span> <span class="token string">"2020-09-07T18:08:49.000Z"</span><span class="token punctuation">,</span>    <span class="token property">"@metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"beat"</span><span class="token operator">:</span> <span class="token string">"filebeat"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span>        <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.9.0"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"server"</span><span class="token operator">:</span> <span class="token string">"nginx"</span><span class="token punctuation">,</span>    <span class="token property">"ecs"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"host"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"log"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"file"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"/usr/local/nginx/logs/access.log"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"json"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"input"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"log"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"nginx-access"</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"10.10.110.194 - - [08/Sep/2020:02:08:41 +0800] \"GET /848dd HTTP/1.1\" 404 153 \"-\" \"curl/7.29.0\""</span><span class="token punctuation">,</span>    <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"access"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Logstash-读取-Redis-中的日志数据"><a href="#Logstash-读取-Redis-中的日志数据" class="headerlink" title="Logstash 读取 Redis 中的日志数据"></a>Logstash 读取 Redis 中的日志数据</h1><p>logstash 读取 redis 中的日志数据，并且在 Kibana展示 Nginx 日志</p><pre class="line-numbers language-json"><code class="language-json"># logstash配置文件通过我们定义的fields字段和标签匹配数据<span class="token punctuation">,</span>将不同的数据存储到不同的indexinput <span class="token punctuation">{</span>  redis <span class="token punctuation">{</span>    host => <span class="token string">"10.10.110.194"</span>    port => <span class="token number">56379</span>    password => <span class="token string">"123456"</span>    db => <span class="token string">"0"</span>    data_type => <span class="token string">"list"</span>    key => <span class="token string">"nginx"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span> # 通过字段和标签判断日志数据<span class="token punctuation">,</span>存储到不同的index  if <span class="token punctuation">[</span>type<span class="token punctuation">]</span> == <span class="token string">"nginx-access"</span> <span class="token punctuation">{</span>    if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"access"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"filebeat-nginx-access%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  if <span class="token punctuation">[</span>type<span class="token punctuation">]</span> == <span class="token string">"nginx-error"</span> <span class="token punctuation">{</span>    if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"error"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"filebeat-nginx-error%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Kibana-展示-Nginx-日志"><a href="#Kibana-展示-Nginx-日志" class="headerlink" title="Kibana 展示 Nginx 日志"></a>Kibana 展示 Nginx 日志</h1><p>我们可以在 kibana 上创建索引，查看 Nginx 日志，通过字段去统计和展示日志数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f560c25160a154a6759d557.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-配置-Json-格式日志&quot;&gt;&lt;a href=&quot;#Nginx-配置-Json-格式日志&quot; class=&quot;headerlink&quot; title=&quot;Nginx 配置 Json 格式日志&quot;&gt;&lt;/a&gt;Nginx 配置 Json 格式日志&lt;/h1&gt;&lt;p&gt;修改 Ngi
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic 引入 Filebeat</title>
    <link href="https://www.missf.top/post/9482a90c.html"/>
    <id>https://www.missf.top/post/9482a90c.html</id>
    <published>2020-08-20T03:58:57.000Z</published>
    <updated>2021-01-20T10:13:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入-Filebeat-架构简介"><a href="#引入-Filebeat-架构简介" class="headerlink" title="引入 Filebeat 架构简介"></a>引入 Filebeat 架构简介</h1><p>filebeat 代替 logstash 去收集日志数据，然后将收集到的日志数据存储到 redis 或者 kafka，再由 logstash 去消费数据。filebeat 是非常轻量级单用途的日志采集器，属于Beats 家族。早期的 elk 架构使用 logstash 收集、解析日志，但是 logstash 对内存、CPU、IO等资源消耗比较高(因为 logstash 是使用 java 语言编写的)，后来出现了使用golang 编写的 filebeat 日志收集器，可以不依赖任何环境安装即可使用，同时对资源的占用可以忽略不计，使用 filebeat 替代 logstash 去收集日志是非常好的方案</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f55ced6160a154a674c1b90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="安装-Filebeat"><a href="#安装-Filebeat" class="headerlink" title="安装 Filebeat"></a>安装 Filebeat</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载 filebeat</span><span class="token function">wget</span> https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.9.0-x86_64.rpm<span class="token comment" spellcheck="true"># 安装</span>yum <span class="token function">install</span> -y filebeat-7.9.0-x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编写-Filebeat-配置文件"><a href="#编写-Filebeat-配置文件" class="headerlink" title="编写 Filebeat 配置文件"></a>编写 Filebeat 配置文件</h1><p>filebeat 配置文件负责收集日志，然后将数据存到 redis</p><pre class="line-numbers language-json"><code class="language-json">cat /etc/filebeat/filebeat.ymlfilebeat.inputs<span class="token operator">:</span>- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  paths<span class="token operator">:</span>    - /var/log/messages  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"messages"</span><span class="token punctuation">,</span><span class="token string">"syslog"</span><span class="token punctuation">]</span>  #include_lines<span class="token operator">:</span> <span class="token punctuation">[</span>'sometext'<span class="token punctuation">]</span> Filebeat仅导出与列表中的正则表达式匹配的行  #exclude_lines<span class="token operator">:</span> <span class="token punctuation">[</span>'^DBG'<span class="token punctuation">]</span> Filebeat会删除列表中与正则表达式匹配的所有行  fields<span class="token operator">:</span>    # 可以指定字段向输出添加附加信息    type<span class="token operator">:</span> system  # fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>     # 如果为<span class="token boolean">true</span><span class="token punctuation">,</span>则自定义字段将作为顶级字段而不是作为fields字段的子字典- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  paths<span class="token operator">:</span>    - /var/log/audit/audit.log  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"audit"</span><span class="token punctuation">,</span><span class="token string">"syslog"</span><span class="token punctuation">]</span>  fields<span class="token operator">:</span>    type<span class="token operator">:</span> system  # fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>output.console<span class="token operator">:</span>    # 将收集到的日志数据输出到控制台<span class="token punctuation">,</span>可以查看fields定义的字段output.redis<span class="token operator">:</span>    # filebeat将收集到的日志存储到redis  hosts<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"10.10.110.194:56379"</span><span class="token punctuation">]</span>  password<span class="token operator">:</span> <span class="token string">"123456"</span>  key<span class="token operator">:</span> <span class="token string">"filebeat"</span>  db<span class="token operator">:</span> <span class="token number">0</span>  timeout<span class="token operator">:</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="查看-Filebeat-输出的-Json-数据"><a href="#查看-Filebeat-输出的-Json-数据" class="headerlink" title="查看 Filebeat 输出的 Json 数据"></a>查看 Filebeat 输出的 Json 数据</h1><p>我们在调试日志格式时使用命令去启动 filebeat，使用 systemctl 的方式去调试会出现很多转义符，不便于查看</p><pre class="line-numbers language-json"><code class="language-json">/usr/bin/filebeat -c /etc/filebeat/filebeat.yml    # 这里需要将控制台输出的数据json格式化<span class="token punctuation">{</span>    <span class="token property">"@timestamp"</span><span class="token operator">:</span> <span class="token string">"2020-09-07T16:17:42.615Z"</span><span class="token punctuation">,</span>    <span class="token property">"@metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"beat"</span><span class="token operator">:</span> <span class="token string">"filebeat"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span>        <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.9.0"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"ecs"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.5.0"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"host"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"localhost.localdomain"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"agent"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"ephemeral_id"</span><span class="token operator">:</span> <span class="token string">"660a2bfb-9a56-43a8-ae93-788060f5d243"</span><span class="token punctuation">,</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"6a8ff370-52b5-4f89-ad9c-b6feecf938a9"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"filebeat"</span><span class="token punctuation">,</span>        <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.9.0"</span><span class="token punctuation">,</span>        <span class="token property">"hostname"</span><span class="token operator">:</span> <span class="token string">"localhost.localdomain"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"log"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"offset"</span><span class="token operator">:</span> <span class="token number">997322</span><span class="token punctuation">,</span>        <span class="token property">"file"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"/var/log/messages"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Sep  8 00:01:01 localhost systemd: Started Session 7 of user root."</span><span class="token punctuation">,</span>    <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"messages"</span><span class="token punctuation">,</span> <span class="token string">"syslog"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">{</span> # 这里由于filebeat配置文件中没有开启fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>这个选项<span class="token punctuation">,</span>所以我们定义的字段会在fields里面        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"system"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"input"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"log"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="定义-Filebeat-输出的-Json-数据"><a href="#定义-Filebeat-输出的-Json-数据" class="headerlink" title="定义 Filebeat 输出的 Json 数据"></a>定义 Filebeat 输出的 Json 数据</h1><p>我们除了可以自己自定义字段，还可以删除一些 filebeat 默认输出的字段，让日志数据更加易于查看</p><pre class="line-numbers language-json"><code class="language-json"># 定义filebeat配置文件<span class="token punctuation">,</span>过滤不需要的json数据filebeat.inputs<span class="token operator">:</span>- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  # json.keys_under_root<span class="token operator">:</span> <span class="token boolean">true</span> 开始json解析<span class="token punctuation">,</span>不是json格式的日志不要开启此选项  paths<span class="token operator">:</span>    - /var/log/messages  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"messages"</span><span class="token punctuation">,</span><span class="token string">"syslog"</span><span class="token punctuation">]</span>  fields<span class="token operator">:</span>    type<span class="token operator">:</span> system  fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>- type<span class="token operator">:</span> log  enabled<span class="token operator">:</span> <span class="token boolean">true</span>  paths<span class="token operator">:</span>    - /var/log/audit/audit.log  tags<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"audit"</span><span class="token punctuation">,</span><span class="token string">"syslog"</span><span class="token punctuation">]</span>  fields<span class="token operator">:</span>    type<span class="token operator">:</span> system  fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span>processors<span class="token operator">:</span>- drop_fields<span class="token operator">:</span>    fields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"input_type"</span><span class="token punctuation">,</span> <span class="token string">"ecs.version"</span><span class="token punctuation">,</span> <span class="token string">"host.name"</span><span class="token punctuation">,</span> <span class="token string">"agent"</span><span class="token punctuation">,</span> <span class="token string">"log.offset"</span><span class="token punctuation">]</span>    # 将这些字段丢弃output.console<span class="token operator">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看自定义之后的 json 数据</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"@timestamp"</span><span class="token operator">:</span> <span class="token string">"2020-09-07T17:37:59.500Z"</span><span class="token punctuation">,</span>    <span class="token property">"@metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"beat"</span><span class="token operator">:</span> <span class="token string">"filebeat"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span>        <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.9.0"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"messages"</span><span class="token punctuation">,</span> <span class="token string">"syslog"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"input"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"log"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span>    # fields_under_root<span class="token operator">:</span> <span class="token boolean">true</span> 将作为顶级字段    <span class="token property">"ecs"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"host"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"log"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"file"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"/var/log/messages"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Sep  8 01:35:28 localhost systemd-logind: Removed session 4."</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Logstash-消费-Redis-中的数据"><a href="#Logstash-消费-Redis-中的数据" class="headerlink" title="Logstash 消费 Redis 中的数据"></a>Logstash 消费 Redis 中的数据</h1><p>filebeat 将日志数据存储到 redis 之后，logstash 从 redis 读取日志数据就是非常简单的事情了</p><pre class="line-numbers language-json"><code class="language-json">cat /etc/logstash/conf.d/sys-from-redis.confinput <span class="token punctuation">{</span>  redis <span class="token punctuation">{</span>    host => <span class="token string">"10.10.110.194"</span>    port => <span class="token number">56379</span>    password => <span class="token string">"123456"</span>    db => <span class="token string">"0"</span>    data_type => <span class="token string">"list"</span>    batch_count => <span class="token string">"1"</span>    key => <span class="token string">"filebeat"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  if <span class="token punctuation">[</span>type<span class="token punctuation">]</span> == <span class="token string">"system"</span> <span class="token punctuation">{</span>    # 这里的匹配由filebeat输出的json数据格式来定义    if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"messages"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"filebeat-fromredis-messages-%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    else if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"audit"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"filebeat-fromredis-audit-%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Elasticsearch-查看数据"><a href="#Elasticsearch-查看数据" class="headerlink" title="Elasticsearch 查看数据"></a>Elasticsearch 查看数据</h1><p>索引的命名根据我们在 logstash 处理数据时的定义格式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f5600d8160a154a675742af.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入-Filebeat-架构简介&quot;&gt;&lt;a href=&quot;#引入-Filebeat-架构简介&quot; class=&quot;headerlink&quot; title=&quot;引入 Filebeat 架构简介&quot;&gt;&lt;/a&gt;引入 Filebeat 架构简介&lt;/h1&gt;&lt;p&gt;filebeat 代替 lo
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic 引入 Redis</title>
    <link href="https://www.missf.top/post/23bc2fbc.html"/>
    <id>https://www.missf.top/post/23bc2fbc.html</id>
    <published>2020-08-17T10:48:56.000Z</published>
    <updated>2021-01-20T10:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入-Redis-架构简介"><a href="#引入-Redis-架构简介" class="headerlink" title="引入 Redis 架构简介"></a>引入 Redis 架构简介</h1><p>logstash 分为 shipper(负责收集日志数据)和 indexer(负责对日志做过滤存储到ES)两个角色。当日志量达到一个量级之后，我们就不能继续使用 logstash 去收集和处理数据，由于 ES 的 HTTP API 处理能力有限，在日志写入频繁的情况下可能会超时、丢失，所以用队列来做缓冲在两个 logstash 角色之间可以引入 redis 或者 kafka。使用消息队列的方式可减少 ES 压力，队列起到缓冲作用，也可以一定程度保护数据不丢失。同时我们还能将所有收集到的日志统一在 logstash indexer 进行处理</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f51fb57160a154a6778fb68.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre class="line-numbers language-bash"><code class="language-bash">logstash 10.10.110.195    <span class="token comment" spellcheck="true"># logstash shipper 生产数据,将获取到的数据存到 redis</span>logstash + redis 10.10.110.194    <span class="token comment" spellcheck="true"># logstash indexer 消费 redis 中的日志数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="生产日志数据"><a href="#生产日志数据" class="headerlink" title="生产日志数据"></a>生产日志数据</h1><p>编写 logstash pipeline 配置文件，将收集到的日志数据存储到 redis</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  file <span class="token punctuation">{</span>    path => <span class="token punctuation">[</span><span class="token string">"/var/log/messages"</span><span class="token punctuation">]</span>    type => <span class="token string">"syslog"</span>    tags => <span class="token punctuation">[</span><span class="token string">"messages"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>    start_position => <span class="token string">"beginning"</span>  <span class="token punctuation">}</span>  file <span class="token punctuation">{</span>    path => <span class="token punctuation">[</span><span class="token string">"/var/log/audit/audit.log"</span><span class="token punctuation">]</span>    type => <span class="token string">"syslog"</span>    tags => <span class="token punctuation">[</span><span class="token string">"audit"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>    start_position => <span class="token string">"beginning"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  redis <span class="token punctuation">{</span>    host => <span class="token punctuation">[</span><span class="token string">"10.10.110.194:56379"</span><span class="token punctuation">]</span>    password => <span class="token string">"123456"</span>    db => <span class="token string">"0"</span>    data_type => <span class="token string">"list"</span>    key => <span class="token string">"logstash"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动 logstash 进行收集日志存储到 redis</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/share/logstash/bin/logstash -rf /etc/logstash/conf.d/syslog-toredis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Redis查看日志数据"><a href="#Redis查看日志数据" class="headerlink" title="Redis查看日志数据"></a>Redis查看日志数据</h1><p>logstash 在收集到日志数据并且添加上标签和类型然后存储到 redis，我们可以返回列表的长度来得知日志数据是否被存储到 redis</p><p><img src="https://pic.imgdb.cn/item/5f55cd21160a154a674bc848.jpg" alt=""></p><h1 id="消费日志数据"><a href="#消费日志数据" class="headerlink" title="消费日志数据"></a>消费日志数据</h1><p>编写 logstash pipeline 配置文件，将 redis 中的日志数据存储到 ES</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  redis <span class="token punctuation">{</span>    host => <span class="token string">"10.10.110.194"</span>    port => <span class="token number">56379</span>    password => <span class="token string">"123456"</span>    db => <span class="token string">"0"</span>    data_type => <span class="token string">"list"</span>    key => <span class="token string">"logstash"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  if <span class="token punctuation">[</span>type<span class="token punctuation">]</span> == <span class="token string">"syslog"</span> <span class="token punctuation">{</span>    if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"messages"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"syslog-fromredis-messages-%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    else if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"audit"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"syslog-fromredis-audit-%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Redis-查看消费的数据"><a href="#Redis-查看消费的数据" class="headerlink" title="Redis 查看消费的数据"></a>Redis 查看消费的数据</h1><p>日志数据被消费完之后就代表已经写入到 ES</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># redis 中的 key 会全部存到 ES 中(日志数据被消费完)</span>127.0.0.1:56379<span class="token operator">></span> llen logstash<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 7041127.0.0.1:56379<span class="token operator">></span> llen logstash<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5791127.0.0.1:56379<span class="token operator">></span> llen logstash<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4541127.0.0.1:56379<span class="token operator">></span> llen logstash<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3041127.0.0.1:56379<span class="token operator">></span> llen logstash<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1666127.0.0.1:56379<span class="token operator">></span> llen logstash<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0127.0.0.1:56379<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入-Redis-架构简介&quot;&gt;&lt;a href=&quot;#引入-Redis-架构简介&quot; class=&quot;headerlink&quot; title=&quot;引入 Redis 架构简介&quot;&gt;&lt;/a&gt;引入 Redis 架构简介&lt;/h1&gt;&lt;p&gt;logstash 分为 shipper(负责收集日志
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Kibana 展示系统日志</title>
    <link href="https://www.missf.top/post/c802a07c.html"/>
    <id>https://www.missf.top/post/c802a07c.html</id>
    <published>2020-08-16T10:39:44.000Z</published>
    <updated>2021-01-20T10:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写-logstash-pipeline-配置文件"><a href="#编写-logstash-pipeline-配置文件" class="headerlink" title="编写 logstash pipeline 配置文件"></a>编写 logstash pipeline 配置文件</h1><p>定义日志收集、过滤、存储的方式</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  file <span class="token punctuation">{</span>    path => <span class="token punctuation">[</span><span class="token string">"/var/log/messages"</span><span class="token punctuation">]</span>    type => <span class="token string">"syslog"</span>    tags => <span class="token punctuation">[</span><span class="token string">"messages"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>    start_position => <span class="token string">"beginning"</span>    # 从文件开头读取    <span class="token punctuation">}</span>  file <span class="token punctuation">{</span>    path => <span class="token punctuation">[</span><span class="token string">"/var/log/audit/audit.log"</span><span class="token punctuation">]</span>    type => <span class="token string">"syslog"</span>    tags => <span class="token punctuation">[</span><span class="token string">"audit"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>    start_position => <span class="token string">"beginning"</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  if <span class="token punctuation">[</span>type<span class="token punctuation">]</span> == <span class="token string">"syslog"</span> <span class="token punctuation">{</span>    if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"messages"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>    # 存储带ES        index  => <span class="token string">"syslog-messages-%{+YYYY.MM.dd}"</span>    # index的命名格式      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    else if <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> == <span class="token string">"audit"</span> <span class="token punctuation">{</span>      elasticsearch <span class="token punctuation">{</span>        hosts  => <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.192:9200"</span><span class="token punctuation">,</span><span class="token string">"http://10.10.110.193:9200"</span><span class="token punctuation">]</span>        index  => <span class="token string">"syslog-audit-%{+YYYY.MM.dd}"</span>      <span class="token punctuation">}</span>      stdout <span class="token punctuation">{</span> codec=> rubydebug <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Logstash-收集日志存储到-ES"><a href="#Logstash-收集日志存储到-ES" class="headerlink" title="Logstash 收集日志存储到 ES"></a>Logstash 收集日志存储到 ES</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 logstash,systemctl 启动方式可以指定配置文件</span>/usr/share/logstash/bin/logstash -rf /etc/logstash/conf.d/syslog.conf<span class="token comment" spellcheck="true"># logstash 常用参数</span>-n 指定logstash实例的名称,默认为当前主机名-f 指定启动配置文件-e 指定直接执行的配置文件内容,可以不指定-f参数了-r 检测配置文件变化,自动重新加载-t 检查配置的语法是否正确并退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Elasticsearch-查看数据"><a href="#Elasticsearch-查看数据" class="headerlink" title="Elasticsearch 查看数据"></a>Elasticsearch 查看数据</h1><p>索引的命名格式按日期去分割</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f50be45160a154a6732f27c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="将-ES-的日志索引到-Kibana"><a href="#将-ES-的日志索引到-Kibana" class="headerlink" title="将 ES 的日志索引到 Kibana"></a>将 ES 的日志索引到 Kibana</h1><p>Kibana 的配置文件指定 ES 的地址，使用正则匹配去创建索引</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f50c769160a154a67356974.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>配置时间过滤器字段</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f51e97a160a154a67727f8b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Kibana-展示日志数据"><a href="#Kibana-展示日志数据" class="headerlink" title="Kibana 展示日志数据"></a>Kibana 展示日志数据</h1><p>可以根据日志数据的字段去查看指定的信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f51f25f160a154a6776bac0.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编写-logstash-pipeline-配置文件&quot;&gt;&lt;a href=&quot;#编写-logstash-pipeline-配置文件&quot; class=&quot;headerlink&quot; title=&quot;编写 logstash pipeline 配置文件&quot;&gt;&lt;/a&gt;编写 logstash
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Kibana</title>
    <link href="https://www.missf.top/post/e26112db.html"/>
    <id>https://www.missf.top/post/e26112db.html</id>
    <published>2020-08-14T07:56:54.000Z</published>
    <updated>2021-01-20T10:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kibana-简述"><a href="#Kibana-简述" class="headerlink" title="Kibana 简述"></a>Kibana 简述</h1><p>Kibana 是一个针对 Elasticsearch 的开源分析及可视化平台，用来搜索、查看交互存储在 Elasticsearch 索引中的数据。使用 Kibana，可以通过各种图表进行高级数据分析及展示。Kibana 让海量数据更容易理解，它操作简单，基于浏览器的用户界面可以快速创建仪表板(dashboard)实时显示 Elasticsearch 查询动态。设置 Kibana 非常简单，无需编码或者额外的基础架构，就可以完成 Kibana 安装并启动 Elasticsearch 索引监测</p><h1 id="Kibana-安装配置"><a href="#Kibana-安装配置" class="headerlink" title="Kibana 安装配置"></a>Kibana 安装配置</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载 Kibana</span><span class="token function">wget</span> https://artifacts.elastic.co/downloads/kibana/kibana-7.8.1-x86_64.rpm<span class="token comment" spellcheck="true"># 安装</span>shasum -a 512 kibana-7.8.1-x86_64.rpmrpm --install kibana-7.8.1-x86_64.rpm<span class="token comment" spellcheck="true"># 修改 Kibana 配置文件</span><span class="token function">grep</span> -v <span class="token string">"^#"</span> /etc/kibana/kibana.ymlserver.port: 5601server.host: <span class="token string">"127.0.0.1"</span>elasticsearch.hosts: <span class="token punctuation">[</span><span class="token string">"http://10.10.110.191:9200"</span><span class="token punctuation">]</span>i18n.locale: <span class="token string">"zh-CN"</span><span class="token comment" spellcheck="true"># 启动 Kibana</span>systemctl start kibana.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置-Nginx-代理-Kibana"><a href="#配置-Nginx-代理-Kibana" class="headerlink" title="配置 Nginx 代理 Kibana"></a>配置 Nginx 代理 Kibana</h1><p>配置 Nginx 反向代理实现鉴权</p><pre class="line-numbers language-bash"><code class="language-bash">vim /usr/local/nginx/conf/nginx.confserver <span class="token punctuation">{</span>      listen 9090<span class="token punctuation">;</span>      server_name localhost<span class="token punctuation">;</span>      location / <span class="token punctuation">{</span>        auth_basic <span class="token string">"Restricted Access"</span><span class="token punctuation">;</span>        auth_basic_user_file /usr/local/nginx/conf/passwd.db<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># 账号密码文件</span>        proxy_pass http://127.0.0.1:5601<span class="token punctuation">;</span>        proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置验证登录账号密码</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 需要安装 httpd-tools 工具,文件里的密码是密文的</span>htpasswd -c /usr/local/nginx/conf/passwd.db admin    <span class="token comment" spellcheck="true"># 连续输入两次密码</span><span class="token comment" spellcheck="true"># 测试本机 kibana 能否连接,如果本机都不能连接,那么 Nginx 代理就没有意义</span>curl -L -u admin:12345678 http://127.0.0.1:5601<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="登录-Kibana"><a href="#登录-Kibana" class="headerlink" title="登录 Kibana"></a>登录 Kibana</h1><p>登录 kibana 的地址</p><pre class="line-numbers language-bash"><code class="language-bash">http://10.10.110.194:9090/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Nginx 账号密码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f50a2a9160a154a672c41a2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>kibana web 页面</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f50a1ee160a154a672c0902.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kibana-简述&quot;&gt;&lt;a href=&quot;#Kibana-简述&quot; class=&quot;headerlink&quot; title=&quot;Kibana 简述&quot;&gt;&lt;/a&gt;Kibana 简述&lt;/h1&gt;&lt;p&gt;Kibana 是一个针对 Elasticsearch 的开源分析及可视化平台，用来搜
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Logstash</title>
    <link href="https://www.missf.top/post/fe947601.html"/>
    <id>https://www.missf.top/post/fe947601.html</id>
    <published>2020-08-11T07:04:57.000Z</published>
    <updated>2020-09-28T03:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Logstash-概述"><a href="#Logstash-概述" class="headerlink" title="Logstash 概述"></a>Logstash 概述</h1><p>logstash 是 elasticsearch 的数据管道，负责对数据源进行处理。工作原理分别是输入、过滤、输出。其中 input(负责从数据源采集数据)和 output(将数据传输到目的地)是必要的，filter(将数据修改为你指定的格式或内容)是非必要的。logstash 是插件式管理模式，在输入、过滤、输出以及编码过程中都可以使用插件进行定制，Logstash 社区有超过 200 种可用插件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f4ca600160a154a67c1320d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Logstash-安装"><a href="#Logstash-安装" class="headerlink" title="Logstash 安装"></a>Logstash 安装</h1><p>这里使用 yum 是因为二进制安装的 jdk，在 Logstash 启动时会报 could not find java</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装jdk</span>yum <span class="token function">install</span> -y java-11-openjdk java-11-openjdk-devel java-11-openjdk-headless<span class="token comment" spellcheck="true"># 下载logstash</span><span class="token function">wget</span> https://artifacts.elastic.co/downloads/logstash/logstash-7.8.1.rpm<span class="token comment" spellcheck="true"># 安装logstash</span>yum <span class="token function">install</span> -y logstash-7.8.1.rpm<span class="token comment" spellcheck="true"># 修改启动分配内存</span>vim /etc/logstash/jvm.options-Xms512m-Xmx512m<span class="token comment" spellcheck="true"># 第一个logstash示例</span><span class="token function">cd</span> logstash Installation directorybin/logstash -e <span class="token string">'input { stdin { } } output { stdout {} }'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 执行结果如下</p><p><img src="https://pic.imgdb.cn/item/5f4db451160a154a67703955.jpg" alt=""></p><h1 id="Logstash-配置详解"><a href="#Logstash-配置详解" class="headerlink" title="Logstash 配置详解"></a>Logstash 配置详解</h1><p>Logstash 的配置有两个必须元素(input和output)和一个可选元素(filter)</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span> # 输入   stdin <span class="token punctuation">{</span>     ... # 标准输入  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span> # 过滤  ...    # 对数据进行分割、截取等处理 <span class="token punctuation">}</span>output <span class="token punctuation">{</span> # 输出   stdout <span class="token punctuation">{</span>    ...  # 标准输出  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输入</p><p>采集各种样式、大小和来源的数据，数据往往以各种各样的形式，或分散或集中地存在于不同的系统中</p><p> Logstash支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件</p><p>能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种AWS服务采集数据</p></blockquote><blockquote><p> 过滤</p><p>实时解析和转换数据，Logstash过滤器能够解析各个事件</p><p>识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松更快速地分析和实现商业价值</p></blockquote><blockquote><p>输出</p><p>Logstash提供众多输出选择，你可以将数据发送到指定的地方，并且能够灵活地解锁众多下游用例</p></blockquote><h1 id="输入插件-Stdin-示例"><a href="#输入插件-Stdin-示例" class="headerlink" title="输入插件 Stdin 示例"></a>输入插件 Stdin 示例</h1><p>从标准输入读取数据输出到标准输出</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  stdin <span class="token punctuation">{</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>    codec => rubydebug   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json">mwj<span class="token punctuation">{</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-12T18<span class="token operator">:</span><span class="token number">36</span><span class="token operator">:</span><span class="token number">32</span>.683Z<span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"mwj"</span><span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">}</span>test data      <span class="token punctuation">{</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-12T18<span class="token operator">:</span><span class="token number">36</span><span class="token operator">:</span><span class="token number">47</span>.691Z<span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"test data"</span><span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="输入插件-File-示例"><a href="#输入插件-File-示例" class="headerlink" title="输入插件 File 示例"></a>输入插件 File 示例</h1><p>从文件中读取数据，输出到标准输出</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  file <span class="token punctuation">{</span>    # 调用file这个插件<span class="token punctuation">,</span>logstash社区有非常多的插件可以供我们使用    path =><span class="token string">"/var/log/messages"</span>    # 数据源来自这个文件的内容    tags =><span class="token string">"messages"</span>    # 打标签    type =><span class="token string">"syslog"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>    codec => rubydebug   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>          <span class="token string">"type"</span> => <span class="token string">"syslog"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-13T11<span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">45</span>.031Z<span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">,</span>          <span class="token string">"path"</span> => <span class="token string">"/var/log/messages"</span><span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>          <span class="token string">"tags"</span> => <span class="token punctuation">[</span>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token string">"messages"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"Aug 13 19:41:44 localhost yum[86466]: Installed: 1:nginx-mod-http-image-filter-1.16.1-1.el7.x86_64"</span><span class="token punctuation">}</span><span class="token punctuation">{</span>          <span class="token string">"type"</span> => <span class="token string">"syslog"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-13T11<span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">45</span>.032Z<span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">,</span>          <span class="token string">"path"</span> => <span class="token string">"/var/log/messages"</span><span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>          <span class="token string">"tags"</span> => <span class="token punctuation">[</span>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token string">"messages"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"Aug 13 19:41:44 localhost yum[86466]: Installed: 1:nginx-all-modules-1.16.1-1.el7.noarch"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="输入插件-TCP-示例"><a href="#输入插件-TCP-示例" class="headerlink" title="输入插件 TCP 示例"></a>输入插件 TCP 示例</h1><p>logstash 从本机端口读取数据，其他机器通过 nc 工具发送数据到 logstash 指定的端口</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  tcp <span class="token punctuation">{</span>    port =><span class="token number">12345</span>    # 监听<span class="token number">12345</span>端口    type =><span class="token string">"nc"</span>        # 通过nc工具使用tcp/udp连接去发送网络数据给logstash  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>    codec => rubydebug   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">,</span>          <span class="token string">"type"</span> => <span class="token string">"nc"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-13T06<span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">13</span>.448Z<span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"10.10.110.191"</span><span class="token punctuation">,</span>          <span class="token string">"port"</span> => <span class="token number">35228</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"we"</span>    # logstash接收到其他机器nc工具发送过来的信息(nc <span class="token number">10.10</span>.<span class="token number">110.194</span> <span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">{</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">,</span>          <span class="token string">"type"</span> => <span class="token string">"nc"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-13T06<span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">40</span>.148Z<span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"10.10.110.191"</span><span class="token punctuation">,</span>          <span class="token string">"port"</span> => <span class="token number">35228</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"test"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编解码插件-Json-示例"><a href="#编解码插件-Json-示例" class="headerlink" title="编解码插件 Json 示例"></a>编解码插件 Json 示例</h1><p>只有输入 json 格式的数据才会被成功编解码，不是 json 格式的数据 logstash 不处理</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  stdin <span class="token punctuation">{</span>    codec => json <span class="token punctuation">{</span>    charset => <span class="token punctuation">[</span><span class="token string">"UTF-8"</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>  codec => rubydebug   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"孙七"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span><span class="token property">"mail"</span><span class="token operator">:</span> <span class="token string">"555@qq.com"</span><span class="token punctuation">,</span><span class="token property">"hobby"</span><span class="token operator">:</span><span class="token string">"听音乐、看电影"</span><span class="token punctuation">}</span><span class="token punctuation">{</span>         <span class="token string">"hobby"</span> => <span class="token string">"听音乐、看电影"</span><span class="token punctuation">,</span>          <span class="token string">"name"</span> => <span class="token string">"孙七"</span><span class="token punctuation">,</span>          <span class="token string">"mail"</span> => <span class="token string">"555@qq.com"</span><span class="token punctuation">,</span>           <span class="token string">"age"</span> => <span class="token number">24</span><span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">09</span>-01T14<span class="token operator">:</span><span class="token number">27</span><span class="token operator">:</span><span class="token number">24</span>.066Z<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编解码插件-Multline-示例"><a href="#编解码插件-Multline-示例" class="headerlink" title="编解码插件 Multline 示例"></a>编解码插件 Multline 示例</h1><p>multline 会将不是以字母开头的行合并到上一行(next是合并到下一行)，下面模拟 java 日志报错</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  stdin <span class="token punctuation">{</span>    codec => multiline <span class="token punctuation">{</span>    pattern => <span class="token string">"^\s"</span>    what => <span class="token string">"previous"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>  codec => rubydebug   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> <span class="token number">2020</span>-<span class="token number">08</span>-<span class="token number">13</span> <span class="token number">15</span><span class="token operator">:</span><span class="token number">56</span><span class="token operator">:</span><span class="token number">53</span><span class="token punctuation">,</span><span class="token number">195</span> --AsyncResolver-bootstrap-executor<span class="token number">-0</span>--    # 模拟java报错信息      at com.curre      at org.sprin      at org.sprin<span class="token punctuation">{</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">09</span>-01T14<span class="token operator">:</span><span class="token number">36</span><span class="token operator">:</span><span class="token number">50</span>.642Z<span class="token punctuation">,</span>          <span class="token string">"tags"</span> => <span class="token punctuation">[</span>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token string">"multiline"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"[INFO] 2020-08-13 15:56:53,195 --AsyncResolver-bootstrap-executor-0--\n      at com.curre\n      at org.sprin\n      at org.sprin"</span><span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="过滤插件-Json-示例"><a href="#过滤插件-Json-示例" class="headerlink" title="过滤插件 Json 示例"></a>过滤插件 Json 示例</h1><p>将 json 数据做过滤放在 content 字段里面</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  stdin <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span>  json <span class="token punctuation">{</span>    source => <span class="token string">"message"</span>    target => <span class="token string">"content"</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>    codec => rubydebug  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"request"</span><span class="token operator">:</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token property">"status"</span><span class="token operator">:</span><span class="token string">"404"</span><span class="token punctuation">,</span> <span class="token property">"bytes"</span><span class="token operator">:</span><span class="token string">"563"</span><span class="token punctuation">}</span>    # 数据源<span class="token punctuation">{</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-13T09<span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">26</span>.702Z<span class="token punctuation">,</span>       <span class="token string">"content"</span> => <span class="token punctuation">{</span>        <span class="token string">"request"</span> => <span class="token string">"get"</span><span class="token punctuation">,</span>          <span class="token string">"bytes"</span> => <span class="token string">"563"</span><span class="token punctuation">,</span>         <span class="token string">"status"</span> => <span class="token string">"404"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token property">"{\"request\":\"get\", \"status\":\"404\", \"bytes\"</span><span class="token operator">:</span>\<span class="token string">"563\"}"</span><span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="过滤插件-Kv-示例"><a href="#过滤插件-Kv-示例" class="headerlink" title="过滤插件 Kv 示例"></a>过滤插件 Kv 示例</h1><p>以 &amp; 和 ? 作为分隔符，得到 key=value 形式的数据</p><pre class="line-numbers language-json"><code class="language-json">input <span class="token punctuation">{</span>  stdin <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>filter <span class="token punctuation">{</span>  kv <span class="token punctuation">{</span>    field_split => "&amp;?<span class="token property">"              # 以&amp;和?作为分隔符,得到key=value的形式    field_split_pattern => "</span><span class="token operator">:</span>+"      # 以一个或者多个<span class="token operator">:</span>作为分隔符  <span class="token punctuation">}</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span>  stdout <span class="token punctuation">{</span>    codec => rubydebug  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下</p><pre class="line-numbers language-json"><code class="language-json">pin=<span class="token number">12345</span>~<span class="token number">0</span>&amp;d=<span class="token number">123</span>&amp;e=foo@bar.com&amp;oq=bo?oi=bo&amp;ss=<span class="token number">12345</span><span class="token operator">:</span>    # 数据源<span class="token punctuation">{</span>             <span class="token string">"d"</span> => <span class="token string">"123"</span><span class="token punctuation">,</span>           <span class="token string">"pin"</span> => <span class="token string">"12345~0"</span><span class="token punctuation">,</span>            <span class="token string">"ss"</span> => <span class="token string">"12345:"</span><span class="token punctuation">,</span>            <span class="token string">"oq"</span> => <span class="token string">"bo"</span><span class="token punctuation">,</span>            <span class="token string">"oi"</span> => <span class="token string">"bo"</span><span class="token punctuation">,</span>             <span class="token string">"e"</span> => <span class="token string">"foo@bar.com"</span><span class="token punctuation">,</span>    <span class="token string">"@timestamp"</span> => <span class="token number">2020</span>-<span class="token number">08</span>-13T09<span class="token operator">:</span><span class="token number">31</span><span class="token operator">:</span><span class="token number">41</span>.881Z<span class="token punctuation">,</span>          <span class="token string">"host"</span> => <span class="token string">"localhost.localdomain"</span><span class="token punctuation">,</span>       <span class="token string">"message"</span> => <span class="token string">"pin=12345~0&amp;d=123&amp;e=foo@bar.com&amp;oq=bo?oi=bo&amp;ss=12345:"</span><span class="token punctuation">,</span>      <span class="token string">"@version"</span> => <span class="token string">"1"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="输出插件-ES-示例"><a href="#输出插件-ES-示例" class="headerlink" title="输出插件 ES 示例"></a>输出插件 ES 示例</h1><p>logstash 将日志输出到 ES 节点，存储到 missf 这个 index 并且以时间去命名</p><pre class="line-numbers language-json"><code class="language-json">output <span class="token punctuation">{</span>  elasticsearch <span class="token punctuation">{</span>    hosts => <span class="token string">"localhost:9200"</span>    index => <span class="token string">"missf-%{+YYYY.MM.dd}"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Logstash-概述&quot;&gt;&lt;a href=&quot;#Logstash-概述&quot; class=&quot;headerlink&quot; title=&quot;Logstash 概述&quot;&gt;&lt;/a&gt;Logstash 概述&lt;/h1&gt;&lt;p&gt;logstash 是 elasticsearch 的数据管道，负责对
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Elasticsearch</title>
    <link href="https://www.missf.top/post/1abc58c4.html"/>
    <id>https://www.missf.top/post/1abc58c4.html</id>
    <published>2020-08-05T10:26:09.000Z</published>
    <updated>2021-01-20T10:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h1><p>Elasticsearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 语言开发，并作为 Apache 许可条款下的开放源代码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索、稳定、可靠、快速、使用方便</p><p>我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用 JSON 通过 HTTP 来索引数据，我们希望搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多用户，我们希望建立一个云的解决方案。因此我们利用 Elasticsearch 来解决所有这些问题及可能出现的更多其它问题</p><h1 id="Elasticsearch-集群部署"><a href="#Elasticsearch-集群部署" class="headerlink" title="Elasticsearch 集群部署"></a>Elasticsearch 集群部署</h1><p>Elasticsearch 的发展是非常快速的，所以在 ES5.0 之前，ELK 的各个版本都不统一，出现了版本号混乱的状态，所以从 5.0 开始，所有 Elastic Stack 中的项目全部统一版本号。目前最新版本是 7.8.1</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 环境准备</span>ES1 10.10.110.191ES2 10.10.110.192ES3 10.10.110.193<span class="token comment" spellcheck="true"># 下载 elasticsearch 和校验文件</span><span class="token function">wget</span> https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.1-x86_64.rpm<span class="token function">wget</span> https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.1-x86_64.rpm.sha512<span class="token comment" spellcheck="true"># 安装 elasticsearch</span>shasum -a 512 -c elasticsearch-7.8.1-x86_64.rpm.sha512yum <span class="token function">install</span> -y elasticsearch-7.8.1-x86_64.rpm<span class="token comment" spellcheck="true"># 修改 jvm 启动参数,根据自己机器决定</span>vim /etc/elasticsearch/jvm.options-Xms512m    <span class="token comment" spellcheck="true"># 确保 Xmx 和 Xms 的大小是相同的，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源</span>-Xmx512m<span class="token comment" spellcheck="true"># 修改进程在 VMAs(虚拟内存区域)创建内存映射最大数量</span><span class="token keyword">echo</span> <span class="token string">"vm.max_map_count=655360"</span> <span class="token operator">>></span> /etc/sysctl.conf <span class="token operator">&amp;&amp;</span> sysctl -p<span class="token comment" spellcheck="true"># 修改 elasticsearch 配置文件</span><span class="token function">grep</span> -v <span class="token string">'^#'</span> /etc/elasticsearch/elasticsearch.ymlcluster.name: elk-cluster    <span class="token comment" spellcheck="true"># 集群名称,所有节点一样</span>node.name: node-1    <span class="token comment" spellcheck="true"># 不同节点,分别用 node-1/node-2/node-3...</span>path.data: /var/lib/elasticsearch    <span class="token comment" spellcheck="true"># 数据目录,如果加入集群失败可以清空数据目录再重启服务</span>path.logs: /var/log/elasticsearch    <span class="token comment" spellcheck="true"># 日志目录</span>network.host: 10.10.110.191        <span class="token comment" spellcheck="true"># 不同节点,分别用10.10.110......</span>http.port: 9200        <span class="token comment" spellcheck="true"># 监听端口</span>discovery.seed_hosts: <span class="token punctuation">[</span><span class="token string">"10.10.110.191"</span>, <span class="token string">"10.10.110.192"</span>, <span class="token string">"10.10.110.193"</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 集群发现,可以写成 10.10.110.191:9200</span>cluster.initial_master_nodes: <span class="token punctuation">[</span><span class="token string">"node-1"</span>, <span class="token string">"node-2"</span>, <span class="token string">"node-3"</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 指定可以成为 master 的节点,此参数只有在初始化集群时生效</span><span class="token comment" spellcheck="true"># 启动 elasticsearch 服务</span>systemctl start elasticsearch.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Elasticsearch-集群常用查询"><a href="#Elasticsearch-集群常用查询" class="headerlink" title="Elasticsearch 集群常用查询"></a>Elasticsearch 集群常用查询</h1><p>查看集群状态</p><pre class="line-numbers language-json"><code class="language-json">curl -X GET http<span class="token operator">:</span>//<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/_cluster/health?pretty# 响应<span class="token punctuation">{</span>  <span class="token property">"cluster_name"</span> <span class="token operator">:</span> <span class="token string">"elk-cluster"</span><span class="token punctuation">,</span>  <span class="token property">"status"</span> <span class="token operator">:</span> <span class="token string">"green"</span><span class="token punctuation">,</span>    # 集群状态红绿灯<span class="token punctuation">,</span>绿<span class="token operator">:</span>健康<span class="token punctuation">,</span>黄<span class="token operator">:</span>亚健康<span class="token punctuation">,</span>红<span class="token operator">:</span>病态  <span class="token property">"timed_out"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"number_of_nodes"</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token property">"number_of_data_nodes"</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token property">"active_primary_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"active_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"relocating_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"initializing_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"unassigned_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"delayed_unassigned_shards"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"number_of_pending_tasks"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"number_of_in_flight_fetch"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"task_max_waiting_in_queue_millis"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"active_shards_percent_as_number"</span> <span class="token operator">:</span> <span class="token number">100.0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看节点状态</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">'http://10.10.110.191:9200/_cat/nodes?v'</span>ip            heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name10.10.110.191           62          93   0    0.00    0.01     0.05 dilmrt    -      node-110.10.110.193           62          74   0    0.00    0.01     0.05 dilmrt    *      node-3    <span class="token comment" spellcheck="true"># *代表当前节点是master</span>10.10.110.192           70          75   0    0.00    0.01     0.05 dilmrt    -      node-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询节点所有索引</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">'http://10.10.110.191:9200/_cat/indices?v'</span>health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.sizegreen  <span class="token function">open</span>   data  njHuT0XvSOa2NHPJM3Aj-g   1   1          3            0     19.5kb          9.7kb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询一个索引所有数据</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">'http://10.10.110.191:9200/data/_search/?pretty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Elasticsearch-head-安装"><a href="#Elasticsearch-head-安装" class="headerlink" title="Elasticsearch-head 安装"></a>Elasticsearch-head 安装</h1><p>由于 ES 官方并没有为 ES 提供界面管理工具，仅仅是提供了后台的服务。elasticsearch-head 是一个为 ES 开发的一个页面客户端工具，其源码托管于 GitHub，地址为：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p><p>elasticsearch-head 提供了四种安装方式：</p><ul><li>源码安装通过npm run start启动(不推荐)</li><li>通过docker安装(推荐)</li><li>通过chrome插件安装(推荐)</li><li>通过ES的plugin方式安装(不推荐)</li></ul><p>通过 Docker 安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 拉取镜像</span>docker pull mobz/elasticsearch-head:5<span class="token comment" spellcheck="true"># 启动容器</span>docker run -itd --name <span class="token string">"elasticsearch-head"</span> -p 9100:9100 -v elasticsearch_head:/usr/src/app --restart always mobz/elasticsearch-head:5<span class="token comment" spellcheck="true"># 由于前后端分离开发,所以会存在跨域问题,需要在服务端做 CORS 的配置</span>vim /etc/elasticsearch/elasticsearch.ymlhttp.cors.enabled: <span class="token boolean">true</span>http.cors.allow-origin: <span class="token string">"*"</span><span class="token comment" spellcheck="true"># Web 访问</span>http://10.10.110.191:9100/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Elasticsearch Head 数据浏览不显示数据，使用浏览器按 F12 查看发现 406 Not Acceptable 错误，出现这个错误是因为后台返回的数据是 json 格式前台无法解析，解决方法如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 找到 docker 数据卷在宿主机上的目录</span>docker volume inspect elasticsearch_head<span class="token comment" spellcheck="true"># 修改数据卷目录下 _site/vendor.js 文件</span>contentType: <span class="token string">"application/x-www-form-urlencoded"</span> 修改为 contentType: <span class="token string">"application/json;charset=UTF-8"</span>var inspectData <span class="token operator">=</span> s.contentType <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"application/x-www-form-urlencoded"</span> <span class="token operator">&amp;&amp;</span> 修改为 var inspectData <span class="token operator">=</span> s.contentType <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"application/json;charset=UTF-8"</span> <span class="token operator">&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Elasticsearch-基本概念"><a href="#Elasticsearch-基本概念" class="headerlink" title="Elasticsearch 基本概念"></a>Elasticsearch 基本概念</h1><p>索引(index)是 Elasticsearch 存放数据的地方，可以理解为关系型数据库的数据库。我们的数据被存储和索引在分片(shards)中，索引只是一个把一个或多个分片分组在一起的逻辑空间。索引的结构是为快速有效的全文索引准备的，索引名称必须是小写，并且不能用下划线开头</p><p>类型(type)用于区分同一个索引下不同的数据类型，相当于关系型数据库中的表。在 Elasticsearch 中，我们使用相同类型的文档表示相同的 “事物”，因为他们的数据结构也是相同的。每个类型都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射会告诉 Elasticsearch 不同的文档如何被索引(ES6.0之后一个索引只能存在一种类型)</p><p>文档(document)是 ElasticSearch 中存储的实体数据，一个文档相当于数据库表中的一行记录。在 Elasticsearch 中，文档这个术语有着特殊含义。它特指最顶层结构或者根对象(root object)序列化成的 JSON 数据(以唯一ID标识并存储于Elasticsearch中)</p><p>关系型数据库与 Elasticsearch 的概念类比如下</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">Relational DB</td><td align="center">Databases</td><td align="center">Tables</td><td align="center">Rows</td><td align="center">Columns</td></tr><tr><td align="center">Elasticsearch</td><td align="center">Indices</td><td align="center">Types</td><td align="center">Documents</td><td align="center">Fields</td></tr></tbody></table><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>在 Elasticsearch 中，提供了功能丰富的 RESTful API 的操作，包括基本的 CRUD、创建索引、删除索引等操作。RESTful 是统一规范的 http 接口，任何语言都可以使用。我们可以直接使用 web 客户端(postman)来测试，甚至还可以使用 Linux 上的 curl 工具测试，不需要自己写程序来调用 Elasticsearch 服务</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Elasticsearch RESTful 操作数据的风格</span>curl -X <span class="token operator">&lt;</span>verb<span class="token operator">></span> <span class="token string">'&lt;protocol>://&lt;host>:&lt;port>/&lt;path>?&lt;query_string> -d &lt;body>'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>verb：HTTP 方法，如 GET、POST、PUT、HEAD、DELETE</p></blockquote><blockquote><p>host：ES 集群中的任意节点主机名</p></blockquote><blockquote><p>port：ES HTTP 服务端口默认 9200</p></blockquote><blockquote><p>path：索引路径</p></blockquote><blockquote><p>query_string：可选的查询请求参数，例如 ?pretty 参数将格式化输出 JSON 数据</p></blockquote><blockquote><p>-d：一个 GET 的 JSON 格式请求主体</p></blockquote><blockquote><p>body：自己写的 JSON 格式的请求主体</p></blockquote><h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><p>在 Lucene 中创建索引是需要定义字段名称以及字段的类型，在 Elasticsearch 中提供了非结构化的索引，就是不需要创建索引结构，即可写入数据到索引中，实际上在 Elasticsearch 底层会进行结构化操作，此操作对用户是透明的</p><pre class="line-numbers language-apl"><code class="language-apl"><span class="token comment" spellcheck="true"># 创建一个 data 的空索引</span>curl <span class="token function">-</span>X PUT <span class="token string">'10.10.110.191:9200/data'</span><span class="token comment" spellcheck="true"># 删除索引</span>curl <span class="token function">-</span>X DELETE <span class="token string">'10.10.110.191:9200/data'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>URL 规则：POST /索引/类型/id</p><pre class="line-numbers language-json"><code class="language-json"># 往data这个索引下的user类型中插入一条ID为<span class="token number">1</span>的数据<span class="token punctuation">,</span>?pretty是以json格式返回数据curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/<span class="token number">1</span>?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"mowenjie"</span><span class="token punctuation">,</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token string">"DevOps"</span><span class="token punctuation">,</span><span class="token property">"base"</span><span class="token operator">:</span> <span class="token string">"sz"</span><span class="token punctuation">}</span>'# 响应<span class="token punctuation">{</span>  <span class="token property">"_index"</span> <span class="token operator">:</span> <span class="token string">"data"</span><span class="token punctuation">,</span>  <span class="token property">"_type"</span> <span class="token operator">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>  <span class="token property">"_id"</span> <span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>  <span class="token property">"_version"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token property">"result"</span> <span class="token operator">:</span> <span class="token string">"created"</span><span class="token punctuation">,</span>  <span class="token property">"_shards"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"total"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token property">"successful"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"failed"</span> <span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"_seq_no"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"_primary_term"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span># 不指定ID插入数据会自动生成IDcurl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"missf"</span><span class="token punctuation">,</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token string">"linux"</span><span class="token punctuation">,</span><span class="token property">"base"</span><span class="token operator">:</span> <span class="token string">"sz"</span><span class="token punctuation">}</span>'# 响应<span class="token punctuation">{</span>  <span class="token property">"_index"</span> <span class="token operator">:</span> <span class="token string">"data"</span><span class="token punctuation">,</span>  <span class="token property">"_type"</span> <span class="token operator">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>  <span class="token property">"_id"</span> <span class="token operator">:</span> <span class="token string">"-J1PMXQBkHjO2vDovLJx"</span><span class="token punctuation">,</span>      <span class="token property">"_version"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token property">"result"</span> <span class="token operator">:</span> <span class="token string">"created"</span><span class="token punctuation">,</span>  <span class="token property">"_shards"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"total"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token property">"successful"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token property">"failed"</span> <span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"_seq_no"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token property">"_primary_term"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p>在 Elasticsearch 中可以通过覆盖的方式对数据进行更新</p><pre class="line-numbers language-json"><code class="language-json"># 对ID为<span class="token number">1</span>的这条数据进行更新curl -X PUT '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/<span class="token number">1</span>?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"fan"</span><span class="token punctuation">,</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token string">"java"</span><span class="token punctuation">,</span><span class="token property">"base"</span><span class="token operator">:</span> <span class="token string">"bj"</span><span class="token punctuation">}</span>'# 查询更新结果curl -X GET '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/<span class="token number">1</span>?pretty'<span class="token punctuation">{</span>  <span class="token property">"_index"</span> <span class="token operator">:</span> <span class="token string">"data"</span><span class="token punctuation">,</span>  <span class="token property">"_type"</span> <span class="token operator">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>  <span class="token property">"_id"</span> <span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>  <span class="token property">"_version"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    # 更新之后的数据版本进行了+<span class="token number">1</span>  <span class="token property">"_seq_no"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token property">"_primary_term"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token property">"found"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"_source"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"fan"</span><span class="token punctuation">,</span>    <span class="token property">"job"</span> <span class="token operator">:</span> <span class="token string">"java"</span><span class="token punctuation">,</span>    <span class="token property">"base"</span> <span class="token operator">:</span> <span class="token string">"bj"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span># 上面是更新整条数据<span class="token punctuation">,</span>下面是局部更新一条数据的某些字段<span class="token punctuation">,</span>需要使用_update标识curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/<span class="token number">1</span>/_update?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span><span class="token property">"doc"</span><span class="token operator">:</span><span class="token punctuation">{</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"aaa"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><p>在 Elasticsearch 中，删除文档数据只需要发起 DELETE 请求即可</p><pre class="line-numbers language-json"><code class="language-json"># 删除ID为<span class="token number">1</span>的这条数据curl -X DELETE 'http<span class="token operator">:</span>//<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/<span class="token number">1</span>?pretty'# 响应<span class="token punctuation">,</span>看到返回<span class="token property">"result"</span> <span class="token operator">:</span> <span class="token string">"deleted"</span>就表示删除成功<span class="token punctuation">,</span>如果删除一条不存在的数据会返回<span class="token number">404</span><span class="token punctuation">{</span>  <span class="token property">"_index"</span> <span class="token operator">:</span> <span class="token string">"data"</span><span class="token punctuation">,</span>  <span class="token property">"_type"</span> <span class="token operator">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>  <span class="token property">"_id"</span> <span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>  <span class="token property">"_version"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token property">"result"</span> <span class="token operator">:</span> <span class="token string">"deleted"</span><span class="token punctuation">,</span>  <span class="token property">"_shards"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"total"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token property">"successful"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token property">"failed"</span> <span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"_seq_no"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token property">"_primary_term"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch 将会在你之后添加更多索引的时候才在后台进行删除内容的清理</p><h1 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h1><p>根据 id 搜索数据</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">'10.10.110.191:9200/data/user/003?pretty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索全部数据</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">'10.10.110.191:9200/data/user/_search?pretty'</span>    <span class="token comment" spellcheck="true"># 响应默认只返回10条数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关键字搜素数据</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查询 base 等于 sz 的用户数据</span>curl -X GET <span class="token string">'10.10.110.191:9200/data/user/_search?q=base:sz'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="DSL-搜索"><a href="#DSL-搜索" class="headerlink" title="DSL 搜索"></a>DSL 搜索</h1><p>Elasticsearch 提供基于 JSON 的完整查询语言 DSL(Query DSL) 来定义查询，它允许你构建更加复杂、强大的查询</p><pre class="line-numbers language-json"><code class="language-json"># 查询base等于sz的用户curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>    # 请求体  <span class="token property">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"match"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"base"</span> <span class="token operator">:</span> <span class="token string">"sz"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'# 查询age大于<span class="token number">16</span>且job等于Linux的用户curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d '<span class="token punctuation">{</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>         <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token property">"age"</span><span class="token operator">:</span> <span class="token punctuation">{</span>             <span class="token property">"gt"</span><span class="token operator">:</span> <span class="token number">16</span>           <span class="token punctuation">}</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"job"</span><span class="token operator">:</span> <span class="token string">"Linux"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'# 全文搜索curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"miss lisi"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h1><p>查询得到需要高亮的数据，再使用 highlight 将需要高亮的字段写在 fields 里面</p><pre class="line-numbers language-json"><code class="language-json">curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"miss lisi"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"highlight"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>在 Elasticsearch 中支持聚合操作，类似 SQL 中的 group by 操作</p><pre class="line-numbers language-json"><code class="language-json"># 根据字段值分组聚合curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>  <span class="token property">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"age_terms"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"terms"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"age"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'# 响应<span class="token punctuation">,</span>age字段值为<span class="token number">16</span>的有<span class="token number">1</span>条数据<span class="token punctuation">,</span>age字段值为<span class="token number">25</span>的有<span class="token number">2</span>条数据<span class="token property">"aggregations"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"age_terms"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"doc_count_error_upper_bound"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token property">"sum_other_doc_count"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token property">"buckets"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"key"</span> <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>        <span class="token property">"doc_count"</span> <span class="token operator">:</span> <span class="token number">1</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"key"</span> <span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>        <span class="token property">"doc_count"</span> <span class="token operator">:</span> <span class="token number">2</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"key"</span> <span class="token operator">:</span> <span class="token number">36</span><span class="token punctuation">,</span>        <span class="token property">"doc_count"</span> <span class="token operator">:</span> <span class="token number">1</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>一个文档不只有数据，它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是</p><table><thead><tr><th>节点</th><th>说明</th></tr></thead><tbody><tr><td>_index</td><td>文档存储的地方</td></tr><tr><td>_type</td><td>文档代表的对象的类</td></tr><tr><td>_id</td><td>文档的唯一标识</td></tr></tbody></table><p>索引(index)类似于关系型数据库里的 “数据库” ——它是我们存储和索引关联数据的地方</p><p>_type(类型)，在关系型数据库中，我们经常将相同类的对象存储在一个表里，因为它们有着相同的结构。同理，在 Elasticsearch 中我们使用相同类型(type)的文档表示相同的 “事物”，因为他们的数据结构也是相同的</p><p>id 仅仅是一个字符串，它与 _index 和 _type 组合时，就可以在 Elasticsearch 中唯一标识一个文档。当创建一个文档时你可以自定义 _id ，也可以让 Elasticsearch 帮你自动生成</p><h1 id="响应查询"><a href="#响应查询" class="headerlink" title="响应查询"></a>响应查询</h1><p>指定响应字段</p><pre class="line-numbers language-apl"><code class="language-apl"><span class="token comment" spellcheck="true"># 只响应 _source 下的 name,job 字段</span>curl <span class="token function">-</span>X GET <span class="token string">'10.10.110.191:9200/data/user/001/?_source=name,job'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不返回元数据，仅仅返回原始数据</p><pre class="line-numbers language-apl"><code class="language-apl">curl <span class="token function">-</span>X GET <span class="token string">'10.10.110.191:9200/data/user/001/_source'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="判断文档存在"><a href="#判断文档存在" class="headerlink" title="判断文档存在"></a>判断文档存在</h1><p>如果我们只需要判断文档是否存在，而不查询文档内容</p><pre class="line-numbers language-apl"><code class="language-apl"><span class="token comment" spellcheck="true"># 如果文档存在,Elasticsearch 将返回 HTTP/1.1 200 OK,如果不存在就返回 HTTP/1.1 404 Not Found</span>curl <span class="token function">-</span>i <span class="token function">-</span>X HEAD <span class="token string">'http://10.10.110.191:9200/data/user/001'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，这只表示你在查询的那一刻文档不存在，但并不表示几毫秒后依旧不存在，另一个进程在这期间可能创建新文档</p><h1 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h1><p>有些情况下可以通过批量操作以减少网络请求，如：批量查询、批量插入数据</p><pre class="line-numbers language-json"><code class="language-json"># 批量查询curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/data/user/_mget?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>  <span class="token property">"ids"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"001"</span><span class="token punctuation">,</span> <span class="token string">"002"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>'# 响应<span class="token punctuation">{</span>  <span class="token property">"docs"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"_index"</span> <span class="token operator">:</span> <span class="token string">"data"</span><span class="token punctuation">,</span>      <span class="token property">"_type"</span> <span class="token operator">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>      <span class="token property">"_id"</span> <span class="token operator">:</span> <span class="token string">"001"</span><span class="token punctuation">,</span>      <span class="token property">"_version"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"_seq_no"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token property">"_primary_term"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"found"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token property">"_source"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"lisi"</span><span class="token punctuation">,</span>        <span class="token property">"job"</span> <span class="token operator">:</span> <span class="token string">"Python"</span><span class="token punctuation">,</span>        <span class="token property">"base"</span> <span class="token operator">:</span> <span class="token string">"sh"</span><span class="token punctuation">,</span>        <span class="token property">"age"</span> <span class="token operator">:</span> <span class="token number">16</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"_index"</span> <span class="token operator">:</span> <span class="token string">"data"</span><span class="token punctuation">,</span>      <span class="token property">"_type"</span> <span class="token operator">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span>      <span class="token property">"_id"</span> <span class="token operator">:</span> <span class="token string">"002"</span><span class="token punctuation">,</span>      <span class="token property">"_version"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"_seq_no"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"_primary_term"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"found"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token property">"_source"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"mowenjie"</span><span class="token punctuation">,</span>        <span class="token property">"job"</span> <span class="token operator">:</span> <span class="token string">"Linux"</span><span class="token punctuation">,</span>        <span class="token property">"base"</span> <span class="token operator">:</span> <span class="token string">"sz"</span><span class="token punctuation">,</span>        <span class="token property">"age"</span> <span class="token operator">:</span> <span class="token number">36</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>和 SQL 使用 LIMIT 关键字返回只有一页的结果一样，Elasticsearch 接受 from 和 size 参数</p><pre class="line-numbers language-bash"><code class="language-bash">size: 结果数,默认10 from: 从第n条数据之后开始,默认0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查询一个区间的数据</p><pre class="line-numbers language-json"><code class="language-json"># 导入官方测试数据curl -H <span class="token string">"Content-Type: application/x-ndjson"</span> -XPOST <span class="token string">"10.10.110.191:9200/bank/account/_bulk?pretty"</span> --data-binary @accounts.json# 将数据的account_number字段进行排序之后再取数据curl -X GET <span class="token string">"http://10.10.110.191:9200/bank/account/_search?pretty"</span> -H <span class="token string">"Content-Type:application/json"</span> -d '<span class="token punctuation">{</span><span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"account_number"</span><span class="token operator">:</span> <span class="token string">"asc"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"from"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    # 从第<span class="token number">10</span>条数据之后开始<span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">30</span>    # 一共返回<span class="token number">30</span>条数据<span class="token punctuation">,</span>就是account_number为<span class="token number">10</span>-<span class="token number">39</span>的数据<span class="token punctuation">}</span>'# 取<span class="token number">1000</span>到<span class="token number">2000</span>这个区间的随机数据curl -X GET <span class="token string">"http://10.10.110.191:9200/bank/account/_search?pretty"</span> -H <span class="token string">"Content-Type:application/json"</span> -d'<span class="token punctuation">{</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"balance"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"gte"</span><span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>            <span class="token property">"lte"</span><span class="token operator">:</span> <span class="token number">2000</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>前面我们创建的索引以及插入数据，都是由 Elasticsearch 进行自动判断类型，有些时候我们是需要进行明确字段类型的，否则自动判断的类型和实际需求是不相符的。每个字段都有一个数据类型，可以是一个简单的类型：text、keyword、date、long、double、boolean、ip，或者一个支持 JSON 层次结构的类型：例如 object、nested，或者是一种特殊的类型：geo_point、geo_shape、completion</p><p>创建明确类型的索引</p><pre class="line-numbers language-json"><code class="language-json">curl -X PUT '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/itcast' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>  <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"index"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"number_of_shards"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>      <span class="token property">"number_of_replicas"</span><span class="token operator">:</span> <span class="token string">"0"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"age"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"mail"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"hobby"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看索引映射</p><pre class="line-numbers language-apl"><code class="language-apl">curl <span class="token function">-</span>X GET <span class="token string">'10.10.110.191:9200/itcast/_mapping'</span><span class="token comment" spellcheck="true"># 响应</span><span class="token dfn builtin">{</span>  "itcast" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>    "mappings" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>      "properties" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>        "age" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>          "type" <span class="token dfn builtin">:</span> "integer"        <span class="token dfn builtin">}</span><span class="token function">,</span>        "hobby" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>          "type" <span class="token dfn builtin">:</span> "text"        <span class="token dfn builtin">}</span><span class="token function">,</span>        "mail" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>          "type" <span class="token dfn builtin">:</span> "keyword"        <span class="token dfn builtin">}</span><span class="token function">,</span>        "name" <span class="token dfn builtin">:</span> <span class="token dfn builtin">{</span>          "type" <span class="token dfn builtin">:</span> "text"        <span class="token dfn builtin">}</span>      <span class="token dfn builtin">}</span>    <span class="token dfn builtin">}</span>  <span class="token dfn builtin">}</span><span class="token dfn builtin">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>批量插入数据</p><pre class="line-numbers language-json"><code class="language-json"># 如果插入的数据类型与我们字段定义的类型不同<span class="token punctuation">,</span>那么就无法插入curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/itcast/_bulk' -H <span class="token string">"Content-Type:application/json"</span> --data-binary @itcast.json<span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token property">"_type"</span><span class="token operator">:</span><span class="token string">"_doc"</span><span class="token punctuation">,</span><span class="token property">"_id"</span><span class="token operator">:</span><span class="token string">"1"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span><span class="token property">"mail"</span><span class="token operator">:</span> <span class="token string">"111@qq.com"</span><span class="token punctuation">,</span><span class="token property">"hobby"</span><span class="token operator">:</span><span class="token string">"羽毛球、乒乓球、足球"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token property">"_type"</span><span class="token operator">:</span><span class="token string">"_doc"</span><span class="token punctuation">,</span><span class="token property">"_id"</span><span class="token operator">:</span><span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"李四"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">21</span><span class="token punctuation">,</span><span class="token property">"mail"</span><span class="token operator">:</span> <span class="token string">"222@qq.com"</span><span class="token punctuation">,</span><span class="token property">"hobby"</span><span class="token operator">:</span><span class="token string">"羽毛球、乒乓球、足球、篮球"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token property">"_type"</span><span class="token operator">:</span><span class="token string">"_doc"</span><span class="token punctuation">,</span><span class="token property">"_id"</span><span class="token operator">:</span><span class="token string">"3"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"王五"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token property">"mail"</span><span class="token operator">:</span> <span class="token string">"333@qq.com"</span><span class="token punctuation">,</span><span class="token property">"hobby"</span><span class="token operator">:</span><span class="token string">"羽毛球、篮球、游泳、听音乐"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token property">"_type"</span><span class="token operator">:</span><span class="token string">"_doc"</span><span class="token punctuation">,</span><span class="token property">"_id"</span><span class="token operator">:</span><span class="token string">"4"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"赵六"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">,</span><span class="token property">"mail"</span><span class="token operator">:</span> <span class="token string">"444@qq.com"</span><span class="token punctuation">,</span><span class="token property">"hobby"</span><span class="token operator">:</span><span class="token string">"跑步、游泳"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token property">"_type"</span><span class="token operator">:</span><span class="token string">"_doc"</span><span class="token punctuation">,</span><span class="token property">"_id"</span><span class="token operator">:</span><span class="token string">"5"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"孙七"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span><span class="token property">"mail"</span><span class="token operator">:</span> <span class="token string">"555@qq.com"</span><span class="token punctuation">,</span><span class="token property">"hobby"</span><span class="token operator">:</span><span class="token string">"听音乐、看电影"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询插入的数据</p><pre class="line-numbers language-apl"><code class="language-apl">curl <span class="token function">-</span>X POST <span class="token string">'10.10.110.191:9200/itcast/_doc/_search?pretty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h1><p>term 主要用于精确匹配某些值，比如数字、日期、布尔值或 not_analyzed 的字符串(未经分析的文本数据类型)</p><pre class="line-numbers language-json"><code class="language-json">curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/itcast/_doc/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>   <span class="token property">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"term"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"age"</span> <span class="token operator">:</span> <span class="token number">20</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>range 过滤允许我们按照指定范围查询一批数据</p><pre class="line-numbers language-json"><code class="language-json"># 查询age大于等于<span class="token number">20</span>小于等于<span class="token number">22</span>范围的数据(gt<span class="token operator">:</span>大于<span class="token punctuation">,</span>gte<span class="token operator">:</span>大于等于<span class="token punctuation">,</span>lt<span class="token operator">:</span>小于<span class="token punctuation">,</span>lte<span class="token operator">:</span>小于等于<span class="token punctuation">)</span>curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/bank/account/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>   <span class="token property">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"age"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"gte"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>        <span class="token property">"lte"</span><span class="token operator">:</span> <span class="token number">22</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>exists 查询可以用于查找文档中是否包含指定字段或没有某个字段，类似于 SQL 语句中的 IS_NULL 条件</p><pre class="line-numbers language-json"><code class="language-json"># 查询原始数据中含有address字段的文档curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/bank/account/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>   <span class="token property">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"exists"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"address"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>match 是一个模糊查询，需要指定字段名，但是会进行分词(中英文分词不一样)</p><pre class="line-numbers language-json"><code class="language-json"># 查询hobby字段是乒乓球的记录<span class="token punctuation">,</span>在查询之前会进行分词(只要记录包含<span class="token punctuation">[</span>乒/乓/球<span class="token punctuation">]</span>都会被匹配成功<span class="token punctuation">)</span>curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/itcast/_doc/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>   <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"hobby"</span><span class="token operator">:</span> <span class="token string">"乒乓球"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bool 查询可以用来合并多个条件查询结果的布尔逻辑，它包含以下操作符：</p><blockquote><p>must: 多个查询条件的完全匹配，相当于and</p></blockquote><blockquote><p>must_not: 多个查询条件的相反匹配，相当于not</p></blockquote><blockquote><p>should: 至少有一个查询条件匹配，相当于or</p></blockquote><blockquote><p>filter: 必须匹配，但它不会对匹配的数据进行评分</p></blockquote><pre class="line-numbers language-json"><code class="language-json"># 只要包含<span class="token string">"乒乓 游泳"</span>的数据都会被匹配curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/itcast/_doc/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>   <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"hobby"</span><span class="token operator">:</span> <span class="token string">"乒乓 游泳"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'# hobby包含乒乓但是age不等于<span class="token number">21</span>的数据curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/itcast/_doc/_search?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>   <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"hobby"</span><span class="token operator">:</span> <span class="token string">"乒乓"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"must_not"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"age"</span><span class="token operator">:</span> <span class="token string">"21"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h1><p>中文分词的难点在于在汉语中没有明显的词汇分界点，如在英语中空格可以作为分隔符，如果分隔不正确就会造成歧义。常用中文分词器有 IK、jieba、THULAC 等，推荐使用 IK 分词器</p><blockquote><p>IK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始，IKAnalyzer已经推出了3个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的IK Analyzer 3.0则发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。采用了特有的”正向迭代最细粒度切分算法”，具有80万字/秒的高速处理能力 采用了多子处理器分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。 优化的词典存储，更小的内存占用</p></blockquote><p>安装 ik 中文分词器</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载对应 es 版本的 ik 分词器</span>https://github.com/medcl/elasticsearch-analysis-ik<span class="token comment" spellcheck="true"># 创建目录</span><span class="token function">cd</span> your-es-root/plugins/ <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> ik<span class="token comment" spellcheck="true"># 解压</span>unzip plugin to folder your-es-root/plugins/ik<span class="token comment" spellcheck="true"># 重启 es(集群环境每一台都要配置)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分词测试</p><pre class="line-numbers language-json"><code class="language-json">curl -X POST '<span class="token number">10.10</span>.<span class="token number">110.191</span><span class="token operator">:</span><span class="token number">9200</span>/_analyze?pretty' -H <span class="token string">"Content-Type:application/json"</span> -d ' <span class="token punctuation">{</span>  <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>  <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"我是中国人"</span><span class="token punctuation">}</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"tokens"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"我"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_CHAR"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"是"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_CHAR"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"中国人"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"中国"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">3</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"国人"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">4</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Elasticsearch-简介&quot;&gt;&lt;a href=&quot;#Elasticsearch-简介&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 简介&quot;&gt;&lt;/a&gt;Elasticsearch 简介&lt;/h1&gt;&lt;p&gt;Elasticsearch 
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Stack</title>
    <link href="https://www.missf.top/post/cb83e724.html"/>
    <id>https://www.missf.top/post/cb83e724.html</id>
    <published>2020-08-05T06:19:27.000Z</published>
    <updated>2020-09-28T03:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elastic-Stack-简介"><a href="#Elastic-Stack-简介" class="headerlink" title="Elastic Stack 简介"></a>Elastic Stack 简介</h1><p>ELK 日志收集分析平台相信所有的运维工程师都听说过，实际上 ELK 不是一门技术，而是三个软件的简称。它们分别是由 Elasticsearch、Logstash、Kibana 组成，在ELK发展的过程中，又有新成员 Beats 的加入，所以就形成了 Elastic Stack</p><p>Elastic Stack 的组成</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f46336d160a154a677a6088.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>Elasticsearch 基于 java 语言开发，是个开源分布式搜索引擎，它的特点有:分布式、零配置、自动发现、索引自动分片、索引副本机制、RESTful 风格接口、多数据源、自动搜索负载等</p><h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><p>Logstash 基于 java 语言开发，是一个开源的用于收集，分析和存储日志的工具</p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><p>Kibana 基于 nodejs，也是一个开源和免费的工具，Kibana 可以为 Logstash 和 ElasticSearch 提供的日志分析的友好 Web 界面，可以汇总、分析和搜索重要数据日志</p><h1 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h1><p>Beats 是 elastic 公司开源的一款采集系统监控数据的代理 agent，是在被监控服务器上以客户端形式运行的数据收集器的统称，可以直接把数据发送给 Elasticsearch 或者通过 Logstash 发送给 Elasticsearch，然后进行后续的数据分析活动</p><p>Beats由如下组成：</p><ul><li>Packetbeat：一个网络数据包分析器，用于监控、收集网络流量信息，Packetbeat 嗅探服务器之间的流量，解析应用层协议，并关联到消息的处理，其支持ICMP(v4 and v6)、DNS、HTTP、Mysql、PostgreSQL、Redis、MongoDB、Memcache 等协议</li><li>Filebeat：用于监控、收集服务器日志文件，其已取代 logstash forwarder</li><li>Metricbeat：可定期获取外部系统的监控指标信息，其可以监控、收集 Apache、HAProxy、MongoDB、MySQL、Nginx、PostgreSQL、Redis、System、Zookeeper 等服务</li><li>Winlogbeat：用于监控、收集 Windows 系统的日志信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Elastic-Stack-简介&quot;&gt;&lt;a href=&quot;#Elastic-Stack-简介&quot; class=&quot;headerlink&quot; title=&quot;Elastic Stack 简介&quot;&gt;&lt;/a&gt;Elastic Stack 简介&lt;/h1&gt;&lt;p&gt;ELK 日志收集分析平台相信
      
    
    </summary>
    
    
      <category term="Elastic Stack" scheme="https://www.missf.top/categories/Elastic-Stack/"/>
    
    
      <category term="ELK" scheme="https://www.missf.top/tags/ELK/"/>
    
      <category term="企业级日志系统" scheme="https://www.missf.top/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据收集分析" scheme="https://www.missf.top/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus pushgateway工具</title>
    <link href="https://www.missf.top/post/5cf39589.html"/>
    <id>https://www.missf.top/post/5cf39589.html</id>
    <published>2020-08-04T10:05:33.000Z</published>
    <updated>2020-10-10T08:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PushGateway-部署"><a href="#PushGateway-部署" class="headerlink" title="PushGateway 部署"></a>PushGateway 部署</h1><p>prometheus 基于 http 的 pull 方式去采集时间序列数据，但是由于业务需求，prometheus 和 exporter 可能不在一个子网或者防火墙原因，导致 prometheus 无法直接拉取各个 target 数据，或者需要将不同的数据进行汇总，这时候就可以使用 prometheus 的自带组件 pushgateway 进行数据的汇总，将默认的 pull 方式改为 push 方式进行数据的采集</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载pushgateway</span><span class="token function">wget</span> https://github.com/prometheus/pushgateway/releases/download/v1.2.0/pushgateway-1.2.0.linux-amd64.tar.gz<span class="token comment" spellcheck="true"># 解压</span><span class="token function">tar</span> xf pushgateway-1.2.0.linux-amd64.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> pushgateway-1.2.0.linux-amd64 /usr/local/pushgateway<span class="token comment" spellcheck="true"># 创建pushgateway启动文件</span>vim /usr/lib/systemd/system/pushgateway.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Documentation<span class="token operator">=</span>pushgateway exporterAfter<span class="token operator">=</span>local-fs.target network-online.target network.targetWants<span class="token operator">=</span>local-fs.target network-online.target network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Restart<span class="token operator">=</span>on-failureExecStart<span class="token operator">=</span>/usr/local/pushgateway/pushgateway    <span class="token comment" spellcheck="true"># 需要修改监听端口可以自行添加参数</span><span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target<span class="token comment" spellcheck="true"># 启动pushgateway</span>systemctl start pushgateway.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Prometheus-添加-PushGateway"><a href="#Prometheus-添加-PushGateway" class="headerlink" title="Prometheus 添加 PushGateway"></a>Prometheus 添加 PushGateway</h1><p>在我们的 prometheus 配置文件添加 pushgateway 的地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/prometheus.yml<span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'pushgateway'</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'49.233.200.185:9091'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 这个是安装了pushgateway的服务器地址</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">instance</span><span class="token punctuation">:</span> pushgateway<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启 prometheus 服务</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pushgateway 其实是一个中转站，我们可以使用任何高级语言发送 post 请求到 pushgateway，然后对数据进行增加删除等操作，pushgateway 再把数据实时推送到 prometheus</p><h1 id="推送数据到-PushGateway"><a href="#推送数据到-PushGateway" class="headerlink" title="推送数据到 PushGateway"></a>推送数据到 PushGateway</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"missf 123456"</span> <span class="token operator">|</span> curl --data-binary @- http://49.233.200.185:9091/metrics/job/prometheus<span class="token comment" spellcheck="true"># 数据:missf,值:123456</span><span class="token comment" spellcheck="true"># --data-binary 表示发送二进制数据(post方式)</span><span class="token comment" spellcheck="true"># http://49.233.200.185:9091 pushgateway的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看 pushgateway 推送到 prometheus上的数据，这可以看到有 exported_job=”prometheus” 和 job=”prometheus” 两个指标，我们推送数据时指定的 job 是 prometheus，为什么这里的 job 会显示 pushgateway 呢？这里需要修改一个 honor_labels 的参数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f2a200a14195aa594b740f9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>修改 prometheus 的配置文件，开启 honor_labels 参数(默认为false)</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'pushgateway'</span>    <span class="token key atrule">honor_labels</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'49.233.200.185:9091'</span><span class="token punctuation">]</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">instance</span><span class="token punctuation">:</span> pushgateway<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启 prometheus</p><p>再次推送数据到 pushgateway，然后查看 prometheus 上的数据</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"mwj 123456"</span> <span class="token operator">|</span> curl --data-binary @- http://49.233.200.185:9091/metrics/job/prometheus/instance/missf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic.imgdb.cn/item/5f2a245714195aa594b8dbe0.jpg" alt=""></p><p>这里说明一下 honor_labels 的作用：因为 prometheus 配置 pushgateway 的时候，也会指定 job 和 instance，但是它只表示 pushgateway 实例本身，不能真正表达收集数据的含义。所以配置 pushgateway 需要添加 honor_labels：true 参数，避免收集到的数据本身的 job 和 instance 被覆盖。具体参考官网</p><h1 id="在-PushGateway-删除数据"><a href="#在-PushGateway-删除数据" class="headerlink" title="在 PushGateway 删除数据"></a>在 PushGateway 删除数据</h1><pre class="line-numbers language-bash"><code class="language-bash">curl -X DELETE http://49.233.200.185:9091/metrics/job/prometheus/instance/missf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PushGateway-部署&quot;&gt;&lt;a href=&quot;#PushGateway-部署&quot; class=&quot;headerlink&quot; title=&quot;PushGateway 部署&quot;&gt;&lt;/a&gt;PushGateway 部署&lt;/h1&gt;&lt;p&gt;prometheus 基于 http 的 p
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 业务监控</title>
    <link href="https://www.missf.top/post/f261c617.html"/>
    <id>https://www.missf.top/post/f261c617.html</id>
    <published>2020-08-03T02:26:26.000Z</published>
    <updated>2020-09-28T03:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blackbox-exporter-部署"><a href="#Blackbox-exporter-部署" class="headerlink" title="Blackbox_exporter 部署"></a>Blackbox_exporter 部署</h1><p>Blackbox_exporter 是 prometheus 官方提供的 exporter 之一，可以提供 http、dns、tcp、icmp 的监控数据采集</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载</span><span class="token function">wget</span> https://github.com/prometheus/blackbox_exporter/releases/download/v0.17.0/blackbox_exporter-0.17.0.linux-amd64.tar.gz<span class="token comment" spellcheck="true"># 解压</span><span class="token function">tar</span> xf blackbox_exporter-0.17.0.linux-amd64.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> blackbox_exporter-0.17.0.linux-amd64 /usr/local/blackbox<span class="token comment" spellcheck="true"># 创建blackbox启动文件</span>vim /usr/lib/systemd/system/blackbox.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Documentation<span class="token operator">=</span>Blackbox exporterAfter<span class="token operator">=</span>local-fs.target network-online.target network.targetWants<span class="token operator">=</span>local-fs.target network-online.target network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Restart<span class="token operator">=</span>on-failureExecStart<span class="token operator">=</span>/usr/local/blackbox/blackbox_exporter --config.file<span class="token operator">=</span>/usr/local/blackbox/blackbox.yml<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target<span class="token comment" spellcheck="true"># 启动blackbox</span>systemctl daemon-reloadsystemctl restart blackbox.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置-TCP-端口检测及告警"><a href="#配置-TCP-端口检测及告警" class="headerlink" title="配置 TCP 端口检测及告警"></a>配置 TCP 端口检测及告警</h1><p>传统的端口检测方式，调用命令的方式去实现</p><pre class="line-numbers language-bash"><code class="language-bash">ncat -vz 47.100.107.121 80    <span class="token comment" spellcheck="true"># 返回seconds而不是timeout那么端口就是通的</span>telnet <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>zabbix监控端口可以通过模板或者自定义key写脚本实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改 prometheus 配置文件，配置 TCP 端口检测</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/prometheus.yml<span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'nginx_port_check'</span>    <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /probe    <span class="token key atrule">params</span><span class="token punctuation">:</span>      <span class="token key atrule">module</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>tcp_connect<span class="token punctuation">]</span>    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> check/port/nginx.json    <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __param_target      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__param_target<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance      <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__        <span class="token key atrule">replacement</span><span class="token punctuation">:</span> 47.100.107.121<span class="token punctuation">:</span><span class="token number">9115    </span><span class="token comment" spellcheck="true"># 这个是blackbox所在主机以及端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写监控 TCP 端口的告警规则</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/rules/nginx_port_check.yml<span class="token key atrule">groups</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx port check   <span class="token key atrule">rules</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> nginx_port_check failed     <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s     <span class="token key atrule">expr</span><span class="token punctuation">:</span> probe_success<span class="token punctuation">{</span>job="nginx_port_check"<span class="token punctuation">}</span> == 0     <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token key atrule">serverity</span><span class="token punctuation">:</span> critical     <span class="token key atrule">annotations</span><span class="token punctuation">:</span>       <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} port connection fail,{{ $labels.group }} value is:{{ $value }}"</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} port connection failed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 prometheus 配置文件需要重启 prometheus 服务</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭 Nginx 测试当 80 端口无法访问之后的告警结果</p><p><img src="https://pic.imgdb.cn/item/5f27e91d14195aa594ee2d22.jpg" alt=""></p><h1 id="业务接口检测及告警"><a href="#业务接口检测及告警" class="headerlink" title="业务接口检测及告警"></a>业务接口检测及告警</h1><p>基于现在 Java + Vue 前后端分离的开发模式下，我们很多时候需要去检测 Java 的接口是否正常。传统的手动检测可以使用 postman，或者写 shell 脚本也可以实现，但是prometheus 可以通过 blackbox 去更好的检测业务接口</p><p>修改 prometheus 配置文件，添加监控业务接口的 job</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'get_mysite'</span>    <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /probe    <span class="token key atrule">params</span><span class="token punctuation">:</span>      <span class="token key atrule">module</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>http_2xx<span class="token punctuation">]</span>    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> check/url/*.json    <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __param_target      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__param_target<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance      <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__        <span class="token key atrule">replacement</span><span class="token punctuation">:</span> 47.100.107.121<span class="token punctuation">:</span><span class="token number">9115</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写监控 url 链接的告警规则文件</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/rules/get_mysite.yml<span class="token key atrule">groups</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> get mysite check  <span class="token key atrule">rules</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> get_mysite_check failed     <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s     <span class="token key atrule">expr</span><span class="token punctuation">:</span> probe_success<span class="token punctuation">{</span>group="get_mysite"<span class="token punctuation">,</span>instance="https<span class="token punctuation">:</span>//www.missf.top"<span class="token punctuation">,</span>job="get_mysite"<span class="token punctuation">}</span> == 0    <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token key atrule">serverity</span><span class="token punctuation">:</span> critical     <span class="token key atrule">annotations</span><span class="token punctuation">:</span>       <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} failed, {{ $labels.group }} value is:{{ $value }}"</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} website not accessible"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 prometheus 配置文件之后记得重启 prometheus 服务</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 <a href="https://www.missf.top">https://www.missf.top</a> 这个链接的 http 请求不是返回 2xx 的状态码就会告警</p><p><img src="https://pic.imgdb.cn/item/5f28fbe914195aa5944ce74b.jpg" alt=""></p><p>我们在监控业务接口时，只监控到接口的返回状态(2xx状态码)，假如我们想要监控业务接口的返回内容该如何实现呢？那就需要修改 blackbox 的配置文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">modules</span><span class="token punctuation">:</span>  <span class="token key atrule">http_2xx</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> http<span class="token comment" spellcheck="true"># 下面这段是需要添加的内容 </span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>          <span class="token key atrule">method</span><span class="token punctuation">:</span> GET      <span class="token key atrule">headers</span><span class="token punctuation">:</span>        <span class="token key atrule">Host</span><span class="token punctuation">:</span> www.missf.top        <span class="token key atrule">Accept-Language</span><span class="token punctuation">:</span> en<span class="token punctuation">-</span>US        <span class="token key atrule">Origin</span><span class="token punctuation">:</span> missf.top      <span class="token key atrule">fail_if_body_matches_regexp</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 如果我get的url地址返回的正文中有"apache",那么就会失败,则probe_success值为0</span>        <span class="token punctuation">-</span> <span class="token string">"apache"</span>      <span class="token key atrule">fail_if_body_not_matches_regexp</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"nginx"</span>    <span class="token comment" spellcheck="true"># 如果我get的url地址返回的正文中没有"nginx",那么就会失败,则probe_success值为0</span>  <span class="token key atrule">http_post_2xx</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> http    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">method</span><span class="token punctuation">:</span> POST  <span class="token key atrule">tcp_connect</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp  <span class="token key atrule">pop3s_banner</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp    <span class="token key atrule">tcp</span><span class="token punctuation">:</span>      <span class="token key atrule">query_response</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"^+OK"</span>      <span class="token key atrule">tls</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">tls_config</span><span class="token punctuation">:</span>        <span class="token key atrule">insecure_skip_verify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">ssh_banner</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp    <span class="token key atrule">tcp</span><span class="token punctuation">:</span>      <span class="token key atrule">query_response</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"^SSH-2.0-"</span>  <span class="token key atrule">irc_banner</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp    <span class="token key atrule">tcp</span><span class="token punctuation">:</span>      <span class="token key atrule">query_response</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">send</span><span class="token punctuation">:</span> <span class="token string">"NICK prober"</span>      <span class="token punctuation">-</span> <span class="token key atrule">send</span><span class="token punctuation">:</span> <span class="token string">"USER prober prober prober :prober"</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"PING :([^ ]+)"</span>        <span class="token key atrule">send</span><span class="token punctuation">:</span> <span class="token string">"PONG ${1}"</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"^:[^ ]+ 001"</span>  <span class="token key atrule">icmp</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> icmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改了 blackbox 配置文件需要重启 blackbox 服务</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart blackbox.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面所配置的匹配返回内容是在http_2xx这个模块下添加的，我们需要修改prometheus配置文件对应的http_2xx模块的规则文件，配置我们监控业务接口的返回内容的url地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/check/url/get_mysite.json <span class="token punctuation">[</span><span class="token punctuation">{</span>        <span class="token key atrule">"targets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token string">"47.100.107.121"</span>    <span class="token comment" spellcheck="true"># 这个url返回的是默认的Nginx页面,对应我上面的匹配规则(nginx/apache)</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token key atrule">"labels"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token key atrule">"group"</span><span class="token punctuation">:</span> <span class="token string">"get_mysite"</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 blackbox 的采集数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f292cb314195aa594682880.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>probe_success 的值是根据我们在 blackbox 配置文件的正则去决定的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f292d4d14195aa59468abde.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这时候我们 get_mysite.json 这个规则文件的 job 的 probe_success 值就是通过 get 获取一个 url 的返回值去确定的，我们这样就可以去监控接口的返回内容了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f292f3014195aa5946a6ddd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="配置网络监控"><a href="#配置网络监控" class="headerlink" title="配置网络监控"></a>配置网络监控</h1><p>我们可以让服务器使用 icmp 协议去请求 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 或者是一个公网 IP，测试服务器的网络是否正常</p><p>修改 prometheus 配置文件，添加网络监控的 job</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'icmp_check_network'</span>     <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> 5s     <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /probe     <span class="token key atrule">params</span><span class="token punctuation">:</span>       <span class="token key atrule">module</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>icmp<span class="token punctuation">]</span>     <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> check/icmp/*.json     <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>         <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __param_target       <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__param_target<span class="token punctuation">]</span>         <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance       <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__         <span class="token key atrule">replacement</span><span class="token punctuation">:</span> 47.100.107.121<span class="token punctuation">:</span><span class="token number">9115</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写网络监控的规则文件</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/rules/check_network.yml<span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> icmp check network  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> icmp check network failed    <span class="token key atrule">for</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">expr</span><span class="token punctuation">:</span> probe_success<span class="token punctuation">{</span>group="icmp_check_network"<span class="token punctuation">,</span>instance="www.baidu.com"<span class="token punctuation">,</span>job="icmp_check_network"<span class="token punctuation">}</span> == 0    <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token key atrule">serverity</span><span class="token punctuation">:</span> critical    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} icmp connection failed, {{ $labels.group }} value is: {{ $value }}"</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> "<span class="token punctuation">{</span><span class="token punctuation">{</span> $labels.group <span class="token punctuation">}</span><span class="token punctuation">}</span> connection failed<span class="token punctuation">,</span> <span class="token key atrule">instance</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $labels.instance <span class="token punctuation">}</span><span class="token punctuation">}</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 prometheus 配置文件之后记得重启 prometheus 服务</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Blackbox-exporter-部署&quot;&gt;&lt;a href=&quot;#Blackbox-exporter-部署&quot; class=&quot;headerlink&quot; title=&quot;Blackbox_exporter 部署&quot;&gt;&lt;/a&gt;Blackbox_exporter 部署&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 告警</title>
    <link href="https://www.missf.top/post/615f0093.html"/>
    <id>https://www.missf.top/post/615f0093.html</id>
    <published>2020-07-23T03:53:03.000Z</published>
    <updated>2020-09-28T04:00:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alertmanager-概述"><a href="#Alertmanager-概述" class="headerlink" title="Alertmanager 概述"></a>Alertmanager 概述</h1><p>prometheus 发出告警时分为两部分，首先 prometheus 按告警规则(rule_files配置)向 alertmanager 发送告警，即告警规则是在 prometheus 上定义的，然后由 alertmanager 去管理这些告警，包括去重(deduplicating)、分组(grouping)、静音(silencing)、抑制(inhibition)、聚合(aggregation)，最终通过丰富的告警通知渠道(电话、微信、短信、邮件)将告警通知路由给对应的联系人。prometheus 的大部分组件都是 go 语言开发的，zabbix 到4.4之后的客户端才是 go 编写</p><h1 id="Alertmanager-二进制安装"><a href="#Alertmanager-二进制安装" class="headerlink" title="Alertmanager 二进制安装"></a>Alertmanager 二进制安装</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载</span><span class="token function">wget</span> https://github.com/prometheus/alertmanager/releases/download/v0.21.0/alertmanager-0.21.0.linux-amd64.tar.gz<span class="token comment" spellcheck="true"># 解压</span><span class="token function">tar</span> xf alertmanager-0.21.0.linux-amd64.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> alertmanager-0.21.0.linux-amd64 /usr/local/alertmanager<span class="token comment" spellcheck="true"># 创建alertmanager启动文件</span>vim /usr/lib/systemd/system/alertmanager.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Documentation<span class="token operator">=</span>alertmanager<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Restart<span class="token operator">=</span>on-failureExecStart<span class="token operator">=</span>/usr/local/alertmanager/alertmanager --config.file<span class="token operator">=</span>/usr/local/alertmanager/alertmanager.yml --storage.path<span class="token operator">=</span>/usr/local/alertmanager/data<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target<span class="token comment" spellcheck="true"># 启动</span>systemctl daemon-reloadsystemctl start alertmanager.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Alertmanager-配置文件详解"><a href="#Alertmanager-配置文件详解" class="headerlink" title="Alertmanager 配置文件详解"></a>Alertmanager 配置文件详解</h1><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/alertmanager/alertmanager.yml<span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 5m    <span class="token comment" spellcheck="true"># 恢复的超时时间,这个跟告警恢复通知有关,此参数并不是说在这个时间没有收到告警就会恢复</span><span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 默认以告警名进行分组,就是rule文件的alert值进行分组</span>  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token comment" spellcheck="true"># 发送警报前，至少等待多少秒才会发送(为了收集同组更多的警报信息一起发送)</span>  <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 10s    <span class="token comment" spellcheck="true"># 如果警报1已经发送,这时又出现同组的警报2,由于组状态发生变化,警报会在group_interval这个时间内发送,不会被repeat_interval这个时间收敛</span>  <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 20m    <span class="token comment" spellcheck="true"># 报警信息已发送，但事件并没有恢复,则等待多久时间再重新发送(生产环境一般设成20min或者30min)</span>  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'web.hook'</span>    <span class="token comment" spellcheck="true"># 发送警报的接收者名称,如果一个报警没有被一个route匹配,则发送给默认的接收器</span><span class="token key atrule">receivers</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 发送告警信息给那个接收者</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'web.hook'</span>    <span class="token comment" spellcheck="true"># 这个需要和上面定义的接收者名称一致</span>  <span class="token key atrule">webhook_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:5001/'</span><span class="token key atrule">inhibit_rules</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 抑制规则,防止告警风暴</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'critical'</span>    <span class="token key atrule">target_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'warning'</span>    <span class="token key atrule">equal</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">,</span> <span class="token string">'dev'</span><span class="token punctuation">,</span> <span class="token string">'instance'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="检查-Alertmanager-配置文件"><a href="#检查-Alertmanager-配置文件" class="headerlink" title="检查 Alertmanager 配置文件"></a>检查 Alertmanager 配置文件</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提示SUCCESS,则配置文件没有问题</span>./amtool check-config alertmanager.yml<span class="token comment" spellcheck="true"># 修改配置文件之后重启alertmanager</span>systemctl restart alertmanager.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置邮件告警"><a href="#配置邮件告警" class="headerlink" title="配置邮件告警"></a>配置邮件告警</h1><p>修改 alertmanager 配置文件，填写邮箱的验证信息，定义路由的收件人，配置发送告警邮件到那个邮箱</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat /usr/local/alertmanager/alertmanager.yml <span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 3m  <span class="token key atrule">smtp_smarthost</span><span class="token punctuation">:</span> <span class="token string">'smtp.qq.com:465'</span>  <span class="token key atrule">smtp_from</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_username</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_password</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token comment" spellcheck="true"># 授权码</span>  <span class="token key atrule">smtp_require_tls</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 20m  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mail'</span><span class="token key atrule">receivers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'devops.mail'</span>  <span class="token key atrule">email_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span> <span class="token string">'mf_2013@163.com'</span>    <span class="token key atrule">headers</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token key atrule">Subject</span><span class="token punctuation">:</span> <span class="token string">"[WARN] Prometheus 报警邮件"</span> <span class="token punctuation">}</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true        </span><span class="token comment" spellcheck="true"># 发送告警恢复通知</span><span class="token comment" spellcheck="true">#inhibit_rules:</span><span class="token comment" spellcheck="true">#  - source_match:</span><span class="token comment" spellcheck="true">#      severity: 'critical'</span><span class="token comment" spellcheck="true">#    target_match:</span><span class="token comment" spellcheck="true">#      severity: 'warning'</span><span class="token comment" spellcheck="true">#    equal: ['alertname', 'dev', 'instance']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置 prometheus 与 alertmanager 通信，设置规则文件的路径和正则匹配</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 修改prometheus配置文件</span>vim /usr/local/prometheus/prometheus.yml<span class="token key atrule">alerting</span><span class="token punctuation">:</span>  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">9093    </span><span class="token comment" spellcheck="true"># 这里由于alertmanager是和prometheus部署在同一台机器上,所以写本机地址</span><span class="token key atrule">rule_files</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">"rules/*.yml"</span>    <span class="token comment" spellcheck="true"># rules这个目录是在prometheus上的,指当前配置文件的同级目录,这个目录需要自己创建</span><span class="token comment" spellcheck="true"># 检查prometheus配置文件</span>./promtool check config prometheus.ymlsystemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写 rules 文件，根据 rules 文件中的表达式去告警，这个规则文件的路径是 prometheus 配置文件中定义的</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 监控节点的状态</span>cat /usr/local/prometheus/rules/node.yml <span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> node_alert  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> Node_InstanceDown            <span class="token key atrule">expr</span><span class="token punctuation">:</span> up == 0    <span class="token comment" spellcheck="true"># 表达式</span>    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 prometheus 的 web 控制台查看配置的规则</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f20e09814195aa594f3290e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>关闭 node_exporter.service 节点，查看告警邮件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f20e13414195aa594f3b901.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="配置微信告警"><a href="#配置微信告警" class="headerlink" title="配置微信告警"></a>配置微信告警</h1><p>修改 alertmanager 配置文件，定义路由规则</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat /usr/local/alertmanager/alertmanager.yml <span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 3m  <span class="token key atrule">smtp_smarthost</span><span class="token punctuation">:</span> <span class="token string">'smtp.qq.com:465'</span>  <span class="token key atrule">smtp_from</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_username</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_password</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token comment" spellcheck="true"># 授权码</span>  <span class="token key atrule">smtp_require_tls</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">templates</span><span class="token punctuation">:</span><span class="token punctuation">-</span> /usr/local/alertmanager/template/wechat.temp<span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 20m  <span class="token comment" spellcheck="true">#receiver: 'devops.mail'</span>  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>  <span class="token key atrule">routes</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 为node_exporter、docker、mysqld_exporter定义匹配路由,每个路由有自己的分组在微信告警时信息就会单独发送</span>  <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token comment" spellcheck="true"># 每个服务可以定义自己的接收者,这样在发送时就可以发送给不同的人,不同的服务对应不同的处理人员</span>    <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'node_exporter'</span><span class="token punctuation">]</span>    <span class="token key atrule">match_re</span><span class="token punctuation">:</span>      <span class="token key atrule">job</span><span class="token punctuation">:</span> node_exporter  <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'docker'</span><span class="token punctuation">]</span>    <span class="token key atrule">match_re</span><span class="token punctuation">:</span>      <span class="token key atrule">job</span><span class="token punctuation">:</span> docker  <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mysqld_exporter'</span><span class="token punctuation">]</span>    <span class="token key atrule">match_re</span><span class="token punctuation">:</span>      <span class="token key atrule">job</span><span class="token punctuation">:</span> mysqld_exporter<span class="token key atrule">receivers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token comment" spellcheck="true"># 将这个告警同时发送到邮件和微信</span>  <span class="token key atrule">email_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span> <span class="token string">'mf_2013@163.com'</span>    <span class="token key atrule">headers</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token key atrule">Subject</span><span class="token punctuation">:</span> <span class="token string">"[WARN] Prometheus 报警邮件"</span> <span class="token punctuation">}</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">wechat_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">api_secret</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">agent_id</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">corp_id</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">to_party</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment" spellcheck="true">#inhibit_rules:</span><span class="token comment" spellcheck="true">#  - source_match:</span><span class="token comment" spellcheck="true">#      severity: 'critical'</span><span class="token comment" spellcheck="true">#    target_match:</span><span class="token comment" spellcheck="true">#      severity: 'warning'</span><span class="token comment" spellcheck="true">#    equal: ['alertname', 'dev', 'instance']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写 rules 文件，为了每个服务单独报警，这里将 node_exporter、docker、mysqld_exporter 分开去写匹配规则</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat /usr/local/prometheus/rules/node.yml <span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> node_exporter  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_exporter_Down    <span class="token key atrule">expr</span><span class="token punctuation">:</span> up<span class="token punctuation">{</span>job="node_exporter"<span class="token punctuation">}</span> == 0    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysqld_exporter  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> mysqld_exporter_Down    <span class="token key atrule">expr</span><span class="token punctuation">:</span> up<span class="token punctuation">{</span>job="mysqld_exporter"<span class="token punctuation">}</span> == 0    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> docker  <span class="token key atrule">rules</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> docker_Down    <span class="token key atrule">expr</span><span class="token punctuation">:</span> up<span class="token punctuation">{</span>job="docker"<span class="token punctuation">}</span> == 0    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成之后重启 alertmanager</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart alertmanager.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭 node_exporter 和 docker_cadvisor 服务，这时候会每个服务单独发送告警信息，由于将全部服务 group_by 在一个组里面，在发送恢复信息时会出现服务混乱的情况，所以我将每个服务做了路由，每一个服务都有自己的 group_by，这样在发送信息时才会单独去发送</p><p><img src="https://pic.imgdb.cn/item/5f2140bc14195aa5945ae70c.jpg" alt=""></p><h1 id="配置钉钉告警"><a href="#配置钉钉告警" class="headerlink" title="配置钉钉告警"></a>配置钉钉告警</h1><p>先去创建一个钉钉机器人，具体过程这里就不详细说明了</p><p>prometheus 配置钉钉告警需要使用到 prometheus-webhook-dingtalk 插件，我们先使用二进制安装钉钉插件，dingtalk 服务默认启动的端口是 8060</p><p><a href="https://github.com/timonwong/prometheus-webhook-dingtalk" target="_blank" rel="noopener">prometheus-webhook-dingtalk插件下载地址</a></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载prometheus-webhook-dingtalk</span><span class="token function">wget</span> https://github.com/timonwong/prometheus-webhook-dingtalk/releases/download/v1.4.0/prometheus-webhook-dingtalk-1.4.0.linux-amd64.tar.gz<span class="token comment" spellcheck="true"># 解压prometheus-webhook-dingtalk</span><span class="token function">tar</span> xf prometheus-webhook-dingtalk-1.4.0.linux-amd64.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> prometheus-webhook-dingtalk-1.4.0.linux-amd64 /usr/local/dingtalk<span class="token comment" spellcheck="true"># 编写dingtalk启动文件</span>vim /usr/lib/systemd/system/dingtalk.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>prometheus-webhook-dingtalkAfter<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Restart<span class="token operator">=</span>on-failureExecStart<span class="token operator">=</span>/usr/local/dingtalk/prometheus-webhook-dingtalk \--ding.profile<span class="token operator">=</span>Prometheus告警<span class="token operator">=</span>https://oapi.dingtalk.com/robot/send?access_token<span class="token operator">=</span>xxxxxx<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target<span class="token comment" spellcheck="true"># 启动dingtalk.service</span>systemctl daemon-reloadsystemctl restart dingtalk.service<span class="token comment" spellcheck="true"># 查看dingtalk的webhook地址</span>journalctl -fu dingtalk.serviceJul 29 18:38:01 iZuf6fpaicz5jt7kep555qZ prometheus-webhook-dingtalk<span class="token punctuation">[</span>5504<span class="token punctuation">]</span>: ts<span class="token operator">=</span>2020-07-29T10:38:01.655Z caller<span class="token operator">=</span>main.go:133 component<span class="token operator">=</span>configuration msg<span class="token operator">=</span><span class="token string">"Webhook urls for prometheus alertmanager"</span> urls<span class="token operator">=</span>http://localhost:8060/dingtalk/Prometheus告警/send<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 prometheus 的 alertmanager 配置，更改告警的路由和接收者</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops_dingtalk'</span>    <span class="token comment" spellcheck="true"># 接收者必须和下面的一致</span><span class="token key atrule">receivers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'devops_dingtalk'</span>  <span class="token key atrule">webhook_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">'http://localhost:8060/dingtalk/Prometheus告警/send'</span>    <span class="token comment" spellcheck="true"># 这个URL是dingtalk的webhook地址</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关闭 docker 收集器查看告警效果</p><p><img src="https://pic.imgdb.cn/item/5f22831a14195aa594112818.jpg" alt=""></p><h1 id="告警状态"><a href="#告警状态" class="headerlink" title="告警状态"></a>告警状态</h1><p>prometheus 的告警状态有三种，我们可以在 prometheus 的控制台页面上查看告警的状态</p><p>inactive</p><blockquote><p>没有触发任何阈值，这个是根据 scrape_interval 参数(采集数据周期)和 evaluation_interval 参数(对比规则周期)去决定的</p></blockquote><p>pending</p><blockquote><p>已触发阈值但未满足告警持续时间，告警进入 pending 状态之后，需要等待规则配置的 for 时间，如果在这个时间内触发阈值的表达式一直成立，才会进入 firing 状 态</p></blockquote><p>firing</p><blockquote><p>已触发阈值且满足告警持续时间，将告警从 prometheus 发送给 alertmanager，在 alertmanager 收到告警之后并不会立刻发送，还需要等待一个 group_wait 时间，直到某个计算周期表达式为假，告警状态变更为 inactive，发送一个 resolve 给 altermanger，说明此告警已解决</p></blockquote><h1 id="告警收敛"><a href="#告警收敛" class="headerlink" title="告警收敛"></a>告警收敛</h1><p>alertmanager 在收到 prometheus 发送的告警之后，并不是把收到的信息简单的直接发送出去，而是通过一系列的收敛机制(分组、抑制、静默)去筛选出需要发送的信息，如果 alertmanager 收到信息就直接发送出去，会导致告警信息过多，运维人员会被告警信息淹没，错过重要的告警信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f23803214195aa5946d5b86.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>分组</p><blockquote><p>将类似性质的告警分类为单个通知，减少告警消息数量</p></blockquote><blockquote><p>将类似性质的告警进行聚合发送，帮助运维更好的排查问题</p></blockquote><p>抑制</p><blockquote><p>当告警发出后，停止重复发送由此告警而引起的其他告警，帮助运维第一时间掌握最核心的告警信息</p></blockquote><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">inhibit_rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'critical'</span>    <span class="token comment" spellcheck="true"># 当发生critical级别的告警时,就会抑制下面warning级别的告警</span>    <span class="token key atrule">target_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'warning'</span>    <span class="token key atrule">equal</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">,</span> <span class="token string">'dev'</span><span class="token punctuation">,</span> <span class="token string">'instance'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 已发送的告警与新产生的告警中equal定义的标签完全相同,则启动抑制机制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静默</p><blockquote><p>是一种简单的特定时间静音的提醒机制，在发布新版本时我们需要停掉某些进程，这时候告警肯定会触发的，由于这是我们已经预知的现象，我们可以打开 prometheus 主机的 9093 端口暂时将告警设置成静音</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f23c66b14195aa5948a1e2d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Prometheus一条告警是怎么触发的"><a href="#Prometheus一条告警是怎么触发的" class="headerlink" title="Prometheus一条告警是怎么触发的"></a>Prometheus一条告警是怎么触发的</h1><p>1.采集数据 scrape_interval: 15s</p><p>2.比对采集到的数据是否触发阈值 evaluation_interval: 15s</p><p>3.判断是否超出持续时间(在这个时间内一直处于触发阈值状态)for: 5s</p><p>4.告警到达alertmanager然后进行分组、抑制、静默</p><p>5.通过分组、抑制、静默一系列机制的信息将会被发送，但是会延迟发送group_wait: 10s</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f23ceb714195aa5948dbd05.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="编写告警规则案例"><a href="#编写告警规则案例" class="headerlink" title="编写告警规则案例"></a>编写告警规则案例</h1><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> general.rules  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_FileSystemUsage    <span class="token comment" spellcheck="true"># 监控磁盘使用率</span>    <span class="token key atrule">expr</span><span class="token punctuation">:</span> 100 <span class="token punctuation">-</span> node_filesystem_free_bytes<span class="token punctuation">{</span>mountpoint="/"<span class="token punctuation">,</span>fstype=~"ext4<span class="token punctuation">|</span>xfs"<span class="token punctuation">}</span> / node_filesystem_size_bytes<span class="token punctuation">{</span>mountpoint="/"<span class="token punctuation">,</span>fstype=~"ext4<span class="token punctuation">|</span>xfs"<span class="token punctuation">}</span> * 100 <span class="token punctuation">></span> 80    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> warning    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} : {{ $labels.mountpoint }} Partition utilization is too high"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} : {{ $labels.mountpoint }} Partition utilization is greater than 80% (Currently: {{ $value }})"</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_MemoryUsage    <span class="token comment" spellcheck="true"># 监控内存使用率</span>    <span class="token key atrule">expr</span><span class="token punctuation">:</span> 100 <span class="token punctuation">-</span> (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes) / node_memory_MemTotal_bytes * 100 <span class="token punctuation">></span> 80    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> warning    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} High memory usage"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }}  Memory usage greater than 80% (Currently: {{ $value }})"</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_cpuUsage    <span class="token comment" spellcheck="true"># 监控CPU使用率</span>    <span class="token key atrule">expr</span><span class="token punctuation">:</span> 100 <span class="token punctuation">-</span> irate(node_cpu_seconds_total<span class="token punctuation">{</span>mode="idle"<span class="token punctuation">,</span>job="node_exporter"<span class="token punctuation">,</span>instance="47.100.107.121<span class="token punctuation">:</span>9100"<span class="token punctuation">}</span><span class="token punctuation">[</span>5m<span class="token punctuation">]</span>) * 100 <span class="token punctuation">></span> 80    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> warning    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} High cpu usage"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} Memory usage greater than 60% (Currently: {{ $value }})"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Alertmanager-概述&quot;&gt;&lt;a href=&quot;#Alertmanager-概述&quot; class=&quot;headerlink&quot; title=&quot;Alertmanager 概述&quot;&gt;&lt;/a&gt;Alertmanager 概述&lt;/h1&gt;&lt;p&gt;prometheus 发出告警时分为
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
</feed>
