<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta name="chinaz-site-verification" content="EC6F7C888ADBF24B">
    <meta charset="utf-8">
    
    
    
    
    <title>Docker 容器网络 | 荒原饮露 | 可能是未来的架构师，也可能送外卖。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Docker,容器技术,云计算">
    <meta name="description" content="bridge 模式当启动 Docker 进程之后，Docker 会默认创建一个名为 docker0 的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样 Docker 主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，Docker 会先创建容器的虚拟网卡，容器的虚拟网卡去连接 Docker 主机的 docker0 虚拟网桥，相当于用一根网线将容器和 Docke">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 容器网络">
<meta property="og:url" content="https://www.missf.top/post/bc1d2f66.html">
<meta property="og:site_name" content="荒原饮露">
<meta property="og:description" content="bridge 模式当启动 Docker 进程之后，Docker 会默认创建一个名为 docker0 的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样 Docker 主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，Docker 会先创建容器的虚拟网卡，容器的虚拟网卡去连接 Docker 主机的 docker0 虚拟网桥，相当于用一根网线将容器和 Docke">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg">
<meta property="article:published_time" content="2020-06-23T01:49:44.000Z">
<meta property="article:modified_time" content="2020-09-28T02:52:36.000Z">
<meta property="article:author" content="荒原饮露">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="容器技术">
<meta property="article:tag" content="云计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="荒原饮露" href="/atom.xml">
    
    <link rel="shortcut icon" href="https://pic.imgdb.cn/item/5e9e7910c2a9a83be54641d1.png">
    <link rel="stylesheet" href="/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://pic.imgdb.cn/item/5e9e78fbc2a9a83be5463167.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://pic.imgdb.cn/item/5e9e78b6c2a9a83be545fef2.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">荒原饮露</h5>
          <a href="mailto:mf_2013@163.com" title="mf_2013@163.com" class="mail">mf_2013@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/MF-ReStart" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Docker 容器网络</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入你要搜索的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Docker 容器网络</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-06-23T01:49:44.000Z" itemprop="datePublished" class="page-time">
  2020-06-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Docker/">Docker</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#bridge-模式"><span class="post-toc-number">1.</span> <span class="post-toc-text">bridge 模式</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#host模式"><span class="post-toc-number">2.</span> <span class="post-toc-text">host模式</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#none-模式"><span class="post-toc-number">3.</span> <span class="post-toc-text">none 模式</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#container-模式"><span class="post-toc-number">4.</span> <span class="post-toc-text">container 模式</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器虚拟网卡和-docker0-网桥的-veth-pair-配对"><span class="post-toc-number">5.</span> <span class="post-toc-text">容器虚拟网卡和 docker0 网桥的 veth pair 配对</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器网络访问原理图"><span class="post-toc-number">6.</span> <span class="post-toc-text">容器网络访问原理图</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器网络实现的核心技术-iptables"><span class="post-toc-number">7.</span> <span class="post-toc-text">容器网络实现的核心技术: iptables</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#源IP地址变换规则"><span class="post-toc-number">8.</span> <span class="post-toc-text">源IP地址变换规则</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#目标IP地址变换规则"><span class="post-toc-number">9.</span> <span class="post-toc-text">目标IP地址变换规则</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#etcd-和-flannel-实现-docker-跨主机通信"><span class="post-toc-number">10.</span> <span class="post-toc-text">etcd 和 flannel 实现 docker 跨主机通信</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#master节点配置"><span class="post-toc-number">11.</span> <span class="post-toc-text">master节点配置</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#slave节点配置"><span class="post-toc-number">12.</span> <span class="post-toc-text">slave节点配置</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#配置-Docker-使用-flannel-的网络"><span class="post-toc-number">13.</span> <span class="post-toc-text">配置 Docker 使用 flannel 的网络</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#查看宿主机的IP变化"><span class="post-toc-number">14.</span> <span class="post-toc-text">查看宿主机的IP变化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#在两个节点创建容器相互-ping-验证"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">在两个节点创建容器相互 ping 验证</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Docker 容器网络"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Docker 容器网络</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-06-23 09:49:44" datetime="2020-06-23T01:49:44.000Z"  itemprop="datePublished">2020-06-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Docker/">Docker</a></li></ul>



            
<!--<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>-->
<!--    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>-->
<!--</span>-->


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h1><p>当启动 Docker 进程之后，Docker 会默认创建一个名为 docker0 的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样 Docker 主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，Docker 会先创建容器的虚拟网卡，容器的虚拟网卡去连接 Docker 主机的 docker0 虚拟网桥，相当于用一根网线将容器和 Docker 主机连接起来。虚拟网卡连接到 docker0 子网后，由 docker0 虚拟网桥分配 IP 给容器的虚拟网卡使用，并设置 docker0 虚拟网桥的 IP 地址为容器的默认网关。除了 Docker 启动时默认创建的 bridge 默认网络，我们还可以自定义 bridge 网络。相比默认的具备内部 DNS 发现，bridge 网络模式还可以通过容器名去实现容器之间的网络通信</p>
<p>查看 Docker 宿主机上的 docker0 虚拟网桥，默认网段是 172.17.0.1，安装 Docker 之后默认创建的</p>
<pre class="line-numbers language-bash"><code class="language-bash">ip a s docker0
3: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:9f:dc:ee:74 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:9fff:fedc:ee74/64 scope <span class="token function">link</span> 
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看默认定义好的网络模式，这里没有 container 模式是因为 container 是启动容器时直接指定的</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker network <span class="token function">ls</span>
NETWORK ID          NAME                DRIVER              SCOPE
a42d2b0e12ec        bridge              bridge              local
168bbf4b0447        host                host                local
ec481d03e2a1        none                null                local
21be62f7b97e        webserver           bridge              local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看 bridge 网络模式的详细信息</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker network inspect bridge
<span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,
        <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"a42d2b0e12ec0e039e7c4686099468585b88c8df8b639eaa780700980adb9e1b"</span>,
        <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2020-06-23T17:16:25.717600267+08:00"</span>,
        <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,
        <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,
        <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
            <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,
            <span class="token string">"Options"</span><span class="token keyword">:</span> null,
            <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
                <span class="token punctuation">{</span>
                    <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.0/16"</span>,
                    <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.1"</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"Internal"</span><span class="token keyword">:</span> false,
        <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,
        <span class="token string">"Ingress"</span><span class="token keyword">:</span> false,
        <span class="token string">"ConfigFrom"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
            <span class="token string">"Network"</span><span class="token keyword">:</span> <span class="token string">""</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"ConfigOnly"</span><span class="token keyword">:</span> false,
        <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
            <span class="token string">"253d0d8f196182eccaa52238068513cebfbf2abe69d2a7980e40d8c136b53960"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
                <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"nginx"</span>,
                <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"7fd4576f90bc1d0fd966ed5794710dd43461d077ea32f99e54a8b3c56ba1de08"</span>,
                <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,
                <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2/16"</span>,
                <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"8652448b6f9a99d9b9a6c70277ea23924b21df57289d4deb29a146974ad4c4dd"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
                <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"centos7"</span>,
                <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"e112927463f07a606a3a019f3af7400c711b9a903fec19c130b27c7d5f53d359"</span>,
                <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,
                <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.3/16"</span>,
                <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
            <span class="token string">"com.docker.network.bridge.default_bridge"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,
            <span class="token string">"com.docker.network.bridge.enable_icc"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,
            <span class="token string">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,
            <span class="token string">"com.docker.network.bridge.host_binding_ipv4"</span><span class="token keyword">:</span> <span class="token string">"0.0.0.0"</span>,
            <span class="token string">"com.docker.network.bridge.name"</span><span class="token keyword">:</span> <span class="token string">"docker0"</span>,
            <span class="token string">"com.docker.network.driver.mtu"</span><span class="token keyword">:</span> <span class="token string">"1500"</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装网桥管理工具包</p>
<pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y bridge-utils.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看虚拟网桥上的接口信息</p>
<pre class="line-numbers language-bash"><code class="language-bash">brctl show docker0
bridge name    bridge <span class="token function">id</span>                STP enabled        interfaces
docker0        8000.02429fdcee74        no                veth81bdc19                                                    vetha8f66a7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建类型为 bridge 的自定义网桥</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker network create webserver
21be62f7b97ebfc9ce6f6a1aaaffd59a4a220c6b778f36a98c72162023b5c5e5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动容器时指定使用自定义创建的 webserver 网桥(具备DNS发现)</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"app1"</span> --network webserver centos:7.7.1908 
98efd7fb3c63c0bd487039b7ef00925d786e0499f10d76003afa2277cc93b404

docker container run -itd --name <span class="token string">"app2"</span> --network webserver centos:7.7.1908 
c81e58db50ca74111d46f460ff322378b45414a36804738597559ec3c06cf542

docker container run -itd --name <span class="token string">"app3"</span> --network webserver centos:7.7.1908
41fb1a7dd161c03a158a104da54dcfa3b226035feceecabd003f7a18e91bff61<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看容器的 IP 地址</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker inspect --format<span class="token operator">=</span><span class="token string">'{{.NetworkSettings.Networks.webserver.IPAddress}}'</span> app1
172.18.0.2
docker inspect --format<span class="token operator">=</span><span class="token string">'{{.NetworkSettings.Networks.webserver.IPAddress}}'</span> app2
172.18.0.3
docker inspect --format<span class="token operator">=</span><span class="token string">'{{.NetworkSettings.Networks.webserver.IPAddress}}'</span> app3
172.18.0.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>容器之间的通信测试，自定义的 bridge 网桥相比默认的 bridge 网桥具备内部 DNS 发现， IP 和主机名都是可以 PING 通</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ping</span> 172.18.0.2
PING 172.18.0.2 <span class="token punctuation">(</span>172.18.0.2<span class="token punctuation">)</span> 56<span class="token punctuation">(</span>84<span class="token punctuation">)</span> bytes of data.
64 bytes from 172.18.0.2: icmp_seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.203 ms
64 bytes from 172.18.0.2: icmp_seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.085 ms

<span class="token function">ping</span> 98efd7fb3c63    <span class="token comment" spellcheck="true"># 如果启动容器时不指定自定义的网桥,那就会使用默认的bridge模式,这样是不能PING通主机名的</span>
PING 98efd7fb3c63 <span class="token punctuation">(</span>172.18.0.2<span class="token punctuation">)</span> 56<span class="token punctuation">(</span>84<span class="token punctuation">)</span> bytes of data.
64 bytes from app1.webserver <span class="token punctuation">(</span>172.18.0.2<span class="token punctuation">)</span>: icmp_seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.402 ms
64 bytes from app1.webserver <span class="token punctuation">(</span>172.18.0.2<span class="token punctuation">)</span>: icmp_seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.100 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h1><p>如果启动容器时指定 host 模式，那么这个容器将不会获得一个独立的 Network namespace，而是和宿主机共用一个 Network namespace。容器不会虚拟出自己的网卡，而是使用宿主机的 IP 和端口。这种无需 NAT 转换的网络模式无需再映射容器与宿主机之间的端口，在提高网络传输性能的同时，造成了网络环境隔离性弱化。容器之间不再拥有隔离独立的网络，Docker host 上已使用的端口就不能再用了</p>
<p>启动一个 Nginx 容器，再查看宿主机上的 80 端口是否被使用</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"host_nginx"</span> --network<span class="token operator">=</span>host nginx:1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看宿主机上的 80 端口是否被 Nginx 容器所使用</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">netstat</span> -lntup <span class="token operator">|</span> <span class="token function">grep</span> 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7358/nginx: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看宿主机上 Nginx 进程的父进程是否为 Docker</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -afx <span class="token operator">|</span> <span class="token function">grep</span> containerd -A 1
  1100 ?        Ssl    1:18 /usr/bin/containerd
  7341 ?        Sl     0:00  \_ containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/adf66250b1fcd95c2531f04f8504bea614dd90903f4f074e150ce6202895a023 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc
  7358 pts/0    Ss+    0:00      \_ nginx: master process nginx -g daemon off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># 这个nginx进程是容器中启动的nginx进程,这也正如我们前面所说,使用host模式启动容器,容器会和宿主机共用一个Network namespace</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进入容器中查看网卡信息，可以看到宿主机上的网卡也会显示，这就是共用了一个 Network namespace 的结果</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ifconfig</span>
br-21be62f7b97e: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
        inet6 fe80::42:6fff:fe77:c9f0  prefixlen 64  scopeid 0x20<span class="token operator">&lt;</span>link<span class="token operator">></span>
        ether 02:42:6f:77:c9:f0  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fe80::42:9fff:fedc:ee74  prefixlen 64  scopeid 0x20<span class="token operator">&lt;</span>link<span class="token operator">></span>
        ether 02:42:9f:dc:ee:74  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets 3  bytes 114 <span class="token punctuation">(</span>114.0 B<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 677 <span class="token punctuation">(</span>677.0 B<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

ens32: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500
        inet 10.10.110.150  netmask 255.255.255.0  broadcast 10.10.110.255
        inet6 fe80::20c:29ff:fec4:cbac  prefixlen 64  scopeid 0x20<span class="token operator">&lt;</span>link<span class="token operator">></span>
        ether 00:0c:29:c4:cb:ac  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets 91694  bytes 118390130 <span class="token punctuation">(</span>112.9 MiB<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 41857  bytes 2875558 <span class="token punctuation">(</span>2.7 MiB<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<span class="token operator">&lt;</span>host<span class="token operator">></span>
        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>
        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="none-模式"><a href="#none-模式" class="headerlink" title="none 模式"></a>none 模式</h1><p>容器启动时指定 none 模式是获取独立的 Network namespace，但不为容器进行任何网络配置。容器内部只有 loopback 网络设备不会再有其他的网络资源，将网络创建的责任完全交给用户。作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发，这种方式可以实现更加灵活复杂的网络，同时也体现了Docker 设计理念的开放</p>
<p>启动一个 none 模式的容器</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"none_centos"</span> --network<span class="token operator">=</span>none centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进入容器查看网卡设备信息</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container <span class="token function">exec</span> -it none_centos /bin/bash

<span class="token function">ifconfig</span>    <span class="token comment" spellcheck="true"># 这里只有一个回环口地址,因为none模式不会对容器进行任何网络配置</span>
lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<span class="token operator">&lt;</span>host<span class="token operator">></span>
        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>
        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="container-模式"><a href="#container-模式" class="headerlink" title="container 模式"></a>container 模式</h1><p>创建新的容器时指定和已存在的容器共享一个 Network namespace，这些容器之间共享 IP、端口范围等网络配置，容器之间传输效率高。两个容器除了网络资源共享之外，其他资源还是隔离的。虽然多个容器共享网络环境，但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离</p>
<p>启动一个名为 server1 的容器</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"server1"</span> centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>再启动两个容器，把它们加入到 server1 这个容器的 Network namespace</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"server2"</span> --network<span class="token operator">=</span>container:server1 centos:7.7.1908
docker container run -itd --name <span class="token string">"server3"</span> --network<span class="token operator">=</span>container:server1 centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看各个容器的 IP 地址</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker inspect --format<span class="token operator">=</span><span class="token string">'{{.NetworkSettings.Networks.bridge.IPAddress}}'</span> server1
172.17.0.3
docker inspect --format<span class="token operator">=</span><span class="token string">'{{.NetworkSettings.Networks.bridge.IPAddress}}'</span> server2
<span class="token operator">&lt;</span>no value<span class="token operator">></span>
docker inspect --format<span class="token operator">=</span><span class="token string">'{{.NetworkSettings.Networks.bridge.IPAddress}}'</span> server3
<span class="token operator">&lt;</span>no value<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们在查看 server2 和 server3 容器 IP 时，显示为 &lt;no value&gt;，其实它们是和 server1 共用一个 Network namespace 的</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container <span class="token function">exec</span> -it server2 /bin/bash
<span class="token punctuation">[</span>root@41436b0be6f7 /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>
eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets 10969  bytes 20985758 <span class="token punctuation">(</span>20.0 MiB<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 6234  bytes 344851 <span class="token punctuation">(</span>336.7 KiB<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker container <span class="token function">exec</span> -it server3 /bin/bash
<span class="token punctuation">[</span>root@41436b0be6f7 /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>
eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets 10969  bytes 20985758 <span class="token punctuation">(</span>20.0 MiB<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 6234  bytes 344851 <span class="token punctuation">(</span>336.7 KiB<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
<span class="token comment" spellcheck="true"># 两个容器的IP、主机名都相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="容器虚拟网卡和-docker0-网桥的-veth-pair-配对"><a href="#容器虚拟网卡和-docker0-网桥的-veth-pair-配对" class="headerlink" title="容器虚拟网卡和 docker0 网桥的 veth pair 配对"></a>容器虚拟网卡和 docker0 网桥的 veth pair 配对</h1><p>veth 是成对出现的虚拟网络设备， 发送到 veth 一端虚拟设备的请求会从另一端的虚拟设备中发出。创建一个容器的同时会为这个容器创建一对虚拟网卡 veth pair，这个成对出现的虚拟网卡 veth pair，分别放到宿主机和容器中，宿主机一端桥接到默认的 docker0 或者自定义的网桥上，容器一端放到新创建容器的 Network namespace 中，并把名字修改为 eth0。虚拟网卡 veth pair 就像是一根网线，将宿主机的 docker0 和容器连接起来</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"server1"</span> centos:7.7.1908    <span class="token comment" spellcheck="true"># 创建容器</span>

brctl show docker0    <span class="token comment" spellcheck="true"># 查看宿主机上的docker0网桥</span>
bridge name    bridge <span class="token function">id</span>        STP enabled    interfaces
docker0        8000.02429fdcee74    no        veth7459cf7

ip a s veth7459cf7    <span class="token comment" spellcheck="true"># 这是虚拟网卡veth pair在宿主机上的一端</span>
34: veth7459cf7@if33: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 86:54:3c:c6:70:6b brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet6 fe80::8454:3cff:fec6:706b/64 scope <span class="token function">link</span> 
       valid_lft forever preferred_lft forever

<span class="token punctuation">[</span>root@ec94bfbd724f /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig        # 容器内部的eth0网卡是虚拟网卡veth pair在容器中的一端</span>
eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets 5495  bytes 10346440 <span class="token punctuation">(</span>9.8 MiB<span class="token punctuation">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3386  bytes 186731 <span class="token punctuation">(</span>182.3 KiB<span class="token punctuation">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="容器网络访问原理图"><a href="#容器网络访问原理图" class="headerlink" title="容器网络访问原理图"></a>容器网络访问原理图</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<h1 id="容器网络实现的核心技术-iptables"><a href="#容器网络实现的核心技术-iptables" class="headerlink" title="容器网络实现的核心技术: iptables"></a>容器网络实现的核心技术: iptables</h1><p>docker 容器的跨网络隔离与通信，是使用 iptables 去实现的</p>
<h1 id="源IP地址变换规则"><a href="#源IP地址变换规则" class="headerlink" title="源IP地址变换规则"></a>源IP地址变换规则</h1><p>docker 在安装完成后，将默认在宿主机上增加一些 iptables 规则，以用于 docker 容器和容器之间的隔离与通信，可以使用使用 iptables-save 命令查看</p>
<pre class="line-numbers language-bash"><code class="language-bash">iptables-save <span class="token operator">|</span> <span class="token function">grep</span> docker
-A POSTROUTING -s 172.17.0.0/16 <span class="token operator">!</span> -o docker0 -j MASQUERADE

参数说明:
-s:源地址172.17.0.0/16
-o:指定数据报文流出接口为docker0
-j:动作为MASQUERADE<span class="token punctuation">(</span>地址伪装<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这条规则关系着 Docker 容器和外界的通信，含义是源地址为 172.17.0.0/16 的数据包(即Docker容器发出的数据)，当不是从 docker0 网卡发出时做 SNAT(源地址转换)。这样使得 Docker 容器访问外网的流量，在外界看来就是从宿主机上发出的，外界感觉不到 Docker 容器的存在</p>
<h1 id="目标IP地址变换规则"><a href="#目标IP地址变换规则" class="headerlink" title="目标IP地址变换规则"></a>目标IP地址变换规则</h1><p>从 Docker 容器访问外网的流量，在外部看来就是从宿主机上发出的，外部感觉不到 Docker 容器的存在。其实这也是由相应的 iptables 规则去实现的</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker container run -itd --name <span class="token string">"nginx"</span> -p 80:80 nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看创建容器之后生成的 iptables 规则</p>
<pre class="line-numbers language-bash"><code class="language-bash">iptables-save <span class="token operator">|</span> <span class="token function">grep</span> docker
-A DOCKER <span class="token operator">!</span> -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.2:80
-A DOCKER -d 172.17.0.2/32 <span class="token operator">!</span> -i docker0 -o docker0 -p tcp -m tcp --dport 80 -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这两条规则将访问宿主机的 80 端口的流量转发到了 172.17.0.2 的 80 端口上(即真正提供服务的 Docker 容器的IP+端口)，所以外界访问 Docker 容器是通过 iptables 做DNAT (目的地址转换)实现的</p>
<h1 id="etcd-和-flannel-实现-docker-跨主机通信"><a href="#etcd-和-flannel-实现-docker-跨主机通信" class="headerlink" title="etcd 和 flannel 实现 docker 跨主机通信"></a>etcd 和 flannel 实现 docker 跨主机通信</h1><p>flannel 是一种基于 overlay 网络的跨主机容器网络解决方案，也就是将 TCP 数据包封装在另一种网络包里面进行路由转发和通信，flannel 是 CoreOS 团队针对Kubernetes 设计的一个网络规划服务，让集群中的不同节点主机创建的容器都具有全集群唯一的虚拟 ip 地址，flannel 使用 go 语言编写</p>
<p>实现原理</p>
<p>flannel 为每个 host 分配一个 subnet，容器从这个 subnet 中分配 ip，这些 ip 可以在 host 间路由，容器间无需使用 nat 和端口映射即可实现跨主机通信。每个 subnet 都是从一个更大的 ip 池中划分的，flannel 会在每个主机上运行一个叫 flanneld 的 agent，其职责就是从池子中分配 subnet。etcd 相当于一个数据库，flannel 使用 etcd 存放网络配置、已分配的 subnet、host 的 IP 等信息</p>
<p>实验环境</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>安装软件</th>
<th>系统</th>
<th>内核版本</th>
<th>docker版本</th>
</tr>
</thead>
<tbody><tr>
<td>10.10.110.150(master)</td>
<td>etcd、flannel、docker</td>
<td>CentOS7.7.1908</td>
<td>3.10.0-1062.el7.x86_64</td>
<td>19.03.12</td>
</tr>
<tr>
<td>10.10.110.151(slave)</td>
<td>flannel、docker</td>
<td>CentOS7.7.1908</td>
<td>3.10.0-1062.el7.x86_64</td>
<td>19.03.12</td>
</tr>
</tbody></table>
<h1 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h1><p>安装配置 etcd</p>
<pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y etcd        <span class="token comment" spellcheck="true"># 安装etcd,由于不配置etcd集群,所以只在10.10.110.150节点安装etcd就行了</span>

<span class="token function">sed</span> -i <span class="token string">"s/localhost/10.10.110.150/g"</span> /etc/etcd/etcd.conf    <span class="token comment" spellcheck="true"># 修改etcd配置文件</span>

systemctl start etcd.service    <span class="token comment" spellcheck="true"># 启动etcd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装配置 flannel</p>
<pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y flannel

<span class="token function">sed</span> -i <span class="token string">"s/127.0.0.1/10.10.110.150/g"</span> /etc/sysconfig/flanneld    <span class="token comment" spellcheck="true"># flannel连接到etcd,slave连接也是填写master的IP</span>

etcdctl --endpoints<span class="token operator">=</span><span class="token string">"http://10.10.110.150:2379"</span> <span class="token keyword">set</span> /atomic.io/network/config <span class="token string">'{ "Network":"172.17.0.0/16", "Backend": {"Type": "vxlan"}} '</span>        <span class="token comment" spellcheck="true"># 配置etcd的子网,如果这一步不配置,那么etcd无法启动</span>

systemctl start flanneld.service    <span class="token comment" spellcheck="true"># 启动flannel</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h1><p>安装配置 flannel</p>
<pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y flannel

<span class="token function">sed</span> -i <span class="token string">"s/127.0.0.1/10.10.110.150/g"</span> /etc/sysconfig/flanneld    <span class="token comment" spellcheck="true"># 这里是填写master节点的IP,让slave连接到master的etcd,多slave也一样</span>

systemctl start flanneld.service    <span class="token comment" spellcheck="true"># 确保slave节点能连接到master节点的etcd,如果不关闭防火墙,那必须打开2379端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="配置-Docker-使用-flannel-的网络"><a href="#配置-Docker-使用-flannel-的网络" class="headerlink" title="配置 Docker 使用 flannel 的网络"></a>配置 Docker 使用 flannel 的网络</h1><p>master 节点</p>
<pre class="line-numbers language-bash"><code class="language-bash">vim /usr/lib/systemd/system/docker.service

EnvironmentFile<span class="token operator">=</span>/run/flannel/docker        <span class="token comment" spellcheck="true"># 加载这个文件里面的变量,这个文件记录了flannel分配给master节点的子网信息(slave也会有自己的子网)</span>

ExecStart<span class="token operator">=</span>/usr/bin/dockerd -H fd:// --containerd<span class="token operator">=</span>/run/containerd/containerd.sock <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>    <span class="token comment" spellcheck="true"># 这个变量是上面文件中定义的,意思是在启动容器时指定使用flannel分配的子网去配置容器的网络</span>

iptables -P FORWARD ACCEPT        <span class="token comment" spellcheck="true"># 开启iptables转发,如不开启即使配置成功也不能通信</span>

systemctl daemon-reload

systemctl restart flanneld.service    <span class="token comment" spellcheck="true"># 这里必须先重启flannel再重启docker,这时候启动容器就会使用flannel去配置容器的网络</span>

systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave 节点配置</p>
<pre class="line-numbers language-bash"><code class="language-bash">vim /usr/lib/systemd/system/docker.service

EnvironmentFile<span class="token operator">=</span>/run/flannel/docker        <span class="token comment" spellcheck="true"># 查看slave节点上这个文件,网段是和master节点不一样的</span>

ExecStart<span class="token operator">=</span>/usr/bin/dockerd -H fd:// --containerd<span class="token operator">=</span>/run/containerd/containerd.sock <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>

iptables -P FORWARD ACCEPT

systemctl daemon-reload

systemctl restart flanneld.service

systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="查看宿主机的IP变化"><a href="#查看宿主机的IP变化" class="headerlink" title="查看宿主机的IP变化"></a>查看宿主机的IP变化</h1><p>master 节点</p>
<pre class="line-numbers language-bash"><code class="language-bash">ip a
3: docker0: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:e3:89:96:4e brd ff:ff:ff:ff:ff:ff
    inet 172.17.98.1/24 brd 172.17.98.255 scope global docker0
       valid_lft forever preferred_lft forever
4: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN group default 
    link/ether 02:6f:fa:71:67:f7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.98.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::6f:faff:fe71:67f7/64 scope <span class="token function">link</span> 
       valid_lft forever preferred_lft forever    
<span class="token comment" spellcheck="true"># docker0虚拟网卡和flannel虚拟网卡已经在同一网段，这时候说明配置成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave 节点</p>
<pre class="line-numbers language-bash"><code class="language-bash">ip a
3: docker0: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:f2:30:ba:34 brd ff:ff:ff:ff:ff:ff
    inet 172.17.75.1/24 brd 172.17.75.255 scope global docker0
       valid_lft forever preferred_lft forever
4: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN group default 
    link/ether f6:ae:d1:c0:e1:a7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.75.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::f4ae:d1ff:fec0:e1a7/64 scope <span class="token function">link</span> 
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="在两个节点创建容器相互-ping-验证"><a href="#在两个节点创建容器相互-ping-验证" class="headerlink" title="在两个节点创建容器相互 ping 验证"></a>在两个节点创建容器相互 ping 验证</h2><p>master 节点</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run -it busybox sh
/ <span class="token comment" spellcheck="true"># ifconfig</span>
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:62:02  
          inet addr:172.17.98.2  Bcast:172.17.98.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:656 <span class="token punctuation">(</span>656.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>

/ <span class="token comment" spellcheck="true"># ping 172.17.75.2</span>
PING 172.17.75.2 <span class="token punctuation">(</span>172.17.75.2<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 172.17.75.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>62 time<span class="token operator">=</span>0.492 ms
64 bytes from 172.17.75.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>62 time<span class="token operator">=</span>0.353 ms
64 bytes from 172.17.75.2: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>62 time<span class="token operator">=</span>0.342 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave 节点</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run -it busybox sh
/ <span class="token comment" spellcheck="true"># ifconfig</span>
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:4B:02  
          inet addr:172.17.75.2  Bcast:172.17.75.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1
          RX packets:6 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:516 <span class="token punctuation">(</span>516.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>

/ <span class="token comment" spellcheck="true"># ping 172.17.98.2</span>
PING 172.17.98.2 <span class="token punctuation">(</span>172.17.98.2<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 172.17.98.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>62 time<span class="token operator">=</span>1.945 ms
64 bytes from 172.17.98.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>62 time<span class="token operator">=</span>0.344 ms
64 bytes from 172.17.98.2: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>62 time<span class="token operator">=</span>0.384 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：如果不能 ping 通，先重启 flannel 再重启 Docker 试试</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-09-28T02:52:36.000Z" itemprop="dateUpdated">2020-09-28 10:52:36</time>
</span><br>


        
        想给作者写留言，请在下面使用Github账号登录，留言支持Markdown语法。如果这篇文章对你有所帮助，那就请我喝咖啡吧！
        
    </div>
    
    <footer>
        <a href="/">
            <img src="https://pic.imgdb.cn/item/5e9e78b6c2a9a83be545fef2.jpg" alt="荒原饮露">
            荒原饮露
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/" rel="tag">容器技术</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">

  
    <div class="waves-block waves-effect prev">
      <a href="/post/a7b8d397.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev </div>
        <h4 class="title">Docker 容器数据持久化</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/post/44241b5a.html" id="post-next" class="post-nav-link">
        <div class="tips"> Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Dockerfile 定制容器镜像</h4>
      </a>
    </div>
  


</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: '23c466a5c9454511f778',
          clientSecret: '0175fa1cbbd5ae44c3a5adcd4a6ce32c0011032b',
          repo: 'mf-restart.github.io',
          owner: 'MF-ReStart',
          admin: ['MF-ReStart'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我喝咖啡吧~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://pic.imgdb.cn/item/5e9e7942c2a9a83be54666eb.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://pic.imgdb.cn/item/5e9e7942c2a9a83be54666eb.jpg" data-alipay="https://pic.imgdb.cn/item/5e9e795ac2a9a83be54675ba.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>荒原饮露 &copy; 2019 - 2021</span>
            <span id="alive"></span>
            <script type="text/javascript">
                function runtime(){
                    // 初始时间，日/月/年 时:分:秒
                    X = new Date("03/24/2019 9:30:00");
                    Y = new Date();
                    T = (Y.getTime()-X.getTime());
                    M = 24*60*60*1000;
                    a = T/M;
                    A = Math.floor(a);
                    b = (a-A)*24;
                    B = Math.floor(b);
                    c = (b-B)*60;
                    C = Math.floor((b-B)*60);
                    D = Math.floor((c-C)*60);
                    //信息写入到DIV中
                    var alive = document.getElementById("alive");
                    alive.innerHTML = "本站勉强运行 : "+A+"天"+B+"小时"+C+"分"+D+"秒"
                }
                setInterval(runtime, 1000);
            </script>
            
        </p>
        <br>
        <p>
            <span>
                
                <div class="github-badge">
    <a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动">
        <span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://github.com/" target="_blank"
       title="静态网页托管于 GitHub & Coding Pages">
        <span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub & Coding Pages</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://www.aliyun.com/" target="_blank" title="阿里云提供域名相关服务">
        <span class="badge-subject">DNS</span><span class="badge-value bg-blueviolet">Aliyun</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://github.com/yscoder/hexo-theme-indigo" target="_blank"
       title="站点使用 Indigo 主题">
        <span class="badge-subject">Theme</span><span class="badge-value bg-blue">indigo</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"
       title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可">
        <span class="badge-subject"><i class="icon icon-copyright"></i></span><span class="badge-value bg-lightgrey">BY-NC-SA 4.0</span></a>
</div>


    <div class="github-badge">
        <span class="badge-subject">UV</span><span class="badge-value bg-orange"
                                                                                   id="busuanzi_value_site_uv"></span>
    </div>
    <div class="github-badge">
        <span class="badge-subject">PV</span><span class="badge-value bg-brightgreen"
                                                                                   id="busuanzi_value_site_pv"></span>
    </div>
    <div class="github-badge">
        <span class="badge-subject">WordCount</span><span class="badge-value bg-blueviolet">
            
                4.6k
            
        </span>
    </div>


            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="/js/main.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
